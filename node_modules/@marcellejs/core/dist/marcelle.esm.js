import '@tensorflow/tfjs-backend-cpu';
import '@tensorflow/tfjs-backend-webgl';
import { formatDistanceToNow } from 'date-fns';
import * as most from '@most/core';
import { never } from '@most/core';
import { newDefaultScheduler, asap } from '@most/scheduler';
import { createAdapter } from '@most/adapter';
import autoBind from 'auto-bind';
import io from 'socket.io-client';
import authentication from '@feathersjs/authentication-client';
import feathers from '@feathersjs/feathers';
import socketio from '@feathersjs/socketio-client';
import memoryService from 'feathers-memory';
import localStorageService from 'feathers-localstorage';
import { cloneDeep } from 'lodash';
import sift from 'sift';
import { loadGraphModel } from '@tensorflow/tfjs-converter';
import { io as io$1, tidy as tidy$1, zeros as zeros$1, tensor as tensor$1, oneHot, tensor2d as tensor2d$1, train, image, browser } from '@tensorflow/tfjs-core';
import { LayersModel, loadLayersModel, sequential, layers, metrics } from '@tensorflow/tfjs-layers';
import { generator } from '@tensorflow/tfjs-data';
import { load } from '@tensorflow-models/coco-ssd';
import { Chart, ArcElement, BarController, BubbleController, CategoryScale, DoughnutController, Filler, Legend, LineElement, LineController, LinearScale, LogarithmicScale, PieController, PointElement, PolarAreaController, RadarController, RadialLinearScale, BarElement, ScatterController, TimeScale, TimeSeriesScale, Title, Tooltip } from 'chart.js';
import 'chartjs-adapter-luxon';
import { dequal } from 'dequal';
import { MatrixElement, MatrixController } from 'chartjs-chart-matrix';
import colorLib from '@kurkle/color';
import zoomPlugin from 'chartjs-plugin-zoom';
import loadImage from 'blueimp-load-image';
import kmeans from 'ml-kmeans';
import * as seedrandom from 'seedrandom';
import { KNNClassifier as KNNClassifier$1 } from '@tensorflow-models/knn-classifier';
import { load as load$1 } from '@tensorflow-models/mobilenet';
import { PCA as PCA$1 } from 'ml-pca';
import { util, SupportedModels, createDetector } from '@tensorflow-models/pose-detection';
import { ScatterGL } from 'scatter-gl';
import { UMAP } from 'umap-js';

function _mergeNamespaces(n, m) {
    m.forEach(function (e) {
        e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
            if (k !== 'default' && !(k in n)) {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    });
    return Object.freeze(n);
}

function noop$1() { }
const identity = x => x;
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function is_promise(value) {
    return value && typeof value === 'object' && typeof value.then === 'function';
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
let src_url_equal_anchor;
function src_url_equal(element_src, url) {
    if (!src_url_equal_anchor) {
        src_url_equal_anchor = document.createElement('a');
    }
    src_url_equal_anchor.href = url;
    return element_src === src_url_equal_anchor.href;
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
    if (store == null) {
        return noop$1;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
    let value;
    subscribe(store, _ => value = _)();
    return value;
}
function component_subscribe(component, store, callback) {
    component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
    }
}
function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn
        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
        : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
            return lets;
        }
        if (typeof lets === 'object') {
            const merged = [];
            const len = Math.max($$scope.dirty.length, lets.length);
            for (let i = 0; i < len; i += 1) {
                merged[i] = $$scope.dirty[i] | lets[i];
            }
            return merged;
        }
        return $$scope.dirty | lets;
    }
    return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
    if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
    }
}
function get_all_dirty_from_scope($$scope) {
    if ($$scope.ctx.length > 32) {
        const dirty = [];
        const length = $$scope.ctx.length / 32;
        for (let i = 0; i < length; i++) {
            dirty[i] = -1;
        }
        return dirty;
    }
    return -1;
}
function action_destroyer(action_result) {
    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop$1;
}

const is_client = typeof window !== 'undefined';
let now$1 = is_client
    ? () => window.performance.now()
    : () => Date.now();
let raf = is_client ? cb => requestAnimationFrame(cb) : noop$1;

const tasks = new Set();
function run_tasks(now) {
    tasks.forEach(task => {
        if (!task.c(now)) {
            tasks.delete(task);
            task.f();
        }
    });
    if (tasks.size !== 0)
        raf(run_tasks);
}
/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 */
function loop(callback) {
    let task;
    if (tasks.size === 0)
        raf(run_tasks);
    return {
        promise: new Promise(fulfill => {
            tasks.add(task = { c: callback, f: fulfill });
        }),
        abort() {
            tasks.delete(task);
        }
    };
}
function append(target, node) {
    target.appendChild(node);
}
function get_root_for_style(node) {
    if (!node)
        return document;
    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
    if (root && root.host) {
        return root;
    }
    return node.ownerDocument;
}
function append_empty_stylesheet(node) {
    const style_element = element('style');
    append_stylesheet(get_root_for_style(node), style_element);
    return style_element.sheet;
}
function append_stylesheet(node, style) {
    append(node.head || node, style);
    return style.sheet;
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}
function element(name) {
    return document.createElement(name);
}
function svg_element(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
}
function text$1(data) {
    return document.createTextNode(data);
}
function space() {
    return text$1(' ');
}
function empty() {
    return text$1('');
}
function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
    return function (event) {
        event.preventDefault();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function stop_propagation(fn) {
    return function (event) {
        event.stopPropagation();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function set_custom_element_data(node, prop, value) {
    if (prop in node) {
        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
    }
    else {
        attr(node, prop, value);
    }
}
function children(element) {
    return Array.from(element.childNodes);
}
function set_data(text, data) {
    data = '' + data;
    if (text.wholeText !== data)
        text.data = data;
}
function set_input_value(input, value) {
    input.value = value == null ? '' : value;
}
function set_style(node, key, value, important) {
    if (value === null) {
        node.style.removeProperty(key);
    }
    else {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
}
function select_option(select, value) {
    for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        if (option.__value === value) {
            option.selected = true;
            return;
        }
    }
    select.selectedIndex = -1; // no option should be selected
}
function select_value(select) {
    const selected_option = select.querySelector(':checked') || select.options[0];
    return selected_option && selected_option.__value;
}
// unfortunately this can't be a constant as that wouldn't be tree-shakeable
// so we cache the result instead
let crossorigin;
function is_crossorigin() {
    if (crossorigin === undefined) {
        crossorigin = false;
        try {
            if (typeof window !== 'undefined' && window.parent) {
                void window.parent.document;
            }
        }
        catch (error) {
            crossorigin = true;
        }
    }
    return crossorigin;
}
function add_resize_listener(node, fn) {
    const computed_style = getComputedStyle(node);
    if (computed_style.position === 'static') {
        node.style.position = 'relative';
    }
    const iframe = element('iframe');
    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
    iframe.setAttribute('aria-hidden', 'true');
    iframe.tabIndex = -1;
    const crossorigin = is_crossorigin();
    let unsubscribe;
    if (crossorigin) {
        iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
        unsubscribe = listen(window, 'message', (event) => {
            if (event.source === iframe.contentWindow)
                fn();
        });
    }
    else {
        iframe.src = 'about:blank';
        iframe.onload = () => {
            unsubscribe = listen(iframe.contentWindow, 'resize', fn);
        };
    }
    append(node, iframe);
    return () => {
        if (crossorigin) {
            unsubscribe();
        }
        else if (unsubscribe && iframe.contentWindow) {
            unsubscribe();
        }
        detach(iframe);
    };
}
function toggle_class(element, name, toggle) {
    element.classList[toggle ? 'add' : 'remove'](name);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, bubbles, cancelable, detail);
    return e;
}
class HtmlTag {
    constructor(is_svg = false) {
        this.is_svg = false;
        this.is_svg = is_svg;
        this.e = this.n = null;
    }
    c(html) {
        this.h(html);
    }
    m(html, target, anchor = null) {
        if (!this.e) {
            if (this.is_svg)
                this.e = svg_element(target.nodeName);
            else
                this.e = element(target.nodeName);
            this.t = target;
            this.c(html);
        }
        this.i(anchor);
    }
    h(html) {
        this.e.innerHTML = html;
        this.n = Array.from(this.e.childNodes);
    }
    i(anchor) {
        for (let i = 0; i < this.n.length; i += 1) {
            insert(this.t, this.n[i], anchor);
        }
    }
    p(html) {
        this.d();
        this.h(html);
        this.i(this.a);
    }
    d() {
        this.n.forEach(detach);
    }
}

// we need to store the information for multiple documents because a Svelte application could also contain iframes
// https://github.com/sveltejs/svelte/issues/3624
const managed_styles = new Map();
let active = 0;
// https://github.com/darkskyapp/string-hash/blob/master/index.js
function hash(str) {
    let hash = 5381;
    let i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return hash >>> 0;
}
function create_style_information(doc, node) {
    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
    managed_styles.set(doc, info);
    return info;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
    const step = 16.666 / duration;
    let keyframes = '{\n';
    for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
    }
    const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
    const name = `__svelte_${hash(rule)}_${uid}`;
    const doc = get_root_for_style(node);
    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
    if (!rules[name]) {
        rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
    }
    const animation = node.style.animation || '';
    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
    active += 1;
    return name;
}
function delete_rule(node, name) {
    const previous = (node.style.animation || '').split(', ');
    const next = previous.filter(name
        ? anim => anim.indexOf(name) < 0 // remove specific animation
        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
    );
    const deleted = previous.length - next.length;
    if (deleted) {
        node.style.animation = next.join(', ');
        active -= deleted;
        if (!active)
            clear_rules();
    }
}
function clear_rules() {
    raf(() => {
        if (active)
            return;
        managed_styles.forEach(info => {
            const { ownerNode } = info.stylesheet;
            // there is no ownerNode if it runs on jsdom.
            if (ownerNode)
                detach(ownerNode);
        });
        managed_styles.clear();
    });
}

function create_animation(node, from, fn, params) {
    if (!from)
        return noop$1;
    const to = node.getBoundingClientRect();
    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
        return noop$1;
    const { delay = 0, duration = 300, easing = identity, 
    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
    start: start_time = now$1() + delay, 
    // @ts-ignore todo:
    end = start_time + duration, tick = noop$1, css } = fn(node, { from, to }, params);
    let running = true;
    let started = false;
    let name;
    function start() {
        if (css) {
            name = create_rule(node, 0, 1, duration, delay, easing, css);
        }
        if (!delay) {
            started = true;
        }
    }
    function stop() {
        if (css)
            delete_rule(node, name);
        running = false;
    }
    loop(now => {
        if (!started && now >= start_time) {
            started = true;
        }
        if (started && now >= end) {
            tick(1, 0);
            stop();
        }
        if (!running) {
            return false;
        }
        if (started) {
            const p = now - start_time;
            const t = 0 + 1 * easing(p / duration);
            tick(t, 1 - t);
        }
        return true;
    });
    start();
    tick(0, 1);
    return stop;
}
function fix_position(node) {
    const style = getComputedStyle(node);
    if (style.position !== 'absolute' && style.position !== 'fixed') {
        const { width, height } = style;
        const a = node.getBoundingClientRect();
        node.style.position = 'absolute';
        node.style.width = width;
        node.style.height = height;
        add_transform(node, a);
    }
}
function add_transform(node, a) {
    const b = node.getBoundingClientRect();
    if (a.left !== b.left || a.top !== b.top) {
        const style = getComputedStyle(node);
        const transform = style.transform === 'none' ? '' : style.transform;
        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
    }
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error('Function called outside component initialization');
    return current_component;
}
/**
 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
 * it can be called from an external module).
 *
 * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
 *
 * https://svelte.dev/docs#run-time-svelte-onmount
 */
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
/**
 * Schedules a callback to run immediately after the component has been updated.
 *
 * The first time the callback runs will be after the initial `onMount`
 */
function afterUpdate(fn) {
    get_current_component().$$.after_update.push(fn);
}
/**
 * Schedules a callback to run immediately before the component is unmounted.
 *
 * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
 * only one that runs inside a server-side component.
 *
 * https://svelte.dev/docs#run-time-svelte-ondestroy
 */
function onDestroy(fn) {
    get_current_component().$$.on_destroy.push(fn);
}
/**
 * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).
 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
 *
 * Component events created with `createEventDispatcher` create a
 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
 * property and can contain any type of data.
 *
 * https://svelte.dev/docs#run-time-svelte-createeventdispatcher
 */
function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail, { cancelable = false } = {}) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
            // TODO are there situations where events could be dispatched
            // in a server (non-DOM) environment?
            const event = custom_event(type, detail, { cancelable });
            callbacks.slice().forEach(fn => {
                fn.call(component, event);
            });
            return !event.defaultPrevented;
        }
        return true;
    };
}
/**
 * Associates an arbitrary `context` object with the current component and the specified `key`
 * and returns that object. The context is then available to children of the component
 * (including slotted content) with `getContext`.
 *
 * Like lifecycle functions, this must be called during component initialisation.
 *
 * https://svelte.dev/docs#run-time-svelte-setcontext
 */
function setContext(key, context) {
    get_current_component().$$.context.set(key, context);
    return context;
}
/**
 * Retrieves the context that belongs to the closest parent component with the specified `key`.
 * Must be called during component initialisation.
 *
 * https://svelte.dev/docs#run-time-svelte-getcontext
 */
function getContext(key) {
    return get_current_component().$$.context.get(key);
}
// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
function bubble(component, event) {
    const callbacks = component.$$.callbacks[event.type];
    if (callbacks) {
        // @ts-ignore
        callbacks.slice().forEach(fn => fn.call(this, event));
    }
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function tick() {
    schedule_update();
    return resolved_promise;
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
function add_flush_callback(fn) {
    flush_callbacks.push(fn);
}
// flush() calls callbacks in this order:
// 1. All beforeUpdate callbacks, in order: parents before children
// 2. All bind:this callbacks, in reverse order: children before parents.
// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
//    for afterUpdates called during the initial onMount, which are called in
//    reverse order: children before parents.
// Since callbacks might update component values, which could trigger another
// call to flush(), the following steps guard against this:
// 1. During beforeUpdate, any updated components will be added to the
//    dirty_components array and will cause a reentrant call to flush(). Because
//    the flush index is kept outside the function, the reentrant call will pick
//    up where the earlier call left off and go through all dirty components. The
//    current_component value is saved and restored so that the reentrant call will
//    not interfere with the "parent" flush() call.
// 2. bind:this callbacks cannot trigger new flush() calls.
// 3. During afterUpdate, any updated components will NOT have their afterUpdate
//    callback called a second time; the seen_callbacks set, outside the flush()
//    function, guarantees this behavior.
const seen_callbacks = new Set();
let flushidx = 0; // Do *not* move this inside the flush() function
function flush() {
    const saved_component = current_component;
    do {
        // first, call beforeUpdate functions
        // and update components
        while (flushidx < dirty_components.length) {
            const component = dirty_components[flushidx];
            flushidx++;
            set_current_component(component);
            update(component.$$);
        }
        set_current_component(null);
        dirty_components.length = 0;
        flushidx = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    seen_callbacks.clear();
    set_current_component(saved_component);
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}

let promise;
function wait() {
    if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
            promise = null;
        });
    }
    return promise;
}
function dispatch(node, direction, kind) {
    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
    else if (callback) {
        callback();
    }
}
const null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
    let config = fn(node, params);
    let running = false;
    let animation_name;
    let task;
    let uid = 0;
    function cleanup() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop$1, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
        tick(0, 1);
        const start_time = now$1() + delay;
        const end_time = start_time + duration;
        if (task)
            task.abort();
        running = true;
        add_render_callback(() => dispatch(node, true, 'start'));
        task = loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(1, 0);
                    dispatch(node, true, 'end');
                    cleanup();
                    return running = false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(t, 1 - t);
                }
            }
            return running;
        });
    }
    let started = false;
    return {
        start() {
            if (started)
                return;
            started = true;
            delete_rule(node);
            if (is_function(config)) {
                config = config();
                wait().then(go);
            }
            else {
                go();
            }
        },
        invalidate() {
            started = false;
        },
        end() {
            if (running) {
                cleanup();
                running = false;
            }
        }
    };
}
function create_out_transition(node, fn, params) {
    let config = fn(node, params);
    let running = true;
    let animation_name;
    const group = outros;
    group.r += 1;
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop$1, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
        const start_time = now$1() + delay;
        const end_time = start_time + duration;
        add_render_callback(() => dispatch(node, false, 'start'));
        loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(0, 1);
                    dispatch(node, false, 'end');
                    if (!--group.r) {
                        // this will result in `end()` being called,
                        // so we don't need to clean up here
                        run_all(group.c);
                    }
                    return false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(1 - t, t);
                }
            }
            return running;
        });
    }
    if (is_function(config)) {
        wait().then(() => {
            // @ts-ignore
            config = config();
            go();
        });
    }
    else {
        go();
    }
    return {
        end(reset) {
            if (reset && config.tick) {
                config.tick(1, 0);
            }
            if (running) {
                if (animation_name)
                    delete_rule(node, animation_name);
                running = false;
            }
        }
    };
}
function create_bidirectional_transition(node, fn, params, intro) {
    let config = fn(node, params);
    let t = intro ? 0 : 1;
    let running_program = null;
    let pending_program = null;
    let animation_name = null;
    function clear_animation() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function init(program, duration) {
        const d = (program.b - t);
        duration *= Math.abs(d);
        return {
            a: t,
            b: program.b,
            d,
            duration,
            start: program.start,
            end: program.start + duration,
            group: program.group
        };
    }
    function go(b) {
        const { delay = 0, duration = 300, easing = identity, tick = noop$1, css } = config || null_transition;
        const program = {
            start: now$1() + delay,
            b
        };
        if (!b) {
            // @ts-ignore todo: improve typings
            program.group = outros;
            outros.r += 1;
        }
        if (running_program || pending_program) {
            pending_program = program;
        }
        else {
            // if this is an intro, and there's a delay, we need to do
            // an initial tick and/or apply CSS animation immediately
            if (css) {
                clear_animation();
                animation_name = create_rule(node, t, b, duration, delay, easing, css);
            }
            if (b)
                tick(0, 1);
            running_program = init(program, duration);
            add_render_callback(() => dispatch(node, b, 'start'));
            loop(now => {
                if (pending_program && now > pending_program.start) {
                    running_program = init(pending_program, duration);
                    pending_program = null;
                    dispatch(node, running_program.b, 'start');
                    if (css) {
                        clear_animation();
                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                    }
                }
                if (running_program) {
                    if (now >= running_program.end) {
                        tick(t = running_program.b, 1 - t);
                        dispatch(node, running_program.b, 'end');
                        if (!pending_program) {
                            // we're done
                            if (running_program.b) {
                                // intro — we can tidy up immediately
                                clear_animation();
                            }
                            else {
                                // outro — needs to be coordinated
                                if (!--running_program.group.r)
                                    run_all(running_program.group.c);
                            }
                        }
                        running_program = null;
                    }
                    else if (now >= running_program.start) {
                        const p = now - running_program.start;
                        t = running_program.a + running_program.d * easing(p / running_program.duration);
                        tick(t, 1 - t);
                    }
                }
                return !!(running_program || pending_program);
            });
        }
    }
    return {
        run(b) {
            if (is_function(config)) {
                wait().then(() => {
                    // @ts-ignore
                    config = config();
                    go(b);
                });
            }
            else {
                go(b);
            }
        },
        end() {
            clear_animation();
            running_program = pending_program = null;
        }
    };
}

function handle_promise(promise, info) {
    const token = info.token = {};
    function update(type, index, key, value) {
        if (info.token !== token)
            return;
        info.resolved = value;
        let child_ctx = info.ctx;
        if (key !== undefined) {
            child_ctx = child_ctx.slice();
            child_ctx[key] = value;
        }
        const block = type && (info.current = type)(child_ctx);
        let needs_flush = false;
        if (info.block) {
            if (info.blocks) {
                info.blocks.forEach((block, i) => {
                    if (i !== index && block) {
                        group_outros();
                        transition_out(block, 1, 1, () => {
                            if (info.blocks[i] === block) {
                                info.blocks[i] = null;
                            }
                        });
                        check_outros();
                    }
                });
            }
            else {
                info.block.d(1);
            }
            block.c();
            transition_in(block, 1);
            block.m(info.mount(), info.anchor);
            needs_flush = true;
        }
        info.block = block;
        if (info.blocks)
            info.blocks[index] = block;
        if (needs_flush) {
            flush();
        }
    }
    if (is_promise(promise)) {
        const current_component = get_current_component();
        promise.then(value => {
            set_current_component(current_component);
            update(info.then, 1, info.value, value);
            set_current_component(null);
        }, error => {
            set_current_component(current_component);
            update(info.catch, 2, info.error, error);
            set_current_component(null);
            if (!info.hasCatch) {
                throw error;
            }
        });
        // if we previously had a then/catch block, destroy it
        if (info.current !== info.pending) {
            update(info.pending, 0);
            return true;
        }
    }
    else {
        if (info.current !== info.then) {
            update(info.then, 1, info.value, promise);
            return true;
        }
        info.resolved = promise;
    }
}
function update_await_block_branch(info, ctx, dirty) {
    const child_ctx = ctx.slice();
    const { resolved } = info;
    if (info.current === info.then) {
        child_ctx[info.value] = resolved;
    }
    if (info.current === info.catch) {
        child_ctx[info.error] = resolved;
    }
    info.block.p(child_ctx, dirty);
}

const globals = (typeof window !== 'undefined'
    ? window
    : typeof globalThis !== 'undefined'
        ? globalThis
        : global);
function outro_and_destroy_block(block, lookup) {
    transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
    });
}
function fix_and_outro_and_destroy_block(block, lookup) {
    block.f();
    outro_and_destroy_block(block, lookup);
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
    let o = old_blocks.length;
    let n = list.length;
    let i = o;
    const old_indexes = {};
    while (i--)
        old_indexes[old_blocks[i].key] = i;
    const new_blocks = [];
    const new_lookup = new Map();
    const deltas = new Map();
    i = n;
    while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);
        if (!block) {
            block = create_each_block(key, child_ctx);
            block.c();
        }
        else if (dynamic) {
            block.p(child_ctx, dirty);
        }
        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes)
            deltas.set(key, Math.abs(i - old_indexes[key]));
    }
    const will_move = new Set();
    const did_move = new Set();
    function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
    }
    while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
            // do nothing
            next = new_block.first;
            o--;
            n--;
        }
        else if (!new_lookup.has(old_key)) {
            // remove old block
            destroy(old_block, lookup);
            o--;
        }
        else if (!lookup.has(new_key) || will_move.has(new_key)) {
            insert(new_block);
        }
        else if (did_move.has(old_key)) {
            o--;
        }
        else if (deltas.get(new_key) > deltas.get(old_key)) {
            did_move.add(new_key);
            insert(new_block);
        }
        else {
            will_move.add(old_key);
            o--;
        }
    }
    while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key))
            destroy(old_block, lookup);
    }
    while (n)
        insert(new_blocks[n - 1]);
    return new_blocks;
}

function bind(component, name, callback) {
    const index = component.$$.props[name];
    if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
    }
}
function create_component(block) {
    block && block.c();
}
function mount_component(component, target, anchor, customElement) {
    const { fragment, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
            // if the component was destroyed immediately
            // it will update the `$$.on_destroy` reference to `null`.
            // the destructured on_destroy may still reference to the old array
            if (component.$$.on_destroy) {
                component.$$.on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
    }
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
        fragment: null,
        ctx: [],
        // state
        props,
        update: noop$1,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false,
        root: options.target || parent_component.$$.root
    };
    append_styles && append_styles($$.root);
    let ready = false;
    $$.ctx = instance
        ? instance(component, options.props || {}, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor, options.customElement);
        flush();
    }
    set_current_component(parent_component);
}
/**
 * Base class for Svelte components. Used when dev=false.
 */
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop$1;
    }
    $on(type, callback) {
        if (!is_function(callback)) {
            return noop$1;
        }
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

/* ../design-system/dist/Button.svelte generated by Svelte v3.52.0 */

function create_fragment$14(ctx) {
	let t;
	let button;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	return {
		c() {
			t = space();
			button = element("button");
			if (default_slot) default_slot.c();
			attr(button, "class", "marcelle svelte-babmty");
			button.disabled = /*disabled*/ ctx[2];
			toggle_class(button, "outline", /*variant*/ ctx[1] === 'outline');
			toggle_class(button, "filled", /*variant*/ ctx[1] === 'filled');
			toggle_class(button, "light", /*variant*/ ctx[1] === 'light');
			toggle_class(button, "success", /*type*/ ctx[3] === 'success');
			toggle_class(button, "warning", /*type*/ ctx[3] === 'warning');
			toggle_class(button, "danger", /*type*/ ctx[3] === 'danger');
			toggle_class(button, "size-small", /*size*/ ctx[4] === 'small');
			toggle_class(button, "size-large", /*size*/ ctx[4] === 'large');
			toggle_class(button, "round", /*round*/ ctx[5]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
			insert(target, button, anchor);

			if (default_slot) {
				default_slot.m(button, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(document.body, "mouseup", function () {
						if (is_function(/*pressed*/ ctx[0] && /*stopDown*/ ctx[7])) (/*pressed*/ ctx[0] && /*stopDown*/ ctx[7]).apply(this, arguments);
					}),
					listen(button, "click", /*click_handler*/ ctx[10]),
					listen(button, "mousedown", /*startDown*/ ctx[6])
				];

				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*disabled*/ 4) {
				button.disabled = /*disabled*/ ctx[2];
			}

			if (!current || dirty & /*variant*/ 2) {
				toggle_class(button, "outline", /*variant*/ ctx[1] === 'outline');
			}

			if (!current || dirty & /*variant*/ 2) {
				toggle_class(button, "filled", /*variant*/ ctx[1] === 'filled');
			}

			if (!current || dirty & /*variant*/ 2) {
				toggle_class(button, "light", /*variant*/ ctx[1] === 'light');
			}

			if (!current || dirty & /*type*/ 8) {
				toggle_class(button, "success", /*type*/ ctx[3] === 'success');
			}

			if (!current || dirty & /*type*/ 8) {
				toggle_class(button, "warning", /*type*/ ctx[3] === 'warning');
			}

			if (!current || dirty & /*type*/ 8) {
				toggle_class(button, "danger", /*type*/ ctx[3] === 'danger');
			}

			if (!current || dirty & /*size*/ 16) {
				toggle_class(button, "size-small", /*size*/ ctx[4] === 'small');
			}

			if (!current || dirty & /*size*/ 16) {
				toggle_class(button, "size-large", /*size*/ ctx[4] === 'large');
			}

			if (!current || dirty & /*round*/ 32) {
				toggle_class(button, "round", /*round*/ ctx[5]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(t);
			if (detaching) detach(button);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$13($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { variant = 'outline' } = $$props;
	let { disabled = false } = $$props;
	let { type = 'default' } = $$props;
	let { size = 'medium' } = $$props;
	let { round = false } = $$props;
	let { pressed = false } = $$props;
	const dispatch = createEventDispatcher();

	function startDown() {
		$$invalidate(0, pressed = true);
		dispatch('pressed', pressed);
	}

	function stopDown() {
		$$invalidate(0, pressed = false);
		dispatch('pressed', pressed);
	}

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('variant' in $$props) $$invalidate(1, variant = $$props.variant);
		if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
		if ('type' in $$props) $$invalidate(3, type = $$props.type);
		if ('size' in $$props) $$invalidate(4, size = $$props.size);
		if ('round' in $$props) $$invalidate(5, round = $$props.round);
		if ('pressed' in $$props) $$invalidate(0, pressed = $$props.pressed);
		if ('$$scope' in $$props) $$invalidate(8, $$scope = $$props.$$scope);
	};

	return [
		pressed,
		variant,
		disabled,
		type,
		size,
		round,
		startDown,
		stopDown,
		$$scope,
		slots,
		click_handler
	];
}

class Button$1 extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$13, create_fragment$14, safe_not_equal, {
			variant: 1,
			disabled: 2,
			type: 3,
			size: 4,
			round: 5,
			pressed: 0
		});
	}
}

/* ../design-system/dist/Input.svelte generated by Svelte v3.52.0 */

function create_fragment$13(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "class", "marcelle svelte-t20lcy");
			input.disabled = /*disabled*/ ctx[2];
			attr(input, "type", /*type*/ ctx[3]);
			attr(input, "placeholder", /*placeholder*/ ctx[1]);
			input.value = /*value*/ ctx[0];
		},
		m(target, anchor) {
			insert(target, input, anchor);

			if (!mounted) {
				dispose = listen(input, "input", /*handleInput*/ ctx[4]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*disabled*/ 4) {
				input.disabled = /*disabled*/ ctx[2];
			}

			if (dirty & /*type*/ 8) {
				attr(input, "type", /*type*/ ctx[3]);
			}

			if (dirty & /*placeholder*/ 2) {
				attr(input, "placeholder", /*placeholder*/ ctx[1]);
			}

			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				input.value = /*value*/ ctx[0];
			}
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			dispose();
		}
	};
}

function instance$12($$self, $$props, $$invalidate) {
	let { placeholder = '' } = $$props;
	let { disabled = false } = $$props;
	let { type = 'text' } = $$props;
	let { value = null } = $$props;

	function handleInput(e) {
		$$invalidate(0, value = e.currentTarget.value);
	}

	$$self.$$set = $$props => {
		if ('placeholder' in $$props) $$invalidate(1, placeholder = $$props.placeholder);
		if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
		if ('type' in $$props) $$invalidate(3, type = $$props.type);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
	};

	return [value, placeholder, disabled, type, handleInput];
}

class Input extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$12, create_fragment$13, safe_not_equal, {
			placeholder: 1,
			disabled: 2,
			type: 3,
			value: 0
		});
	}
}

/* ../design-system/dist/Modal.svelte generated by Svelte v3.52.0 */

function create_fragment$12(ctx) {
	let div3;
	let div1;
	let div0;
	let t;
	let div2;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			div3 = element("div");
			div1 = element("div");
			div0 = element("div");
			t = space();
			div2 = element("div");
			if (default_slot) default_slot.c();
			attr(div0, "class", "absolute inset-0 bg-gray-500 opacity-50");
			attr(div1, "class", "overlay svelte-nr9mik");
			attr(div2, "class", "modal svelte-nr9mik");
			attr(div3, "class", "modal-container svelte-nr9mik");
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div1);
			append(div1, div0);
			append(div3, t);
			append(div3, div2);

			if (default_slot) {
				default_slot.m(div2, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(div0, "click", /*onOutsideClick*/ ctx[0]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div3);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$11($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	const dispatch = createEventDispatcher();

	function quit() {
		dispatch('quit');
	}

	function onOutsideClick() {
		quit();
	}

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [onOutsideClick, quit, $$scope, slots];
}

class Modal extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$11, create_fragment$12, safe_not_equal, { quit: 1 });
	}

	get quit() {
		return this.$$.ctx[1];
	}
}

function cubicInOut(t) {
    return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;
}
function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}

function blur(node, { delay = 0, duration = 400, easing = cubicInOut, amount = 5, opacity = 0 } = {}) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const f = style.filter === 'none' ? '' : style.filter;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (_t, u) => `opacity: ${target_opacity - (od * u)}; filter: ${f} blur(${u * amount}px);`
    };
}
function slide(node, { delay = 0, duration = 400, easing = cubicOut } = {}) {
    const style = getComputedStyle(node);
    const opacity = +style.opacity;
    const height = parseFloat(style.height);
    const padding_top = parseFloat(style.paddingTop);
    const padding_bottom = parseFloat(style.paddingBottom);
    const margin_top = parseFloat(style.marginTop);
    const margin_bottom = parseFloat(style.marginBottom);
    const border_top_width = parseFloat(style.borderTopWidth);
    const border_bottom_width = parseFloat(style.borderBottomWidth);
    return {
        delay,
        duration,
        easing,
        css: t => 'overflow: hidden;' +
            `opacity: ${Math.min(t * 20, 1) * opacity};` +
            `height: ${t * height}px;` +
            `padding-top: ${t * padding_top}px;` +
            `padding-bottom: ${t * padding_bottom}px;` +
            `margin-top: ${t * margin_top}px;` +
            `margin-bottom: ${t * margin_bottom}px;` +
            `border-top-width: ${t * border_top_width}px;` +
            `border-bottom-width: ${t * border_bottom_width}px;`
    };
}
function scale(node, { delay = 0, duration = 400, easing = cubicOut, start = 0, opacity = 0 } = {}) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === 'none' ? '' : style.transform;
    const sd = 1 - start;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (_t, u) => `
			transform: ${transform} scale(${1 - (sd * u)});
			opacity: ${target_opacity - (od * u)}
		`
    };
}

function flip(node, { from, to }, params = {}) {
    const style = getComputedStyle(node);
    const transform = style.transform === 'none' ? '' : style.transform;
    const [ox, oy] = style.transformOrigin.split(' ').map(parseFloat);
    const dx = (from.left + from.width * ox / to.width) - (to.left + ox);
    const dy = (from.top + from.height * oy / to.height) - (to.top + oy);
    const { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;
    return {
        delay,
        duration: is_function(duration) ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,
        easing,
        css: (t, u) => {
            const x = u * dx;
            const y = u * dy;
            const sx = t + u * from.width / to.width;
            const sy = t + u * from.height / to.height;
            return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;
        }
    };
}

/* ../design-system/dist/Notification.svelte generated by Svelte v3.52.0 */

function get_each_context$h(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i].title;
	child_ctx[6] = list[i].message;
	child_ctx[7] = list[i].type;
	child_ctx[8] = list[i].id;
	return child_ctx;
}

// (49:34) 
function create_if_block_1$i(ctx) {
	let path;

	return {
		c() {
			path = svg_element("path");
			attr(path, "d", "M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0\n                4.34 4.34a8 8 0 0 0 11.32 11.32zM9 5h2v6H9V5zm0 8h2v2H9v-2z");
		},
		m(target, anchor) {
			insert(target, path, anchor);
		},
		d(detaching) {
			if (detaching) detach(path);
		}
	};
}

// (44:6) {#if type === 'default'}
function create_if_block$E(ctx) {
	let path;

	return {
		c() {
			path = svg_element("path");
			attr(path, "d", "M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0\n                4.34 4.34a8 8 0 0 0 11.32 11.32zM9 11V9h2v6H9v-4zm0-6h2v2H9V5z");
		},
		m(target, anchor) {
			insert(target, path, anchor);
		},
		d(detaching) {
			if (detaching) detach(path);
		}
	};
}

// (26:1) {#each notifications.slice(0, 10) as { title, message, type, id }
function create_each_block$h(key_1, ctx) {
	let div4;
	let div3;
	let div0;
	let svg0;
	let t0;
	let div1;
	let p0;
	let t1_value = /*title*/ ctx[5] + "";
	let t1;
	let t2;
	let p1;
	let t3_value = /*message*/ ctx[6] + "";
	let t3;
	let t4;
	let div2;
	let svg1;
	let title;
	let t5;
	let path;
	let t6;
	let div4_transition;
	let rect;
	let stop_animation = noop$1;
	let current;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*type*/ ctx[7] === 'default') return create_if_block$E;
		if (/*type*/ ctx[7] === 'danger') return create_if_block_1$i;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	function click_handler() {
		return /*click_handler*/ ctx[3](/*id*/ ctx[8]);
	}

	return {
		key: key_1,
		first: null,
		c() {
			div4 = element("div");
			div3 = element("div");
			div0 = element("div");
			svg0 = svg_element("svg");
			if (if_block) if_block.c();
			t0 = space();
			div1 = element("div");
			p0 = element("p");
			t1 = text$1(t1_value);
			t2 = space();
			p1 = element("p");
			t3 = text$1(t3_value);
			t4 = space();
			div2 = element("div");
			svg1 = svg_element("svg");
			title = svg_element("title");
			t5 = text$1("Close");
			path = svg_element("path");
			t6 = space();
			attr(svg0, "class", "notification-svg mr-4 svelte-r4ekig");
			attr(svg0, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg0, "viewBox", "0 0 20 20");
			toggle_class(svg0, "default", /*type*/ ctx[7] === 'default');
			toggle_class(svg0, "danger", /*type*/ ctx[7] === 'danger');
			attr(div0, "class", "py-1");
			attr(p0, "class", "my-1 font-bold");
			attr(p1, "class", "my-1 text-sm");
			attr(path, "d", "M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1\n              1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10\n              8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0\n              1.698z");
			attr(svg1, "class", "notification-svg ml-4 cursor-pointer svelte-r4ekig");
			attr(svg1, "role", "button");
			attr(svg1, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg1, "viewBox", "0 0 20 20");
			toggle_class(svg1, "default", /*type*/ ctx[7] === 'default');
			toggle_class(svg1, "danger", /*type*/ ctx[7] === 'danger');
			attr(div3, "class", "flex items-start");
			attr(div4, "class", "notification-card svelte-r4ekig");
			attr(div4, "role", "alert");
			toggle_class(div4, "default", /*type*/ ctx[7] === 'default');
			toggle_class(div4, "danger", /*type*/ ctx[7] === 'danger');
			this.first = div4;
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			append(div4, div3);
			append(div3, div0);
			append(div0, svg0);
			if (if_block) if_block.m(svg0, null);
			append(div3, t0);
			append(div3, div1);
			append(div1, p0);
			append(p0, t1);
			append(div1, t2);
			append(div1, p1);
			append(p1, t3);
			append(div3, t4);
			append(div3, div2);
			append(div2, svg1);
			append(svg1, title);
			append(title, t5);
			append(svg1, path);
			append(div4, t6);
			current = true;

			if (!mounted) {
				dispose = listen(svg1, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg0, null);
				}
			}

			if (!current || dirty & /*notifications*/ 1) {
				toggle_class(svg0, "default", /*type*/ ctx[7] === 'default');
			}

			if (!current || dirty & /*notifications*/ 1) {
				toggle_class(svg0, "danger", /*type*/ ctx[7] === 'danger');
			}

			if ((!current || dirty & /*notifications*/ 1) && t1_value !== (t1_value = /*title*/ ctx[5] + "")) set_data(t1, t1_value);
			if ((!current || dirty & /*notifications*/ 1) && t3_value !== (t3_value = /*message*/ ctx[6] + "")) set_data(t3, t3_value);

			if (!current || dirty & /*notifications*/ 1) {
				toggle_class(svg1, "default", /*type*/ ctx[7] === 'default');
			}

			if (!current || dirty & /*notifications*/ 1) {
				toggle_class(svg1, "danger", /*type*/ ctx[7] === 'danger');
			}

			if (!current || dirty & /*notifications*/ 1) {
				toggle_class(div4, "default", /*type*/ ctx[7] === 'default');
			}

			if (!current || dirty & /*notifications*/ 1) {
				toggle_class(div4, "danger", /*type*/ ctx[7] === 'danger');
			}
		},
		r() {
			rect = div4.getBoundingClientRect();
		},
		f() {
			fix_position(div4);
			stop_animation();
			add_transform(div4, rect);
		},
		a() {
			stop_animation();
			stop_animation = create_animation(div4, rect, flip, {});
		},
		i(local) {
			if (current) return;

			add_render_callback(() => {
				if (!div4_transition) div4_transition = create_bidirectional_transition(div4, blur, { amount: 10 }, true);
				div4_transition.run(1);
			});

			current = true;
		},
		o(local) {
			if (!div4_transition) div4_transition = create_bidirectional_transition(div4, blur, { amount: 10 }, false);
			div4_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div4);

			if (if_block) {
				if_block.d();
			}

			if (detaching && div4_transition) div4_transition.end();
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$11(ctx) {
	let div;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let current;
	let each_value = /*notifications*/ ctx[0].slice(0, 10);
	const get_key = ctx => /*id*/ ctx[8];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$h(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$h(key, child_ctx));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "marcelle notification-container svelte-r4ekig");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*notifications, close*/ 3) {
				each_value = /*notifications*/ ctx[0].slice(0, 10);
				group_outros();
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, fix_and_outro_and_destroy_block, create_each_block$h, null, get_each_context$h);
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();
				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};
}

function instance$10($$self, $$props, $$invalidate) {
	let { notifications = [] } = $$props;

	function close(id) {
		$$invalidate(0, notifications = notifications.filter(x => x.id !== id));
	}

	let uid = 1;

	function add({ title, message, type = 'default', duration = 3000 }) {
		const n = { id: uid, title, message, type };
		uid += 1;
		$$invalidate(0, notifications = [...notifications, n]);

		if (duration > 0) {
			setTimeout(
				() => {
					close(n.id);
				},
				duration
			);
		}
	}

	const click_handler = id => close(id);

	$$self.$$set = $$props => {
		if ('notifications' in $$props) $$invalidate(0, notifications = $$props.notifications);
	};

	return [notifications, close, add, click_handler];
}

class Notification extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$10, create_fragment$11, safe_not_equal, { notifications: 0, add: 2 });
	}

	get add() {
		return this.$$.ctx[2];
	}
}

/* ../design-system/dist/Number.svelte generated by Svelte v3.52.0 */

function create_fragment$10(ctx) {
	let div;
	let button0;
	let t0;
	let t1;
	let input;
	let t2;
	let button1;
	let t3;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			button0 = element("button");
			t0 = text$1("-");
			t1 = space();
			input = element("input");
			t2 = space();
			button1 = element("button");
			t3 = text$1("+");
			button0.disabled = /*disabled*/ ctx[1];
			attr(button0, "class", "left svelte-9ymaj0");
			attr(input, "type", "number");
			attr(input, "inputmode", "decimal");
			input.value = /*value*/ ctx[0];
			input.disabled = /*disabled*/ ctx[1];
			set_style(input, "width", "80px");
			attr(input, "class", "svelte-9ymaj0");
			button1.disabled = /*disabled*/ ctx[1];
			attr(button1, "class", "right svelte-9ymaj0");
			attr(div, "class", "flex");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, button0);
			append(button0, t0);
			append(div, t1);
			append(div, input);
			append(div, t2);
			append(div, button1);
			append(button1, t3);

			if (!mounted) {
				dispose = [
					listen(button0, "click", /*click_handler*/ ctx[3]),
					listen(input, "change", /*changeValue*/ ctx[2]),
					listen(button1, "click", /*click_handler_1*/ ctx[4])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*disabled*/ 2) {
				button0.disabled = /*disabled*/ ctx[1];
			}

			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				input.value = /*value*/ ctx[0];
			}

			if (dirty & /*disabled*/ 2) {
				input.disabled = /*disabled*/ ctx[1];
			}

			if (dirty & /*disabled*/ 2) {
				button1.disabled = /*disabled*/ ctx[1];
			}
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$$($$self, $$props, $$invalidate) {
	let { disabled = false } = $$props;
	let { value } = $$props;

	function changeValue(e) {
		const target = e.target;
		const x = parseFloat(target.value);

		if (!Number.isNaN(x)) {
			$$invalidate(0, value = x);
		} else {
			target.value = value.toString();
		}
	}

	const click_handler = () => {
		$$invalidate(0, value -= 1);
	};

	const click_handler_1 = () => {
		$$invalidate(0, value += 1);
	};

	$$self.$$set = $$props => {
		if ('disabled' in $$props) $$invalidate(1, disabled = $$props.disabled);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
	};

	return [value, disabled, changeValue, click_handler, click_handler_1];
}

class Number_1 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$$, create_fragment$10, safe_not_equal, { disabled: 1, value: 0 });
	}
}

/* ../design-system/dist/NumberArray.svelte generated by Svelte v3.52.0 */

function get_each_context$g(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[12] = list[i];
	child_ctx[14] = i;
	return child_ctx;
}

// (33:0) {#if value && Array.isArray(value)}
function create_if_block$D(ctx) {
	let div;
	let t0;
	let button0;
	let t1;
	let t2;
	let button1;
	let t3;
	let mounted;
	let dispose;
	let each_value = /*value*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$g(get_each_context$g(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			button0 = element("button");
			t1 = text$1("-");
			t2 = space();
			button1 = element("button");
			t3 = text$1("+");
			button0.disabled = /*disabled*/ ctx[1];
			attr(button0, "class", "left svelte-9ymaj0");
			button1.disabled = /*disabled*/ ctx[1];
			attr(button1, "class", "right svelte-9ymaj0");
			set_style(button1, "border-left", "none");
			attr(div, "class", "flex items-center");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append(div, t0);
			append(div, button0);
			append(button0, t1);
			append(div, t2);
			append(div, button1);
			append(button1, t3);

			if (!mounted) {
				dispose = [
					listen(button0, "click", /*click_handler_2*/ ctx[10]),
					listen(button1, "click", /*click_handler_3*/ ctx[11])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*disabled, increment, value, changeValue, decrement*/ 31) {
				each_value = /*value*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$g(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$g(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, t0);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*disabled*/ 2) {
				button0.disabled = /*disabled*/ ctx[1];
			}

			if (dirty & /*disabled*/ 2) {
				button1.disabled = /*disabled*/ ctx[1];
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (35:2) {#each value as v, i}
function create_each_block$g(ctx) {
	let div;
	let button0;
	let t0;
	let t1;
	let input;
	let input_value_value;
	let t2;
	let button1;
	let t3;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[7](/*i*/ ctx[14]);
	}

	function change_handler(...args) {
		return /*change_handler*/ ctx[8](/*i*/ ctx[14], ...args);
	}

	function click_handler_1() {
		return /*click_handler_1*/ ctx[9](/*i*/ ctx[14]);
	}

	return {
		c() {
			div = element("div");
			button0 = element("button");
			t0 = text$1("-");
			t1 = space();
			input = element("input");
			t2 = space();
			button1 = element("button");
			t3 = text$1("+");
			button0.disabled = /*disabled*/ ctx[1];
			attr(button0, "class", "left svelte-9ymaj0");
			attr(input, "type", "number");
			attr(input, "inputmode", "decimal");
			input.value = input_value_value = /*v*/ ctx[12];
			input.disabled = /*disabled*/ ctx[1];
			set_style(input, "width", "80px");
			attr(input, "class", "svelte-9ymaj0");
			button1.disabled = /*disabled*/ ctx[1];
			attr(button1, "class", "right svelte-9ymaj0");
			attr(div, "class", "flex mr-2");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, button0);
			append(button0, t0);
			append(div, t1);
			append(div, input);
			append(div, t2);
			append(div, button1);
			append(button1, t3);

			if (!mounted) {
				dispose = [
					listen(button0, "click", click_handler),
					listen(input, "change", change_handler),
					listen(button1, "click", click_handler_1)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*disabled*/ 2) {
				button0.disabled = /*disabled*/ ctx[1];
			}

			if (dirty & /*value*/ 1 && input_value_value !== (input_value_value = /*v*/ ctx[12]) && input.value !== input_value_value) {
				input.value = input_value_value;
			}

			if (dirty & /*disabled*/ 2) {
				input.disabled = /*disabled*/ ctx[1];
			}

			if (dirty & /*disabled*/ 2) {
				button1.disabled = /*disabled*/ ctx[1];
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$$(ctx) {
	let show_if = /*value*/ ctx[0] && Array.isArray(/*value*/ ctx[0]);
	let if_block_anchor;
	let if_block = show_if && create_if_block$D(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (dirty & /*value*/ 1) show_if = /*value*/ ctx[0] && Array.isArray(/*value*/ ctx[0]);

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$D(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$_($$self, $$props, $$invalidate) {
	let { disabled = false } = $$props;
	let { value } = $$props;

	function changeValue(e, i) {
		const target = e.target;
		const x = parseFloat(target.value);

		if (!Number.isNaN(x)) {
			$$invalidate(0, value[i] = x, value);
		} else {
			target.value = value[i].toString();
		}
	}

	function decrement(i) {
		const v = value.slice();
		v[i] -= 1;
		$$invalidate(0, value = v);
	}

	function increment(i) {
		const v = value.slice();
		v[i] += 1;
		$$invalidate(0, value = v);
	}

	function extend() {
		const v = value.slice();
		v.push(v.length ? v[v.length - 1] : 0);
		$$invalidate(0, value = v);
	}

	function reduce() {
		$$invalidate(0, value = value.slice(0, value.length - 1));
	}

	const click_handler = i => decrement(i);
	const change_handler = (i, e) => changeValue(e, i);
	const click_handler_1 = i => increment(i);
	const click_handler_2 = () => reduce();
	const click_handler_3 = () => extend();

	$$self.$$set = $$props => {
		if ('disabled' in $$props) $$invalidate(1, disabled = $$props.disabled);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
	};

	return [
		value,
		disabled,
		changeValue,
		decrement,
		increment,
		extend,
		reduce,
		click_handler,
		change_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3
	];
}

class NumberArray$1 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$_, create_fragment$$, safe_not_equal, { disabled: 1, value: 0 });
	}
}

/* ../design-system/dist/PopMenu.svelte generated by Svelte v3.52.0 */

function get_each_context$f(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	return child_ctx;
}

// (37:1) <Button size="small" round on:click={toggleDropdown}>
function create_default_slot$G(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "d", "M10 12a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm0-6a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm0 12a2 2 0 1 1 0-4 2 2 0 0 1 0 4z");
			attr(svg, "class", "fill-current inline-block h-5 w-5");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "viewBox", "0 0 20 20");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (48:1) {#if showDropdown}
function create_if_block$C(ctx) {
	let div2;
	let div1;
	let div0;
	let div2_transition;
	let current;
	let each_value = /*actions*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
	}

	return {
		c() {
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div0, "class", "py-1");
			attr(div0, "role", "menu");
			attr(div0, "aria-orientation", "vertical");
			attr(div0, "aria-labelledby", "options-menu");
			attr(div1, "class", "origin-top-right absolute right-0 mt-1 w-56 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none");
			attr(div2, "class", "origin-top-right absolute right-0 mt-2 w-56 rounded-md shadow-lg z-50");
			toggle_class(div2, "hidden", false);
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div1);
			append(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*selectAction, actions*/ 9) {
				each_value = /*actions*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$f(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$f(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i(local) {
			if (current) return;

			add_render_callback(() => {
				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, slide, { duration: 100 }, true);
				div2_transition.run(1);
			});

			current = true;
		},
		o(local) {
			if (!div2_transition) div2_transition = create_bidirectional_transition(div2, slide, { duration: 100 }, false);
			div2_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			destroy_each(each_blocks, detaching);
			if (detaching && div2_transition) div2_transition.end();
		}
	};
}

// (58:5) {#each actions as action}
function create_each_block$f(ctx) {
	let button;
	let t0_value = /*action*/ ctx[7].text + "";
	let t0;
	let t1;
	let mounted;
	let dispose;

	function click_handler_1() {
		return /*click_handler_1*/ ctx[5](/*action*/ ctx[7]);
	}

	return {
		c() {
			button = element("button");
			t0 = text$1(t0_value);
			t1 = space();
			attr(button, "class", "text-sm py-2 px-4 font-normal block w-full whitespace-no-wrap bg-transparent text-gray-800 hover:bg-gray-100 border-0 cursor-pointer");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t0);
			append(button, t1);

			if (!mounted) {
				dispose = listen(button, "click", click_handler_1);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*actions*/ 1 && t0_value !== (t0_value = /*action*/ ctx[7].text + "")) set_data(t0, t0_value);
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$_(ctx) {
	let t0;
	let div;
	let button;
	let t1;
	let current;
	let mounted;
	let dispose;

	button = new Button$1({
			props: {
				size: "small",
				round: true,
				$$slots: { default: [create_default_slot$G] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*toggleDropdown*/ ctx[2]);
	let if_block = /*showDropdown*/ ctx[1] && create_if_block$C(ctx);

	return {
		c() {
			t0 = space();
			div = element("div");
			create_component(button.$$.fragment);
			t1 = space();
			if (if_block) if_block.c();
			attr(div, "class", "relative");
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, div, anchor);
			mount_component(button, div, null);
			append(div, t1);
			if (if_block) if_block.m(div, null);
			current = true;

			if (!mounted) {
				dispose = listen(document.body, "click", /*click_handler*/ ctx[4]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 1024) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);

			if (/*showDropdown*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*showDropdown*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$C(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(div);
			destroy_component(button);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

function instance$Z($$self, $$props, $$invalidate) {
	let { actions = [] } = $$props;
	const dispatch = createEventDispatcher();
	let showDropdown = false;

	function toggleDropdown(e) {
		e.stopPropagation();

		if (showDropdown) {
			$$invalidate(1, showDropdown = false);
		} else {
			$$invalidate(1, showDropdown = true);
		}
	}

	function selectAction(code) {
		dispatch('select', code);
	}

	const click_handler = () => {
		$$invalidate(1, showDropdown = false);
	};

	const click_handler_1 = action => selectAction(action.code);

	$$self.$$set = $$props => {
		if ('actions' in $$props) $$invalidate(0, actions = $$props.actions);
	};

	return [
		actions,
		showDropdown,
		toggleDropdown,
		selectAction,
		click_handler,
		click_handler_1
	];
}

class PopMenu extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$Z, create_fragment$_, safe_not_equal, { actions: 0 });
	}
}

/* ../design-system/dist/Progress.svelte generated by Svelte v3.52.0 */

function create_fragment$Z(ctx) {
	let div;
	let div_style_value;

	return {
		c() {
			div = element("div");
			attr(div, "class", "progress-line svelte-1w3676e");

			attr(div, "style", div_style_value = /*progress*/ ctx[0] >= 0
			? `--bar-mr: ${100 - Math.floor(/*progress*/ ctx[0] * 100)}%;`
			: '--bar-mr: 0px');

			toggle_class(div, "thin", /*thin*/ ctx[2]);
			toggle_class(div, "indeterminate", /*progress*/ ctx[0] === undefined || /*progress*/ ctx[0] === null || /*progress*/ ctx[0] < 0);
			toggle_class(div, "gray", /*type*/ ctx[1] === 'idle');
			toggle_class(div, "green", /*type*/ ctx[1] === 'success');
			toggle_class(div, "red", /*type*/ ctx[1] === 'danger');
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, [dirty]) {
			if (dirty & /*progress*/ 1 && div_style_value !== (div_style_value = /*progress*/ ctx[0] >= 0
			? `--bar-mr: ${100 - Math.floor(/*progress*/ ctx[0] * 100)}%;`
			: '--bar-mr: 0px')) {
				attr(div, "style", div_style_value);
			}

			if (dirty & /*thin*/ 4) {
				toggle_class(div, "thin", /*thin*/ ctx[2]);
			}

			if (dirty & /*progress, undefined*/ 1) {
				toggle_class(div, "indeterminate", /*progress*/ ctx[0] === undefined || /*progress*/ ctx[0] === null || /*progress*/ ctx[0] < 0);
			}

			if (dirty & /*type*/ 2) {
				toggle_class(div, "gray", /*type*/ ctx[1] === 'idle');
			}

			if (dirty & /*type*/ 2) {
				toggle_class(div, "green", /*type*/ ctx[1] === 'success');
			}

			if (dirty & /*type*/ 2) {
				toggle_class(div, "red", /*type*/ ctx[1] === 'danger');
			}
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function instance$Y($$self, $$props, $$invalidate) {
	let { progress } = $$props;
	let { type = 'default' } = $$props;
	let { thin = false } = $$props;

	$$self.$$set = $$props => {
		if ('progress' in $$props) $$invalidate(0, progress = $$props.progress);
		if ('type' in $$props) $$invalidate(1, type = $$props.type);
		if ('thin' in $$props) $$invalidate(2, thin = $$props.thin);
	};

	return [progress, type, thin];
}

class Progress extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$Y, create_fragment$Z, safe_not_equal, { progress: 0, type: 1, thin: 2 });
	}
}

/* ../design-system/dist/Select.svelte generated by Svelte v3.52.0 */

function get_each_context$e(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	return child_ctx;
}

// (15:2) {#if placeholder}
function create_if_block$B(ctx) {
	let option;
	let t;

	return {
		c() {
			option = element("option");
			t = text$1(/*placeholder*/ ctx[2]);
			option.__value = "";
			option.value = option.__value;
			option.disabled = true;
			attr(option, "class", "svelte-g3sqa4");
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty & /*placeholder*/ 4) set_data(t, /*placeholder*/ ctx[2]);
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (18:2) {#each options as option}
function create_each_block$e(ctx) {
	let option;
	let t_value = /*option*/ ctx[7] + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text$1(t_value);
			option.__value = option_value_value = /*option*/ ctx[7];
			option.value = option.__value;
			attr(option, "class", "svelte-g3sqa4");
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty & /*options*/ 2 && t_value !== (t_value = /*option*/ ctx[7] + "")) set_data(t, t_value);

			if (dirty & /*options*/ 2 && option_value_value !== (option_value_value = /*option*/ ctx[7])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

function create_fragment$Y(ctx) {
	let div1;
	let select;
	let if_block_anchor;
	let t;
	let div0;
	let mounted;
	let dispose;
	let if_block = /*placeholder*/ ctx[2] && create_if_block$B(ctx);
	let each_value = /*options*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
	}

	return {
		c() {
			div1 = element("div");
			select = element("select");
			if (if_block) if_block.c();
			if_block_anchor = empty();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			div0 = element("div");
			div0.innerHTML = `<svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"></path></svg>`;
			attr(select, "class", "svelte-g3sqa4");
			if (/*value*/ ctx[0] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[5].call(select));
			toggle_class(select, "small", /*size*/ ctx[3] === 'small');
			attr(div0, "class", "pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700");
			attr(div1, "class", "select-container svelte-g3sqa4");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, select);
			if (if_block) if_block.m(select, null);
			append(select, if_block_anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			select_option(select, /*value*/ ctx[0]);
			append(div1, t);
			append(div1, div0);

			if (!mounted) {
				dispose = [
					listen(select, "change", /*select_change_handler*/ ctx[5]),
					listen(select, "change", /*change_handler*/ ctx[6])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*placeholder*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$B(ctx);
					if_block.c();
					if_block.m(select, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*options*/ 2) {
				each_value = /*options*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$e(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$e(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*value, options*/ 3) {
				select_option(select, /*value*/ ctx[0]);
			}

			if (dirty & /*size*/ 8) {
				toggle_class(select, "small", /*size*/ ctx[3] === 'small');
			}
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) detach(div1);
			if (if_block) if_block.d();
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$X($$self, $$props, $$invalidate) {
	let { options } = $$props;
	let { value = '' } = $$props;
	let { placeholder = 'Select an Option' } = $$props;
	let { size = 'normal' } = $$props;
	const dispatch = createEventDispatcher();

	function select_change_handler() {
		value = select_value(this);
		$$invalidate(0, value);
		$$invalidate(1, options);
	}

	const change_handler = e => dispatch('change', e.currentTarget.value);

	$$self.$$set = $$props => {
		if ('options' in $$props) $$invalidate(1, options = $$props.options);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('placeholder' in $$props) $$invalidate(2, placeholder = $$props.placeholder);
		if ('size' in $$props) $$invalidate(3, size = $$props.size);
	};

	return [
		value,
		options,
		placeholder,
		size,
		dispatch,
		select_change_handler,
		change_handler
	];
}

class Select$2 extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$X, create_fragment$Y, safe_not_equal, {
			options: 1,
			value: 0,
			placeholder: 2,
			size: 3
		});
	}
}

/* ../design-system/dist/Spinner.svelte generated by Svelte v3.52.0 */

function create_fragment$X(ctx) {
	let span3;

	return {
		c() {
			span3 = element("span");
			span3.innerHTML = `<span class="spinner svelte-l56ytt"><span class="dot1 svelte-l56ytt"></span>  <span class="dot2 svelte-l56ytt"></span></span>`;
			attr(span3, "class", "spinner-container svelte-l56ytt");
		},
		m(target, anchor) {
			insert(target, span3, anchor);
		},
		p: noop$1,
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) detach(span3);
		}
	};
}

class Spinner extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment$X, safe_not_equal, {});
	}
}

/* ../design-system/dist/Switch.svelte generated by Svelte v3.52.0 */

function create_fragment$W(ctx) {
	let label;
	let input;
	let t0;
	let span2;
	let t2;
	let span3;
	let t3;
	let mounted;
	let dispose;

	return {
		c() {
			label = element("label");
			input = element("input");
			t0 = space();
			span2 = element("span");

			span2.innerHTML = `<span class="track svelte-16fu7e0"></span> 
    <span class="thumb svelte-16fu7e0"></span>`;

			t2 = space();
			span3 = element("span");
			t3 = text$1(/*text*/ ctx[1]);
			attr(input, "type", "checkbox");
			input.disabled = /*disabled*/ ctx[2];
			attr(input, "class", "svelte-16fu7e0");
			attr(span2, "class", "switch svelte-16fu7e0");
			attr(span3, "class", "ml-2 cursor-pointer");
			attr(label, "class", "marcelle");
		},
		m(target, anchor) {
			insert(target, label, anchor);
			append(label, input);
			input.checked = /*checked*/ ctx[0];
			append(label, t0);
			append(label, span2);
			append(label, t2);
			append(label, span3);
			append(span3, t3);

			if (!mounted) {
				dispose = listen(input, "change", /*input_change_handler*/ ctx[3]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*disabled*/ 4) {
				input.disabled = /*disabled*/ ctx[2];
			}

			if (dirty & /*checked*/ 1) {
				input.checked = /*checked*/ ctx[0];
			}

			if (dirty & /*text*/ 2) set_data(t3, /*text*/ ctx[1]);
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) detach(label);
			mounted = false;
			dispose();
		}
	};
}

function instance$W($$self, $$props, $$invalidate) {
	let { text = '' } = $$props;
	let { checked = false } = $$props;
	let { disabled = false } = $$props;

	function input_change_handler() {
		checked = this.checked;
		$$invalidate(0, checked);
	}

	$$self.$$set = $$props => {
		if ('text' in $$props) $$invalidate(1, text = $$props.text);
		if ('checked' in $$props) $$invalidate(0, checked = $$props.checked);
		if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
	};

	return [checked, text, disabled, input_change_handler];
}

class Switch extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$W, create_fragment$W, safe_not_equal, { text: 1, checked: 0, disabled: 2 });
	}
}

const subscriber_queue = [];
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */
function writable(value, start = noop$1) {
    let stop;
    const subscribers = new Set();
    function set(new_value) {
        if (safe_not_equal(value, new_value)) {
            value = new_value;
            if (stop) { // store is ready
                const run_queue = !subscriber_queue.length;
                for (const subscriber of subscribers) {
                    subscriber[1]();
                    subscriber_queue.push(subscriber, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = noop$1) {
        const subscriber = [run, invalidate];
        subscribers.add(subscriber);
        if (subscribers.size === 1) {
            stop = start(set) || noop$1;
        }
        run(value);
        return () => {
            subscribers.delete(subscriber);
            if (subscribers.size === 0) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}

/* ../design-system/dist/Tabs.svelte generated by Svelte v3.52.0 */

function create_fragment$V(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "tabs");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[0],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

const TABS = {};

function instance$V($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	const tabs = [];
	const panels = [];
	const selectedTab = writable(null);
	const selectedPanel = writable(null);

	setContext(TABS, {
		registerTab: tab => {
			tabs.push(tab);
			selectedTab.update(current => current || tab);

			onDestroy(() => {
				const i = tabs.indexOf(tab);
				tabs.splice(i, 1);

				selectedTab.update(current => current === tab
				? tabs[i] || tabs[tabs.length - 1]
				: current);
			});
		},
		registerPanel: panel => {
			panels.push(panel);
			selectedPanel.update(current => current || panel);

			onDestroy(() => {
				const i = panels.indexOf(panel);
				panels.splice(i, 1);

				selectedPanel.update(current => current === panel
				? panels[i] || panels[panels.length - 1]
				: current);
			});
		},
		selectTab: tab => {
			const i = tabs.indexOf(tab);
			selectedTab.set(tab);
			selectedPanel.set(panels[i]);
		},
		selectedTab,
		selectedPanel
	});

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	return [$$scope, slots];
}

class Tabs extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$V, create_fragment$V, safe_not_equal, {});
	}
}

/* ../design-system/dist/Tab.svelte generated by Svelte v3.52.0 */

function create_fragment$U(ctx) {
	let div;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "text-sm font-semibold text-gray-600 cursor-pointer mx-4 p-2 hover:text-gray-800 svelte-13dez5h");
			attr(div, "role", "tab");
			toggle_class(div, "selected", /*$selectedTab*/ ctx[0] === /*tab*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(div, "click", /*click_handler*/ ctx[6]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*$selectedTab, tab*/ 3) {
				toggle_class(div, "selected", /*$selectedTab*/ ctx[0] === /*tab*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$U($$self, $$props, $$invalidate) {
	let $selectedTab;
	let { $$slots: slots = {}, $$scope } = $$props;
	const tab = {};
	const { registerTab, selectTab, selectedTab } = getContext(TABS);
	component_subscribe($$self, selectedTab, value => $$invalidate(0, $selectedTab = value));
	registerTab(tab);
	const click_handler = () => selectTab(tab);

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	};

	return [$selectedTab, tab, selectTab, selectedTab, $$scope, slots, click_handler];
}

class Tab extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$U, create_fragment$U, safe_not_equal, {});
	}
}

/* ../design-system/dist/TabPanel.svelte generated by Svelte v3.52.0 */

function create_if_block$A(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$T(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*$selectedPanel*/ ctx[0] === /*panel*/ ctx[1] && create_if_block$A(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*$selectedPanel*/ ctx[0] === /*panel*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*$selectedPanel*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$A(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$T($$self, $$props, $$invalidate) {
	let $selectedPanel;
	let { $$slots: slots = {}, $$scope } = $$props;
	const panel = {};
	const { registerPanel, selectedPanel } = getContext(TABS);
	component_subscribe($$self, selectedPanel, value => $$invalidate(0, $selectedPanel = value));
	registerPanel(panel);

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	return [$selectedPanel, panel, selectedPanel, $$scope, slots];
}

class TabPanel extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$T, create_fragment$T, safe_not_equal, {});
	}
}

/* ../design-system/dist/TableContentCell.svelte generated by Svelte v3.52.0 */

function create_else_block$l(ctx) {
	let t;

	return {
		c() {
			t = text$1(/*value*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*value*/ 2) set_data(t, /*value*/ ctx[1]);
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (48:37) 
function create_if_block_6$1(ctx) {
	let t_value = /*value*/ ctx[1].toPrecision(2) + "";
	let t;

	return {
		c() {
			t = text$1(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*value*/ 2 && t_value !== (t_value = /*value*/ ctx[1].toPrecision(2) + "")) set_data(t, t_value);
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (46:28) 
function create_if_block_5$1(ctx) {
	let t0;
	let t1_value = getArrayShape(/*value*/ ctx[1]).join(', ') + "";
	let t1;
	let t2;

	return {
		c() {
			t0 = text$1("Array(");
			t1 = text$1(t1_value);
			t2 = text$1(")");
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, t2, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*value*/ 2 && t1_value !== (t1_value = getArrayShape(/*value*/ ctx[1]).join(', ') + "")) set_data(t1, t1_value);
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (detaching) detach(t2);
		}
	};
}

// (44:27) 
function create_if_block_4$2(ctx) {
	let t_value = /*formatDate*/ ctx[3](/*value*/ ctx[1]) + "";
	let t;

	return {
		c() {
			t = text$1(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*value*/ 2 && t_value !== (t_value = /*formatDate*/ ctx[3](/*value*/ ctx[1]) + "")) set_data(t, t_value);
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (42:27) 
function create_if_block_3$7(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[7],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (40:29) 
function create_if_block_2$a(ctx) {
	let button;
	let current;

	button = new Button$1({
			props: {
				size: "small",
				$$slots: { default: [create_default_slot$F] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*click_handler_1*/ ctx[6]);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope, value*/ 130) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (31:27) 
function create_if_block_1$h(ctx) {
	let sl_button;
	let t_value = /*value*/ ctx[1].text + "";
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			sl_button = element("sl-button");
			t = text$1(t_value);
			set_custom_element_data(sl_button, "type", "text");
			set_custom_element_data(sl_button, "size", "small");
		},
		m(target, anchor) {
			insert(target, sl_button, anchor);
			append(sl_button, t);

			if (!mounted) {
				dispose = listen(sl_button, "click", /*click_handler*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*value*/ 2 && t_value !== (t_value = /*value*/ ctx[1].text + "")) set_data(t, t_value);
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) detach(sl_button);
			mounted = false;
			dispose();
		}
	};
}

// (29:1) {#if type === 'image'}
function create_if_block$z(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "alt", "thumbnail");
			if (!src_url_equal(img.src, img_src_value = /*value*/ ctx[1])) attr(img, "src", img_src_value);
			attr(img, "width", "30");
			attr(img, "height", "30");
			attr(img, "class", "rounded-md");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*value*/ 2 && !src_url_equal(img.src, img_src_value = /*value*/ ctx[1])) {
				attr(img, "src", img_src_value);
			}
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (41:2) <Button size="small" on:click={() => dispatch('action', value)}>
function create_default_slot$F(ctx) {
	let t;

	return {
		c() {
			t = text$1(/*value*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*value*/ 2) set_data(t, /*value*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$S(ctx) {
	let td;
	let current_block_type_index;
	let if_block;
	let current;

	const if_block_creators = [
		create_if_block$z,
		create_if_block_1$h,
		create_if_block_2$a,
		create_if_block_3$7,
		create_if_block_4$2,
		create_if_block_5$1,
		create_if_block_6$1,
		create_else_block$l
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*type*/ ctx[0] === 'image') return 0;
		if (/*type*/ ctx[0] === 'link') return 1;
		if (/*type*/ ctx[0] === 'action') return 2;
		if (/*type*/ ctx[0] === 'slot') return 3;
		if (/*type*/ ctx[0] === 'date') return 4;
		if (/*type*/ ctx[0] === 'array') return 5;
		if (typeof /*value*/ ctx[1] === 'number') return 6;
		return 7;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			td = element("td");
			if_block.c();
			attr(td, "class", "svelte-1w1eb18");
		},
		m(target, anchor) {
			insert(target, td, anchor);
			if_blocks[current_block_type_index].m(td, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(td, null);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(td);
			if_blocks[current_block_type_index].d();
		}
	};
}

function getArrayShape(arr) {
	if (!Array.isArray(arr)) return [];

	if (arr.length > 0 && Array.isArray(arr[0])) {
		return [arr.length, ...getArrayShape(arr[0])];
	}

	return [arr.length];
}

function instance$S($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { type = 'generic' } = $$props;
	let { value = null } = $$props;
	const dispatch = createEventDispatcher();

	function formatDate(v) {
		try {
			return formatDistanceToNow(Date.parse(v), { includeSeconds: true, addSuffix: true });
		} catch(error) {
			// eslint-disable-next-line no-console
			console.log('Date Parsing Error', v, error);

			return v;
		}
	}

	const click_handler = () => {
		// eslint-disable-next-line no-console
		console.log('GOTO:', value.href);
	};

	const click_handler_1 = () => dispatch('action', value);

	$$self.$$set = $$props => {
		if ('type' in $$props) $$invalidate(0, type = $$props.type);
		if ('value' in $$props) $$invalidate(1, value = $$props.value);
		if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
	};

	return [
		type,
		value,
		dispatch,
		formatDate,
		slots,
		click_handler,
		click_handler_1,
		$$scope
	];
}

class TableContentCell extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$S, create_fragment$S, safe_not_equal, { type: 0, value: 1 });
	}
}

/* ../design-system/dist/TableHeaderCell.svelte generated by Svelte v3.52.0 */

function create_if_block$y(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1$g, create_else_block$k];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*sortAscending*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (40:3) {:else}
function create_else_block$k(ctx) {
	let button;
	let current;

	button = new Button$1({
			props: {
				round: true,
				size: "small",
				$$slots: { default: [create_default_slot_1$f] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*sort*/ ctx[3]);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 64) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (21:3) {#if sortAscending}
function create_if_block_1$g(ctx) {
	let button;
	let current;

	button = new Button$1({
			props: {
				round: true,
				size: "small",
				$$slots: { default: [create_default_slot$E] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*sort*/ ctx[3]);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 64) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (41:4) <Button round size="small" on:click={sort}>
function create_default_slot_1$f(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "stroke-linecap", "round");
			attr(path, "stroke-linejoin", "round");
			attr(path, "stroke-width", "2");
			attr(path, "d", "M16 17l-4 4m0 0l-4-4m4 4V3");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "h-6 w-6");
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (22:4) <Button round size="small" on:click={sort}>
function create_default_slot$E(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "stroke-linecap", "round");
			attr(path, "stroke-linejoin", "round");
			attr(path, "stroke-width", "2");
			attr(path, "d", "M8 7l4-4m0 0l4 4m-4-4v18");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "h-6 w-6");
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function create_fragment$R(ctx) {
	let th;
	let span1;
	let span0;
	let t0;
	let t1;
	let current;
	let if_block = /*sortable*/ ctx[1] && create_if_block$y(ctx);

	return {
		c() {
			th = element("th");
			span1 = element("span");
			span0 = element("span");
			t0 = text$1(/*name*/ ctx[0]);
			t1 = space();
			if (if_block) if_block.c();
			set_style(span0, "margin-top", "0.5rem");
			set_style(span0, "margin-bottom", "0.5rem");
			set_style(span1, "display", "flex");
			set_style(span1, "justify-content", "space-between");
			set_style(span1, "align-items", "center");
			attr(th, "class", "svelte-1310j1m");
		},
		m(target, anchor) {
			insert(target, th, anchor);
			append(th, span1);
			append(span1, span0);
			append(span0, t0);
			append(span1, t1);
			if (if_block) if_block.m(span1, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*name*/ 1) set_data(t0, /*name*/ ctx[0]);

			if (/*sortable*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*sortable*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$y(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(span1, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(th);
			if (if_block) if_block.d();
		}
	};
}

function instance$R($$self, $$props, $$invalidate) {
	let { name = 'name' } = $$props;
	let { sortable = false } = $$props;
	let { sorting = { col: '', ascending: true } } = $$props;
	const dispatch = createEventDispatcher();
	let sortAscending = true;

	function sort() {
		$$invalidate(2, sortAscending = !sortAscending);
		dispatch('sort', { col: name, ascending: sortAscending });
	}

	$$self.$$set = $$props => {
		if ('name' in $$props) $$invalidate(0, name = $$props.name);
		if ('sortable' in $$props) $$invalidate(1, sortable = $$props.sortable);
		if ('sorting' in $$props) $$invalidate(4, sorting = $$props.sorting);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*sorting, name*/ 17) {
			if (sorting.col === name) {
				$$invalidate(2, sortAscending = sorting.ascending);
			}
		}
	};

	return [name, sortable, sortAscending, sort, sorting];
}

class TableHeaderCell extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$R, create_fragment$R, safe_not_equal, { name: 0, sortable: 1, sorting: 4 });
	}
}

/* ../design-system/dist/TableActions.svelte generated by Svelte v3.52.0 */

function get_each_context$d(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i].name;
	child_ctx[11] = list[i].multiple;
	child_ctx[12] = list[i].confirm;
	return child_ctx;
}

// (39:4) <Button       size="small"       disabled={multiple === false && selected.length > 1}       type={name === 'delete' ? 'danger' : 'default'}       on:click={() => handleAction(name, confirm)}>
function create_default_slot_3$1(ctx) {
	let t_value = /*name*/ ctx[10] + "";
	let t;

	return {
		c() {
			t = text$1(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*actions*/ 2 && t_value !== (t_value = /*name*/ ctx[10] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (38:2) {#each actions as { name, multiple, confirm }}
function create_each_block$d(ctx) {
	let button;
	let current;

	function click_handler() {
		return /*click_handler*/ ctx[7](/*name*/ ctx[10], /*confirm*/ ctx[12]);
	}

	button = new Button$1({
			props: {
				size: "small",
				disabled: /*multiple*/ ctx[11] === false && /*selected*/ ctx[0].length > 1,
				type: /*name*/ ctx[10] === 'delete' ? 'danger' : 'default',
				$$slots: { default: [create_default_slot_3$1] },
				$$scope: { ctx }
			}
		});

	button.$on("click", click_handler);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const button_changes = {};
			if (dirty & /*actions, selected*/ 3) button_changes.disabled = /*multiple*/ ctx[11] === false && /*selected*/ ctx[0].length > 1;
			if (dirty & /*actions*/ 2) button_changes.type = /*name*/ ctx[10] === 'delete' ? 'danger' : 'default';

			if (dirty & /*$$scope, actions*/ 32770) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (49:0) {#if confirmActionPending}
function create_if_block$x(ctx) {
	let modal;
	let current;

	modal = new Modal({
			props: {
				$$slots: { default: [create_default_slot$D] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(modal.$$.fragment);
		},
		m(target, anchor) {
			mount_component(modal, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const modal_changes = {};

			if (dirty & /*$$scope, confirmActionPending, selectedAction*/ 32780) {
				modal_changes.$$scope = { dirty, ctx };
			}

			modal.$set(modal_changes);
		},
		i(local) {
			if (current) return;
			transition_in(modal.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(modal.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(modal, detaching);
		}
	};
}

// (54:8) <Button           type="danger"           on:click={() => {             confirmActionPending = false;           }}>
function create_default_slot_2$4(ctx) {
	let t;

	return {
		c() {
			t = text$1("Cancel");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (61:8) <Button variant="filled" on:click={confirmAction}>
function create_default_slot_1$e(ctx) {
	let t;

	return {
		c() {
			t = text$1("Confirm");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (50:2) <Modal>
function create_default_slot$D(ctx) {
	let div1;
	let p;
	let t0;
	let t1;
	let t2;
	let t3;
	let div0;
	let button0;
	let t4;
	let span;
	let t5;
	let button1;
	let current;

	button0 = new Button$1({
			props: {
				type: "danger",
				$$slots: { default: [create_default_slot_2$4] },
				$$scope: { ctx }
			}
		});

	button0.$on("click", /*click_handler_1*/ ctx[8]);

	button1 = new Button$1({
			props: {
				variant: "filled",
				$$slots: { default: [create_default_slot_1$e] },
				$$scope: { ctx }
			}
		});

	button1.$on("click", /*confirmAction*/ ctx[4]);

	return {
		c() {
			div1 = element("div");
			p = element("p");
			t0 = text$1("Do you want to ");
			t1 = text$1(/*selectedAction*/ ctx[2]);
			t2 = text$1(" the selected items?");
			t3 = space();
			div0 = element("div");
			create_component(button0.$$.fragment);
			t4 = space();
			span = element("span");
			t5 = space();
			create_component(button1.$$.fragment);
			attr(span, "class", "w-2");
			attr(div0, "class", "w-full flex justify-end");
			attr(div1, "class", "p-8");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, p);
			append(p, t0);
			append(p, t1);
			append(p, t2);
			append(div1, t3);
			append(div1, div0);
			mount_component(button0, div0, null);
			append(div0, t4);
			append(div0, span);
			append(div0, t5);
			mount_component(button1, div0, null);
			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty & /*selectedAction*/ 4) set_data(t1, /*selectedAction*/ ctx[2]);
			const button0_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(button0);
			destroy_component(button1);
		}
	};
}

function create_fragment$Q(ctx) {
	let div;
	let t;
	let if_block_anchor;
	let current;
	let each_value = /*actions*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	let if_block = /*confirmActionPending*/ ctx[3] && create_if_block$x(ctx);

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			attr(div, "class", "actions");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			insert(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*actions, selected, handleAction*/ 35) {
				each_value = /*actions*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$d(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$d(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (/*confirmActionPending*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*confirmActionPending*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$x(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(if_block);
			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$Q($$self, $$props, $$invalidate) {
	let { provider } = $$props;
	let { actions } = $$props;
	let { selected } = $$props;
	const dispatch = createEventDispatcher();
	let selectedAction = '';
	let confirmActionPending = false;

	async function confirmAction() {
		if (selectedAction === 'delete') {
			for (const i of selected) {
				await provider.delete(i);
			}
		} else {
			dispatch('action', [selectedAction, selected]);
		}

		$$invalidate(3, confirmActionPending = false);
		$$invalidate(0, selected = []);
		dispatch('selected', selected);
	}

	function handleAction(action, confirm) {
		$$invalidate(2, selectedAction = action);
		if (!selectedAction || selected.length === 0) return;

		if (confirm) {
			$$invalidate(3, confirmActionPending = true);
		} else {
			confirmAction();
		}
	}

	const click_handler = (name, confirm) => handleAction(name, confirm);

	const click_handler_1 = () => {
		$$invalidate(3, confirmActionPending = false);
	};

	$$self.$$set = $$props => {
		if ('provider' in $$props) $$invalidate(6, provider = $$props.provider);
		if ('actions' in $$props) $$invalidate(1, actions = $$props.actions);
		if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
	};

	return [
		selected,
		actions,
		selectedAction,
		confirmActionPending,
		confirmAction,
		handleAction,
		provider,
		click_handler,
		click_handler_1
	];
}

class TableActions extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, { provider: 6, actions: 1, selected: 0 });
	}
}

/* ../design-system/dist/TableFooter.svelte generated by Svelte v3.52.0 */

function create_if_block$w(ctx) {
	let tableactions;
	let updating_selected;
	let current;

	function tableactions_selected_binding(value) {
		/*tableactions_selected_binding*/ ctx[11](value);
	}

	let tableactions_props = {
		provider: /*provider*/ ctx[1],
		actions: /*actions*/ ctx[2]
	};

	if (/*selected*/ ctx[0] !== void 0) {
		tableactions_props.selected = /*selected*/ ctx[0];
	}

	tableactions = new TableActions({ props: tableactions_props });
	binding_callbacks.push(() => bind(tableactions, 'selected', tableactions_selected_binding));
	tableactions.$on("selected", /*selected_handler*/ ctx[12]);
	tableactions.$on("action", /*action_handler*/ ctx[13]);

	return {
		c() {
			create_component(tableactions.$$.fragment);
		},
		m(target, anchor) {
			mount_component(tableactions, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const tableactions_changes = {};
			if (dirty & /*provider*/ 2) tableactions_changes.provider = /*provider*/ ctx[1];
			if (dirty & /*actions*/ 4) tableactions_changes.actions = /*actions*/ ctx[2];

			if (!updating_selected && dirty & /*selected*/ 1) {
				updating_selected = true;
				tableactions_changes.selected = /*selected*/ ctx[0];
				add_flush_callback(() => updating_selected = false);
			}

			tableactions.$set(tableactions_changes);
		},
		i(local) {
			if (current) return;
			transition_in(tableactions.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tableactions.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(tableactions, detaching);
		}
	};
}

// (70:2) <Button    round    disabled={page === 1}    on:click={() => {     gotoPage(page - 1);    }}   >
function create_default_slot_1$d(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "stroke-linecap", "round");
			attr(path, "stroke-linejoin", "round");
			attr(path, "stroke-width", "2");
			attr(path, "d", "M15 19l-7-7 7-7");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "h-3 w-3");
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (97:2) <Button    round    disabled={page === numPages}    on:click={() => {     gotoPage(page + 1);    }}   >
function create_default_slot$C(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr(path, "stroke-linecap", "round");
			attr(path, "stroke-linejoin", "round");
			attr(path, "stroke-width", "2");
			attr(path, "d", "M9 5l7 7-7 7");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "h-3 w-3");
			attr(svg, "fill", "none");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "stroke", "currentColor");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function create_fragment$P(ctx) {
	let div5;
	let div0;
	let t0;
	let div4;
	let div2;
	let t1;
	let div1;
	let select;
	let t2;
	let div3;
	let t3;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let button0;
	let t9;
	let input;
	let input_value_value;
	let t10;
	let button1;
	let current;
	let mounted;
	let dispose;
	let if_block = /*actions*/ ctx[2].length > 0 && /*selected*/ ctx[0].length > 0 && create_if_block$w(ctx);

	select = new Select$2({
			props: {
				size: "small",
				options: ['10', '20', '50', 'all'],
				value: /*itemsPerPage*/ ctx[5].toString()
			}
		});

	select.$on("change", /*change_handler*/ ctx[14]);

	button0 = new Button$1({
			props: {
				round: true,
				disabled: /*page*/ ctx[3] === 1,
				$$slots: { default: [create_default_slot_1$d] },
				$$scope: { ctx }
			}
		});

	button0.$on("click", /*click_handler*/ ctx[15]);

	button1 = new Button$1({
			props: {
				round: true,
				disabled: /*page*/ ctx[3] === /*numPages*/ ctx[6],
				$$slots: { default: [create_default_slot$C] },
				$$scope: { ctx }
			}
		});

	button1.$on("click", /*click_handler_1*/ ctx[17]);

	return {
		c() {
			div5 = element("div");
			div0 = element("div");
			if (if_block) if_block.c();
			t0 = space();
			div4 = element("div");
			div2 = element("div");
			t1 = text$1("Items per page:\n\t\t\t");
			div1 = element("div");
			create_component(select.$$.fragment);
			t2 = space();
			div3 = element("div");
			t3 = text$1(/*start*/ ctx[7]);
			t4 = text$1("-");
			t5 = text$1(/*end*/ ctx[8]);
			t6 = text$1(" of ");
			t7 = text$1(/*total*/ ctx[4]);
			t8 = space();
			create_component(button0.$$.fragment);
			t9 = space();
			input = element("input");
			t10 = space();
			create_component(button1.$$.fragment);
			attr(div0, "class", "actions");
			attr(div1, "class", "w-12 ml-2");
			attr(div2, "class", "flex items-center mx-4");
			attr(div3, "class", "mx-3");
			attr(input, "class", "marcelle w-8 rounded mr-1 mb-1 bg-white text-gray-600 border border-solid border-gray-300 text-center focus:outline-none focus:ring-blue-400 focus:ring-2 focus:ring-opacity-50 active:ring-blue-400 active:ring-4 active:ring-opacity-50");
			input.value = input_value_value = /*page*/ ctx[3].toString();
			attr(div4, "class", "flex items-center");
			attr(div5, "class", "table-footer svelte-13k2ee6");
		},
		m(target, anchor) {
			insert(target, div5, anchor);
			append(div5, div0);
			if (if_block) if_block.m(div0, null);
			append(div5, t0);
			append(div5, div4);
			append(div4, div2);
			append(div2, t1);
			append(div2, div1);
			mount_component(select, div1, null);
			append(div4, t2);
			append(div4, div3);
			append(div3, t3);
			append(div3, t4);
			append(div3, t5);
			append(div3, t6);
			append(div3, t7);
			append(div4, t8);
			mount_component(button0, div4, null);
			append(div4, t9);
			append(div4, input);
			append(div4, t10);
			mount_component(button1, div4, null);
			current = true;

			if (!mounted) {
				dispose = listen(input, "blur", /*blur_handler*/ ctx[16]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*actions*/ ctx[2].length > 0 && /*selected*/ ctx[0].length > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*actions, selected*/ 5) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$w(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div0, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const select_changes = {};
			if (dirty & /*itemsPerPage*/ 32) select_changes.value = /*itemsPerPage*/ ctx[5].toString();
			select.$set(select_changes);
			if (!current || dirty & /*start*/ 128) set_data(t3, /*start*/ ctx[7]);
			if (!current || dirty & /*end*/ 256) set_data(t5, /*end*/ ctx[8]);
			if (!current || dirty & /*total*/ 16) set_data(t7, /*total*/ ctx[4]);
			const button0_changes = {};
			if (dirty & /*page*/ 8) button0_changes.disabled = /*page*/ ctx[3] === 1;

			if (dirty & /*$$scope*/ 262144) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);

			if (!current || dirty & /*page*/ 8 && input_value_value !== (input_value_value = /*page*/ ctx[3].toString()) && input.value !== input_value_value) {
				input.value = input_value_value;
			}

			const button1_changes = {};
			if (dirty & /*page, numPages*/ 72) button1_changes.disabled = /*page*/ ctx[3] === /*numPages*/ ctx[6];

			if (dirty & /*$$scope*/ 262144) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(select.$$.fragment, local);
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(select.$$.fragment, local);
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div5);
			if (if_block) if_block.d();
			destroy_component(select);
			destroy_component(button0);
			destroy_component(button1);
			mounted = false;
			dispose();
		}
	};
}

function instance$P($$self, $$props, $$invalidate) {
	let itemsPerPage;
	let { provider } = $$props;
	let { actions } = $$props;
	let { selected } = $$props;
	let page = 1;
	let numPages = 1;
	let start = 0;
	let end = 0;
	let total = 0;

	let unsub = () => {
		
	};

	// $: console.log('provider', provider);
	// $: console.log('total', total);
	// $: console.log('$total', $total);
	// $: numPages = $total ? Math.ceil($total / itemsPerPage) : 1;
	// $: start = $total ? (page - 1) * itemsPerPage + 1 : 0;
	// $: end = Math.min($total || 0, page * itemsPerPage);
	function gotoPage(i) {
		$$invalidate(3, page = i);
		provider.page(i);
	}

	function tableactions_selected_binding(value) {
		selected = value;
		$$invalidate(0, selected);
	}

	function selected_handler(event) {
		bubble.call(this, $$self, event);
	}

	function action_handler(event) {
		bubble.call(this, $$self, event);
	}

	const change_handler = ({ detail }) => {
		const n = detail === 'all' ? total : parseInt(detail);
		provider.paginate(n);
		$$invalidate(5, itemsPerPage = n);
	};

	const click_handler = () => {
		gotoPage(page - 1);
	};

	const blur_handler = e => {
		let i = parseInt(e.currentTarget.value);
		if (isNaN(i)) return;
		gotoPage(Math.max(1, Math.min(numPages, i)));
	};

	const click_handler_1 = () => {
		gotoPage(page + 1);
	};

	$$self.$$set = $$props => {
		if ('provider' in $$props) $$invalidate(1, provider = $$props.provider);
		if ('actions' in $$props) $$invalidate(2, actions = $$props.actions);
		if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*provider*/ 2) {
			// $: total = provider.total;
			$$invalidate(5, itemsPerPage = provider.options.itemsPerPage);
		}

		if ($$self.$$.dirty & /*unsub, provider, total, itemsPerPage, page*/ 1082) {
			{
				unsub();

				$$invalidate(10, unsub = provider.total.subscribe(t => {
					if (t === undefined || t === 0) {
						$$invalidate(6, numPages = 1);
						$$invalidate(7, start = 0);
						$$invalidate(8, end = 0);
						$$invalidate(4, total = 0);
					} else {
						$$invalidate(6, numPages = Math.ceil(total / itemsPerPage));
						$$invalidate(7, start = (page - 1) * itemsPerPage + 1);
						$$invalidate(8, end = Math.min(total || 0, page * itemsPerPage));
						$$invalidate(4, total = t);
					}
				}));
			}
		}
	};

	return [
		selected,
		provider,
		actions,
		page,
		total,
		itemsPerPage,
		numPages,
		start,
		end,
		gotoPage,
		unsub,
		tableactions_selected_binding,
		selected_handler,
		action_handler,
		change_handler,
		click_handler,
		blur_handler,
		click_handler_1
	];
}

class TableFooter extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$P, create_fragment$P, safe_not_equal, { provider: 1, actions: 2, selected: 0 });
	}
}

/* ../design-system/dist/Table.svelte generated by Svelte v3.52.0 */

function get_each_context$c(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[22] = list[i];
	child_ctx[24] = i;
	return child_ctx;
}

function get_each_context_1$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[25] = list[i].type;
	child_ctx[26] = list[i].name;
	return child_ctx;
}

function get_each_context_2$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[26] = list[i].name;
	child_ctx[29] = list[i].sortable;
	return child_ctx;
}

// (61:0) {#if $error}
function create_if_block_3$6(ctx) {
	let div;
	let sl_alert;
	let sl_icon;
	let t0;
	let strong;
	let br;
	let t2;
	let t3;

	return {
		c() {
			div = element("div");
			sl_alert = element("sl-alert");
			sl_icon = element("sl-icon");
			t0 = space();
			strong = element("strong");
			strong.textContent = "Table Data Error";
			br = element("br");
			t2 = space();
			t3 = text$1(/*$error*/ ctx[9]);
			set_custom_element_data(sl_icon, "slot", "icon");
			set_custom_element_data(sl_icon, "name", "check2-circle");
			set_custom_element_data(sl_alert, "type", "danger");
			set_custom_element_data(sl_alert, "open", "");
			attr(div, "class", "service-error");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, sl_alert);
			append(sl_alert, sl_icon);
			append(sl_alert, t0);
			append(sl_alert, strong);
			append(sl_alert, br);
			append(sl_alert, t2);
			append(sl_alert, t3);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$error*/ 512) set_data(t3, /*$error*/ ctx[9]);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (74:4) {#if selectable}
function create_if_block_1$f(ctx) {
	let th;
	let if_block = !/*singleSelection*/ ctx[4] && create_if_block_2$9(ctx);

	return {
		c() {
			th = element("th");
			if (if_block) if_block.c();
			attr(th, "class", "svelte-12gp9na");
		},
		m(target, anchor) {
			insert(target, th, anchor);
			if (if_block) if_block.m(th, null);
		},
		p(ctx, dirty) {
			if (!/*singleSelection*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_2$9(ctx);
					if_block.c();
					if_block.m(th, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) detach(th);
			if (if_block) if_block.d();
		}
	};
}

// (76:6) {#if !singleSelection}
function create_if_block_2$9(ctx) {
	let input;
	let input_checked_value;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "type", "checkbox");
			input.checked = input_checked_value = /*selected*/ ctx[6].length > 0 && /*selected*/ ctx[6].length === /*$data*/ ctx[10].length;
		},
		m(target, anchor) {
			insert(target, input, anchor);

			if (!mounted) {
				dispose = listen(input, "click", /*selectAll*/ ctx[12]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*selected, $data*/ 1088 && input_checked_value !== (input_checked_value = /*selected*/ ctx[6].length > 0 && /*selected*/ ctx[6].length === /*$data*/ ctx[10].length)) {
				input.checked = input_checked_value;
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			dispose();
		}
	};
}

// (85:4) {#each columns as { name, sortable }}
function create_each_block_2$2(ctx) {
	let tableheadercell;
	let current;

	tableheadercell = new TableHeaderCell({
			props: {
				name: /*name*/ ctx[26],
				sortable: /*sortable*/ ctx[29],
				sorting: /*sorting*/ ctx[7]
			}
		});

	tableheadercell.$on("sort", /*sort*/ ctx[11]);

	return {
		c() {
			create_component(tableheadercell.$$.fragment);
		},
		m(target, anchor) {
			mount_component(tableheadercell, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const tableheadercell_changes = {};
			if (dirty[0] & /*columns*/ 1) tableheadercell_changes.name = /*name*/ ctx[26];
			if (dirty[0] & /*columns*/ 1) tableheadercell_changes.sortable = /*sortable*/ ctx[29];
			if (dirty[0] & /*sorting*/ 128) tableheadercell_changes.sorting = /*sorting*/ ctx[7];
			tableheadercell.$set(tableheadercell_changes);
		},
		i(local) {
			if (current) return;
			transition_in(tableheadercell.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tableheadercell.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(tableheadercell, detaching);
		}
	};
}

// (93:5) {#if selectable}
function create_if_block$v(ctx) {
	let tablecontentcell;
	let current;

	tablecontentcell = new TableContentCell({
			props: {
				type: "slot",
				$$slots: { default: [create_default_slot$B] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(tablecontentcell.$$.fragment);
		},
		m(target, anchor) {
			mount_component(tablecontentcell, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const tablecontentcell_changes = {};

			if (dirty[0] & /*selected*/ 64 | dirty[1] & /*$$scope*/ 2) {
				tablecontentcell_changes.$$scope = { dirty, ctx };
			}

			tablecontentcell.$set(tablecontentcell_changes);
		},
		i(local) {
			if (current) return;
			transition_in(tablecontentcell.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tablecontentcell.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(tablecontentcell, detaching);
		}
	};
}

// (94:6) <TableContentCell type="slot">
function create_default_slot$B(ctx) {
	let input;
	let input_checked_value;
	let mounted;
	let dispose;

	function click_handler(...args) {
		return /*click_handler*/ ctx[16](/*i*/ ctx[24], ...args);
	}

	return {
		c() {
			input = element("input");
			attr(input, "type", "checkbox");
			input.checked = input_checked_value = /*selected*/ ctx[6].includes(/*i*/ ctx[24]);
		},
		m(target, anchor) {
			insert(target, input, anchor);

			if (!mounted) {
				dispose = listen(input, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*selected*/ 64 && input_checked_value !== (input_checked_value = /*selected*/ ctx[6].includes(/*i*/ ctx[24]))) {
				input.checked = input_checked_value;
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			dispose();
		}
	};
}

// (102:5) {#each columns as { type, name }}
function create_each_block_1$4(ctx) {
	let tablecontentcell;
	let current;

	function action_handler(...args) {
		return /*action_handler*/ ctx[17](/*i*/ ctx[24], ...args);
	}

	tablecontentcell = new TableContentCell({
			props: {
				type: /*type*/ ctx[25],
				value: /*item*/ ctx[22][/*name*/ ctx[26]]
			}
		});

	tablecontentcell.$on("action", action_handler);

	return {
		c() {
			create_component(tablecontentcell.$$.fragment);
		},
		m(target, anchor) {
			mount_component(tablecontentcell, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const tablecontentcell_changes = {};
			if (dirty[0] & /*columns*/ 1) tablecontentcell_changes.type = /*type*/ ctx[25];
			if (dirty[0] & /*$data, columns*/ 1025) tablecontentcell_changes.value = /*item*/ ctx[22][/*name*/ ctx[26]];
			tablecontentcell.$set(tablecontentcell_changes);
		},
		i(local) {
			if (current) return;
			transition_in(tablecontentcell.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tablecontentcell.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(tablecontentcell, detaching);
		}
	};
}

// (91:3) {#each $data as item, i}
function create_each_block$c(ctx) {
	let tr;
	let t0;
	let t1;
	let current;
	let if_block = /*selectable*/ ctx[3] && create_if_block$v(ctx);
	let each_value_1 = /*columns*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			tr = element("tr");
			if (if_block) if_block.c();
			t0 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			attr(tr, "class", "svelte-12gp9na");
		},
		m(target, anchor) {
			insert(target, tr, anchor);
			if (if_block) if_block.m(tr, null);
			append(tr, t0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}

			append(tr, t1);
			current = true;
		},
		p(ctx, dirty) {
			if (/*selectable*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*selectable*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$v(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(tr, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (dirty[0] & /*columns, $data, propagateAction*/ 17409) {
				each_value_1 = /*columns*/ ctx[0];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1$4(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(tr, t1);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			transition_out(if_block);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(tr);
			if (if_block) if_block.d();
			destroy_each(each_blocks, detaching);
		}
	};
}

function create_fragment$O(ctx) {
	let t0;
	let div;
	let table;
	let thead;
	let tr;
	let t1;
	let t2;
	let tbody;
	let t3;
	let tablefooter;
	let updating_selected;
	let current;
	let if_block0 = /*$error*/ ctx[9] && create_if_block_3$6(ctx);
	let if_block1 = /*selectable*/ ctx[3] && create_if_block_1$f(ctx);
	let each_value_2 = /*columns*/ ctx[0];
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks_1[i] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i));
	}

	const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
		each_blocks_1[i] = null;
	});

	let each_value = /*$data*/ ctx[10];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
	}

	const out_1 = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	function tablefooter_selected_binding(value) {
		/*tablefooter_selected_binding*/ ctx[18](value);
	}

	let tablefooter_props = {
		provider: /*provider*/ ctx[1],
		actions: /*actions*/ ctx[2]
	};

	if (/*selected*/ ctx[6] !== void 0) {
		tablefooter_props.selected = /*selected*/ ctx[6];
	}

	tablefooter = new TableFooter({ props: tablefooter_props });
	binding_callbacks.push(() => bind(tablefooter, 'selected', tablefooter_selected_binding));
	tablefooter.$on("action", /*action_handler_1*/ ctx[19]);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			table = element("table");
			thead = element("thead");
			tr = element("tr");
			if (if_block1) if_block1.c();
			t1 = space();

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t2 = space();
			tbody = element("tbody");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t3 = space();
			create_component(tablefooter.$$.fragment);
			attr(tr, "class", "svelte-12gp9na");
			attr(thead, "class", "svelte-12gp9na");
			attr(tbody, "class", "svelte-12gp9na");
			attr(table, "class", "svelte-12gp9na");
			attr(div, "class", "marcelle table-container svelte-12gp9na");
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, div, anchor);
			append(div, table);
			append(table, thead);
			append(thead, tr);
			if (if_block1) if_block1.m(tr, null);
			append(tr, t1);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(tr, null);
			}

			append(table, t2);
			append(table, tbody);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tbody, null);
			}

			append(div, t3);
			mount_component(tablefooter, div, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*$error*/ ctx[9]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3$6(ctx);
					if_block0.c();
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*selectable*/ ctx[3]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_1$f(ctx);
					if_block1.c();
					if_block1.m(tr, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*columns, sorting, sort*/ 2177) {
				each_value_2 = /*columns*/ ctx[0];
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2$2(ctx, each_value_2, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
						transition_in(each_blocks_1[i], 1);
					} else {
						each_blocks_1[i] = create_each_block_2$2(child_ctx);
						each_blocks_1[i].c();
						transition_in(each_blocks_1[i], 1);
						each_blocks_1[i].m(tr, null);
					}
				}

				group_outros();

				for (i = each_value_2.length; i < each_blocks_1.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (dirty[0] & /*columns, $data, propagateAction, selected, selectOne, selectable*/ 25673) {
				each_value = /*$data*/ ctx[10];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$c(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$c(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(tbody, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out_1(i);
				}

				check_outros();
			}

			const tablefooter_changes = {};
			if (dirty[0] & /*provider*/ 2) tablefooter_changes.provider = /*provider*/ ctx[1];
			if (dirty[0] & /*actions*/ 4) tablefooter_changes.actions = /*actions*/ ctx[2];

			if (!updating_selected && dirty[0] & /*selected*/ 64) {
				updating_selected = true;
				tablefooter_changes.selected = /*selected*/ ctx[6];
				add_flush_callback(() => updating_selected = false);
			}

			tablefooter.$set(tablefooter_changes);
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_2.length; i += 1) {
				transition_in(each_blocks_1[i]);
			}

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(tablefooter.$$.fragment, local);
			current = true;
		},
		o(local) {
			each_blocks_1 = each_blocks_1.filter(Boolean);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				transition_out(each_blocks_1[i]);
			}

			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(tablefooter.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(div);
			if (if_block1) if_block1.d();
			destroy_each(each_blocks_1, detaching);
			destroy_each(each_blocks, detaching);
			destroy_component(tablefooter);
		}
	};
}

function instance$O($$self, $$props, $$invalidate) {
	let data;
	let error;

	let $error,
		$$unsubscribe_error = noop$1,
		$$subscribe_error = () => ($$unsubscribe_error(), $$unsubscribe_error = subscribe(error, $$value => $$invalidate(9, $error = $$value)), error);

	let $data,
		$$unsubscribe_data = noop$1,
		$$subscribe_data = () => ($$unsubscribe_data(), $$unsubscribe_data = subscribe(data, $$value => $$invalidate(10, $data = $$value)), data);

	$$self.$$.on_destroy.push(() => $$unsubscribe_error());
	$$self.$$.on_destroy.push(() => $$unsubscribe_data());
	let { columns } = $$props;
	let { provider } = $$props;
	let { actions = [] } = $$props;
	let { selectable = true } = $$props;
	let { singleSelection = false } = $$props;
	let { selection = [] } = $$props;
	let selected = [];
	const dispatch = createEventDispatcher();
	let sorting = { col: '', ascending: true };

	function sort({ detail }) {
		$$invalidate(7, sorting = detail);
		provider.sort(detail);
	}

	async function dispatchSelection() {
		$$invalidate(15, selection = await Promise.all(selected.map(provider.get.bind(provider))));
		dispatch('selection', selection);
	}

	function selectAll() {
		if (selected.length === get_store_value(data).length) {
			$$invalidate(6, selected = []);
		} else {
			$$invalidate(6, selected = get_store_value(data).map((x, i) => i));
		}

		dispatchSelection();
	}

	function selectOne(index, e) {
		if (singleSelection) {
			$$invalidate(6, selected = e.currentTarget.checked ? [index] : []);
			dispatchSelection();
		} else {
			if (e.currentTarget.checked) {
				if (!selected.includes(index)) {
					$$invalidate(6, selected = selected.concat([index]));
					dispatchSelection();
				}
			} else {
				$$invalidate(6, selected = selected.filter(x => x !== index));
				dispatchSelection();
			}
		}
	}

	async function propagateAction([actionName, sel]) {
		const s = Array.isArray(sel)
		? await Promise.all(sel.map(provider.get.bind(provider)))
		: await provider.get(sel);

		dispatch(actionName, s);
	}

	const click_handler = (i, e) => selectOne(i, e);

	const action_handler = (i, { detail }) => {
		propagateAction([detail, i]);
	};

	function tablefooter_selected_binding(value) {
		selected = value;
		((($$invalidate(6, selected), $$invalidate(15, selection)), $$invalidate(5, data)), $$invalidate(1, provider));
	}

	const action_handler_1 = ({ detail }) => propagateAction(detail);

	$$self.$$set = $$props => {
		if ('columns' in $$props) $$invalidate(0, columns = $$props.columns);
		if ('provider' in $$props) $$invalidate(1, provider = $$props.provider);
		if ('actions' in $$props) $$invalidate(2, actions = $$props.actions);
		if ('selectable' in $$props) $$invalidate(3, selectable = $$props.selectable);
		if ('singleSelection' in $$props) $$invalidate(4, singleSelection = $$props.singleSelection);
		if ('selection' in $$props) $$invalidate(15, selection = $$props.selection);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*provider*/ 2) {
			$$subscribe_data($$invalidate(5, data = provider.data));
		}

		if ($$self.$$.dirty[0] & /*provider*/ 2) {
			$$subscribe_error($$invalidate(8, error = provider.error));
		}

		if ($$self.$$.dirty[0] & /*selection, data*/ 32800) {
			$$invalidate(6, selected = selection.map(x => get_store_value(data).indexOf(x)));
		}
	};

	return [
		columns,
		provider,
		actions,
		selectable,
		singleSelection,
		data,
		selected,
		sorting,
		error,
		$error,
		$data,
		sort,
		selectAll,
		selectOne,
		propagateAction,
		selection,
		click_handler,
		action_handler,
		tablefooter_selected_binding,
		action_handler_1
	];
}

class Table extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$O,
			create_fragment$O,
			safe_not_equal,
			{
				columns: 0,
				provider: 1,
				actions: 2,
				selectable: 3,
				singleSelection: 4,
				selection: 15
			},
			null,
			[-1, -1]
		);
	}
}

/* ../design-system/dist/TabList.svelte generated by Svelte v3.52.0 */

function create_fragment$N(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "flex border-solid border-0 border-b border-gray-200 mb-2");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[0],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$N($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	return [$$scope, slots];
}

class TabList extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$N, create_fragment$N, safe_not_equal, {});
	}
}

const defaultOptions$1 = { itemsPerPage: 10 };
class TableDataProvider {
    options;
    data = writable([]);
    total = writable(0);
    error = writable(null);
    constructor(options = defaultOptions$1) {
        this.options = { ...defaultOptions$1, ...options };
    }
    paginate(n) {
        this.options.itemsPerPage = n;
        this.update();
    }
    async get(i) {
        const data = get_store_value(this.data);
        if (i >= 0 && i < data.length) {
            return data[i];
        }
        return null;
    }
}

class TableArrayProvider extends TableDataProvider {
    rawData;
    currentPage = 1;
    constructor({ data, ...options }) {
        super(options);
        this.rawData = data;
        this.total.set(data.length);
        this.data.set(this.rawData.slice(0, this.options.itemsPerPage));
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    async update() {
        this.page(this.currentPage);
    }
    async page(i) {
        this.data.set(this.rawData.slice((i - 1) * this.options.itemsPerPage, Math.min(i * this.options.itemsPerPage, this.rawData.length)));
        this.currentPage = i;
    }
    async sort(sorting) {
        this.rawData.sort((x, y) => {
            if (x[sorting.col] > y[sorting.col])
                return sorting.ascending ? 1 : -1;
            if (x[sorting.col] < y[sorting.col])
                return sorting.ascending ? -1 : 1;
            return 0;
        });
        this.page(this.currentPage);
    }
    async delete(i) {
        this.rawData.splice(i, 1);
        this.page(this.currentPage);
        return null;
    }
}

class TableServiceProvider extends TableDataProvider {
    service;
    query;
    transform;
    constructor({ service, columns, transform, ...options }) {
        super(options);
        this.service = service;
        this.transform = transform || {};
        this.query = {
            $sort: {
                updatedAt: -1,
            },
            $limit: this.options.itemsPerPage,
        };
        if (columns) {
            this.query.$select = columns.map((x) => x.name).concat(['id']);
        }
        this.update();
        this.service.on('created', this.update.bind(this));
        this.service.on('patched', this.update.bind(this));
        this.service.on('updated', this.update.bind(this));
        this.service.on('removed', this.update.bind(this));
    }
    paginate(n) {
        super.paginate(n);
        this.query.$limit = this.options.itemsPerPage;
        this.update();
    }
    async update() {
        try {
            const res = (await this.service.find({ query: this.query }));
            const data = res.data.map((x, i) => {
                const z = Object.entries(this.transform)
                    .map(([target, f]) => {
                    try {
                        return { [target]: f(x, i) };
                    }
                    catch (error) {
                        return { [target]: 'transform error' };
                    }
                })
                    .reduce((o, y) => ({ ...o, ...y }), {});
                return { ...x, ...z };
            });
            this.data.set(data);
            this.total.set(res.total);
            this.error.set(null);
        }
        catch (error) {
            this.data.set([]);
            this.total.set(0);
            this.error.set(error);
        }
    }
    async page(i) {
        this.query.$skip = (i - 1) * this.query.$limit;
        this.update();
    }
    async sort(sorting) {
        const { col, ascending } = sorting;
        if (col) {
            this.query.$sort = {
                [col]: ascending ? 1 : -1,
            };
        }
        else {
            delete this.query.$sort;
        }
        this.update();
    }
    async delete(i) {
        const removed = get_store_value(this.data)[i];
        await this.service.remove(removed.id);
        this.update();
        return removed;
    }
}

/* ../design-system/dist/ViewContainer.svelte generated by Svelte v3.52.0 */

function create_if_block_1$e(ctx) {
	let div;
	let progress_1;
	let current;

	progress_1 = new Progress({
			props: {
				progress: /*progress*/ ctx[2],
				thin: true
			}
		});

	return {
		c() {
			div = element("div");
			create_component(progress_1.$$.fragment);
			attr(div, "class", "absolute top-0 left-0 right-0");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(progress_1, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const progress_1_changes = {};
			if (dirty & /*progress*/ 4) progress_1_changes.progress = /*progress*/ ctx[2];
			progress_1.$set(progress_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(progress_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(progress_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(progress_1);
		}
	};
}

// (15:2) {#if loading}
function create_if_block$u(ctx) {
	let spinner;
	let current;
	spinner = new Spinner({});

	return {
		c() {
			create_component(spinner.$$.fragment);
		},
		m(target, anchor) {
			mount_component(spinner, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(spinner.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(spinner.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(spinner, detaching);
		}
	};
}

function create_fragment$M(ctx) {
	let div;
	let t0;
	let span;
	let t1;
	let t2;
	let t3;
	let current;
	let if_block0 = /*progress*/ ctx[2] !== false && create_if_block_1$e(ctx);
	let if_block1 = /*loading*/ ctx[1] && create_if_block$u();
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			span = element("span");
			t1 = text$1(/*title*/ ctx[0]);
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (default_slot) default_slot.c();
			attr(span, "class", "card-title");
			attr(div, "class", "card-container svelte-xnhseh");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append(div, t0);
			append(div, span);
			append(span, t1);
			append(div, t2);
			if (if_block1) if_block1.m(div, null);
			append(div, t3);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (/*progress*/ ctx[2] !== false) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*progress*/ 4) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$e(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*title*/ 1) set_data(t1, /*title*/ ctx[0]);

			if (/*loading*/ ctx[1]) {
				if (if_block1) {
					if (dirty & /*loading*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$u();
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$M($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { title } = $$props;
	let { loading = false } = $$props;
	let { progress = false } = $$props;

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('loading' in $$props) $$invalidate(1, loading = $$props.loading);
		if ('progress' in $$props) $$invalidate(2, progress = $$props.progress);
		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	return [title, loading, progress, $$scope, slots];
}

class ViewContainer extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$M, create_fragment$M, safe_not_equal, { title: 0, loading: 1, progress: 2 });
	}
}

let notificationContainer;
let app;
function notification({ title, message, duration = 3000, type = 'default', }) {
    if (!notificationContainer) {
        notificationContainer = document.createElement('div');
        notificationContainer.id = 'notification-container';
        document.body.appendChild(notificationContainer);
        app = new Notification({
            target: notificationContainer,
        });
    }
    app === null || app === void 0 ? void 0 : app.add({ title, message, duration, type });
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function noop() {
    // Nothing here
}

var _Stream_hold, _Stream_running, _Stream_startPromise;
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function dummySubscriber(value) {
    // Do nothing
}
const scheduler = newDefaultScheduler();
function isMostStream(s) {
    return s && typeof s === 'object' && s.run !== undefined;
}
function isStream(s) {
    return (s &&
        typeof s === 'object' &&
        s.run !== undefined &&
        s.id !== undefined);
}
class Stream {
    constructor(s, hold = undefined) {
        this.id = Stream.nextId++;
        this.subscribers = [];
        this.value = undefined;
        this.ready = false;
        _Stream_hold.set(this, void 0);
        _Stream_running.set(this, false);
        _Stream_startPromise.set(this, void 0);
        __classPrivateFieldSet(this, _Stream_hold, !!hold, "f");
        const [stopStream, stopEvents] = createAdapter();
        const [induce, events] = createAdapter();
        this.stopStream = stopStream;
        this.set = (v) => {
            this.value = v;
            // Following line is not working for derived streams...
            // if (!hold || this.ready) induce(v);
            induce(v);
        };
        let stream;
        if (isStream(s)) {
            stream = s;
            if (hold === undefined) {
                __classPrivateFieldSet(this, _Stream_hold, s.holding, "f");
            }
            if (s.holding) {
                this.value = s.value;
            }
        }
        else if (isMostStream(s)) {
            stream = s;
        }
        else {
            stream = most.map(() => this.value, most.now(s));
            this.value = s;
        }
        this.stream = most.multicast(most.tap(this.runListeners.bind(this), most.until(stopEvents, most.merge(stream, events))));
    }
    get() {
        // if (!this.#hold) {
        //   throw new Error('Cannot get value of a Stream if it was not instantiated with hold=true');
        // }
        return this.value;
    }
    get holding() {
        return __classPrivateFieldGet(this, _Stream_hold, "f");
    }
    run(sink, s) {
        return this.stream.run(sink, s);
    }
    runListeners(value) {
        this.value = value;
        for (const listener of this.subscribers) {
            listener(value);
        }
    }
    subscribe(run = dummySubscriber, invalidate = noop) {
        if (__classPrivateFieldGet(this, _Stream_hold, "f") && __classPrivateFieldGet(this, _Stream_running, "f")) {
            run(this.value);
        }
        const subscriber = (x) => {
            invalidate();
            run(x);
        };
        this.subscribers.push(subscriber);
        if (!__classPrivateFieldGet(this, _Stream_running, "f")) {
            this.start();
        }
        return () => {
            const index = this.subscribers.indexOf(subscriber);
            if (index !== -1)
                this.subscribers.splice(index, 1);
        };
    }
    async start() {
        if (!__classPrivateFieldGet(this, _Stream_running, "f")) {
            Stream.numActive++;
            // console.log('active streams: ', Stream.numActive);
            most.runEffects(this.stream, scheduler).then(() => {
                Stream.numActive--;
                // console.log('active streams: ', Stream.numActive);
            });
            __classPrivateFieldSet(this, _Stream_running, true, "f");
            __classPrivateFieldSet(this, _Stream_startPromise, new Promise((resolve, reject) => {
                asap({
                    run: () => {
                        this.ready = true;
                        resolve();
                    },
                    error(e) {
                        reject(e);
                    },
                    dispose() {
                        // nothing here.
                    },
                }, scheduler);
            }), "f");
        }
        return __classPrivateFieldGet(this, _Stream_startPromise, "f");
    }
    stop() {
        this.stopStream(undefined);
        __classPrivateFieldSet(this, _Stream_running, false, "f");
    }
    hold(h = true) {
        __classPrivateFieldSet(this, _Stream_hold, h, "f");
        return this;
    }
    thru(f) {
        return new Stream(f(this));
    }
    // ------------------------------------
    // Wrap most operators
    // ------------------------------------
    startWith(x) {
        const s = new Stream(most.startWith(x, this));
        if (this.holding) {
            s.value = x;
        }
        return s;
    }
    continueWith(f) {
        const s = new Stream(most.continueWith(f, this));
        if (this.holding) {
            s.value = this.value;
        }
        return s;
    }
    map(f) {
        const s = new Stream(most.map(f, this));
        if (this.holding) {
            s.value = f(this.value);
        }
        return s;
    }
    constant(x) {
        const s = new Stream(most.constant(x, this));
        if (this.holding) {
            s.value = x;
        }
        return s;
    }
    tap(f) {
        const s = new Stream(most.tap(f, this));
        if (this.holding) {
            s.value = this.value;
        }
        return s;
    }
    ap(fs) {
        const s = new Stream(most.ap(fs, this));
        if (this.holding && fs.holding) {
            s.value = fs.get()(this.value);
        }
        return s;
    }
    scan(f, initial) {
        const s = new Stream(most.scan(f, initial, this));
        if (this.holding) {
            s.value = initial;
        }
        return s;
    }
    loop(stepper, seed) {
        return new Stream(most.loop(stepper, seed, this));
    }
    withItems(items) {
        return new Stream(most.withItems(items, this));
    }
    zipItems(f, items) {
        return new Stream(most.zipItems(f, items, this));
    }
    switchLatest() {
        return new Stream(most.switchLatest(this));
    }
    join() {
        return new Stream(most.join(this));
    }
    chain(f) {
        return new Stream(most.chain(f, this));
    }
    concatMap(f) {
        return new Stream(most.concatMap(f, this));
    }
    mergeConcurrently(concurrency) {
        return new Stream(most.mergeConcurrently(concurrency, this));
    }
    mergeMapConcurrently(f, concurrency) {
        return new Stream(most.mergeMapConcurrently(f, concurrency, this));
    }
    merge(stream1) {
        const s = new Stream(most.merge(stream1, this));
        if (this.holding) {
            s.value = this.value;
        }
        return s;
    }
    combine(f, stream1) {
        const s = new Stream(most.combine(f, stream1, this));
        if (this.holding) {
            s.value = f(stream1.value, this.value);
        }
        return s;
    }
    zip(f, stream1) {
        const s = new Stream(most.zip(f, stream1, this));
        if (this.holding) {
            s.value = f(stream1.value, this.value);
        }
        return s;
    }
    resample(sampler) {
        return new Stream(most.sample(this, sampler));
    }
    sample(values) {
        return new Stream(most.sample(values, this));
    }
    snapshot(f, values) {
        return new Stream(most.snapshot(f, values, this));
    }
    filter(p) {
        const s = new Stream(most.filter(p, this));
        if (this.holding && p(this.value)) {
            s.value = this.value;
        }
        return s;
    }
    skipRepeats() {
        const s = new Stream(most.skipRepeats(this));
        if (this.holding) {
            s.value = this.value;
        }
        return s;
    }
    skipRepeatsWith(equals) {
        return new Stream(most.skipRepeatsWith(equals, this));
    }
    slice(start, end) {
        return new Stream(most.slice(start, end, this));
    }
    take(n) {
        return new Stream(most.take(n, this));
    }
    skip(n) {
        return new Stream(most.skip(n, this));
    }
    takeWhile(p) {
        return new Stream(most.takeWhile(p, this));
    }
    skipWhile(p) {
        return new Stream(most.skipWhile(p, this));
    }
    skipAfter(p) {
        return new Stream(most.skipAfter(p, this));
    }
    until(endSignal) {
        return new Stream(most.until(endSignal, this));
    }
    since(startSignal) {
        return new Stream(most.since(startSignal, this));
    }
    during(timeWindow) {
        return new Stream(most.during(timeWindow, this));
    }
    delay(delayTime) {
        return new Stream(most.delay(delayTime, this));
    }
    withLocalTime(origin) {
        return new Stream(most.withLocalTime(origin, this));
    }
    throttle(period) {
        return new Stream(most.throttle(period, this));
    }
    debounce(period) {
        return new Stream(most.debounce(period, this));
    }
    awaitPromises() {
        return new Stream(most.awaitPromises(this));
    }
    recoverWith(f) {
        return new Stream(most.recoverWith(f, this));
    }
    static empty() {
        return new Stream(most.empty());
    }
    static never() {
        return new Stream(most.never());
    }
    static now(x) {
        return new Stream(most.now(x));
    }
    static at(t, x) {
        return new Stream(most.at(t, x));
    }
    static periodic(period) {
        return new Stream(most.periodic(period));
    }
    static throwError(e) {
        return new Stream(most.throwError(e));
    }
}
_Stream_hold = new WeakMap(), _Stream_running = new WeakMap(), _Stream_startPromise = new WeakMap();
Stream.nextId = 0;
Stream.numActive = 0;
function createStream(s, hold = false) {
    return new Stream(s, hold);
}

var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Debug"] = 0] = "Debug";
    LogLevel[LogLevel["Info"] = 1] = "Info";
    LogLevel[LogLevel["Warning"] = 2] = "Warning";
    LogLevel[LogLevel["Error"] = 3] = "Error";
})(LogLevel || (LogLevel = {}));
const $log = new Stream(never());
const logger = {
    log(...messages) {
        // eslint-disable-next-line no-console
        console.log(...messages);
        $log.set([
            LogLevel.Info,
            messages
                .filter((x) => x !== undefined)
                .map((x) => x.toString())
                .join(' '),
        ]);
    },
    debug(...messages) {
        $log.set([
            LogLevel.Debug,
            messages
                .filter((x) => x !== undefined)
                .map((x) => x.toString())
                .join(' '),
        ]);
    },
    info(...messages) {
        this.log(...messages);
    },
    warning(...messages) {
        $log.set([
            LogLevel.Warning,
            messages
                .filter((x) => x !== undefined)
                .map((x) => x.toString())
                .join(' '),
        ]);
    },
    error(...messages) {
        // eslint-disable-next-line no-console
        console.error(...messages);
        $log.set([
            LogLevel.Error,
            messages
                .filter((x) => x !== undefined)
                .map((x) => x.toString())
                .join(' '),
        ]);
    },
};
function getLogStream() {
    return $log;
}

function Catch(target, propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    // eslint-disable-next-line no-param-reassign
    descriptor.value = function safeMethod(...args) {
        try {
            return originalMethod.apply(this, args);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            logger.error(error);
            notification({
                title: error.name,
                message: error.message,
                type: 'danger',
            });
            return error;
        }
    };
    return descriptor;
}
class TrainingError extends Error {
    constructor(message) {
        super(message);
        this.name = 'Training Error';
    }
}
function throwError(error, { duration = 3000 } = {}) {
    logger.error(`${error.name}: ${error.message}`, error);
    notification({
        title: error.name,
        message: error.message,
        type: 'danger',
        duration,
    });
}

/*
 * This is a modification of Itiriri-Async:
 * https://github.com/labs42io/itiriri-async/
 */
function filter(source, predicate) {
    return async function* () {
        let index = 0;
        for await (const element of source()) {
            if (predicate(element, index++)) {
                yield await element;
            }
        }
    };
}
function map(source, transform) {
    return async function* () {
        let index = 0;
        for await (const element of source()) {
            yield await transform(element, index++);
        }
    };
}
function skip(source, count) {
    if (count < 0) {
        throw Error('Negative count is not supported, use await and sync iterator instead.');
    }
    return async function* () {
        yield* filter(source, (_, index) => index >= count)();
    };
}
function take(source, count) {
    if (count < 0) {
        throw Error('Negative count is not supported, use await and sync iterator instead.');
    }
    return async function* () {
        let n = count;
        for await (const element of source()) {
            if (n-- === 0)
                return;
            yield await element;
        }
    };
}
function concat$1(left, right) {
    return async function* () {
        yield* await left();
        yield* await right;
    };
}
async function forEach(source, action) {
    let index = 0;
    for await (const element of source()) {
        action(element, index++);
    }
}
async function toArray(source) {
    const result = [];
    for await (const element of source()) {
        result.push(element);
    }
    return result;
}

/*
 * This is a modification of Itiriri-Async:
 * https://github.com/labs42io/itiriri-async/
 */
function zip(source, others) {
    return async function* () {
        const rightIterator = others()[Symbol.asyncIterator]();
        for await (const leftValue of source()) {
            const right = await rightIterator.next();
            if (right.done)
                return;
            yield [leftValue, right.value];
        }
    };
}

/*
 * This is a modification of Itiriri-Async:
 * https://github.com/labs42io/itiriri-async/
 */
async function reduce(source, callback, initialValue) {
    let [index, accumulator] = [-1, initialValue];
    for await (const element of source()) {
        accumulator =
            ++index === 0 && initialValue === undefined ? element : callback(accumulator, element, index);
    }
    if (initialValue === undefined && index === -1) {
        throw new Error('Sequence contains no elements.');
    }
    return accumulator;
}

/*
 * This is a modification of Itiriri-Async:
 * https://github.com/labs42io/itiriri-async/
 */
function isIterable$1(item) {
    return typeof item[Symbol.iterator] === 'function';
}
function isAsyncIterable(item) {
    return typeof item[Symbol.asyncIterator] === 'function';
}
class LazyIterable {
    constructor(source) {
        this.source = source;
    }
    [Symbol.asyncIterator]() {
        return this.source()[Symbol.asyncIterator]();
    }
    entries() {
        return new LazyIterable(map(this.source, (elem, idx) => [idx, elem]));
    }
    keys() {
        return new LazyIterable(map(this.source, (_, idx) => idx));
    }
    values() {
        return new LazyIterable(this.source);
    }
    forEach(action) {
        return forEach(this.source, action);
    }
    concat(other) {
        if (isIterable$1(other)) {
            return new LazyIterable(concat$1(this.source, (async function* (e) {
                yield* e;
            })(other)));
        }
        return isAsyncIterable(other)
            ? new LazyIterable(concat$1(this.source, other))
            : new LazyIterable(concat$1(this.source, (async function* (e) {
                yield e;
            })(other)));
    }
    reduce(callback, initialValue) {
        return reduce(this.source, callback, initialValue);
    }
    filter(predicate) {
        return new LazyIterable(filter(this.source, predicate));
    }
    take(count) {
        return new LazyIterable(take(this.source, count));
    }
    skip(count) {
        return new LazyIterable(skip(this.source, count));
    }
    map(selector) {
        return new LazyIterable(map(this.source, selector));
    }
    zip(other) {
        return new LazyIterable(zip(this.source, other));
    }
    toArray() {
        return toArray(this.source);
    }
}

class ArrayIterable extends LazyIterable {
    constructor(array) {
        super(async function* () {
            for (const x of array) {
                yield x;
            }
        });
    }
}
function iterableFromArray(arr) {
    return new ArrayIterable(arr);
}

/**
 * Simple object check.
 * @param item
 * @returns {boolean}
 */
function isObject(item) {
    return item && typeof item === 'object' && !Array.isArray(item);
}
/**
 * Deep merge two objects.
 * @param target
 * @param ...sources
 */
function mergeDeep(target, ...sources) {
    if (!sources.length)
        return target;
    const source = sources.shift();
    const result = { ...target };
    if (isObject(target) && isObject(source)) {
        // eslint-disable-next-line no-restricted-syntax
        for (const key in source) {
            if (isObject(source[key])) {
                if (!result[key])
                    Object.assign(result, { [key]: {} });
                result[key] = mergeDeep(result[key], source[key]);
            }
            else {
                Object.assign(result, { [key]: source[key] });
            }
        }
    }
    return mergeDeep(result, ...sources);
}

if (window) {
    window.onerror = (message) => {
        if (typeof message === 'string') {
            notification({
                title: 'An error occurred',
                message,
                type: 'danger',
            });
        }
    };
    window.addEventListener('unhandledrejection', (event) => {
        notification({
            title: 'An error occurred',
            message: event.reason,
            type: 'danger',
        });
    });
}

let nextId = 0;
class Component {
    constructor() {
        this.id = `component-${String(nextId++).padStart(3, '0')}`;
        this.$$ = {
            streams: [],
            app: undefined,
        };
        autoBind(this);
    }
    destroy() {
        var _a;
        (_a = this.$$.app) === null || _a === void 0 ? void 0 : _a.$destroy();
        this.$$.app = undefined;
    }
    start() {
        this.$$.streams = Object.entries(this)
            .filter(([x, s]) => x[0] === '$' && isStream(s))
            .map(([, stream]) => {
            stream.start();
            return stream;
        });
    }
    stop() {
        for (const s of this.$$.streams) {
            s.stop();
        }
    }
    dispose() {
        this.destroy();
        this.stop();
    }
}

/* eslint-disable no-bitwise */
let oidIndex = ~~(Math.random() * 0xffffff);
const MACHINE_ID = parseInt((Math.random() * 0xffffff).toString(), 10);
function genId() {
    const time = ~~(Date.now() / 1000);
    // Use pid
    const pid = Math.floor(Math.random() * 100000);
    oidIndex = (oidIndex + 1) % 0xffffff;
    const inc = oidIndex;
    // Buffer used
    const buffer = new Uint8Array(12);
    // Encode time
    buffer[3] = time & 0xff;
    buffer[2] = (time >> 8) & 0xff;
    buffer[1] = (time >> 16) & 0xff;
    buffer[0] = (time >> 24) & 0xff;
    // Encode machine
    buffer[6] = MACHINE_ID & 0xff;
    buffer[5] = (MACHINE_ID >> 8) & 0xff;
    buffer[4] = (MACHINE_ID >> 16) & 0xff;
    // Encode pid
    buffer[8] = pid & 0xff;
    buffer[7] = (pid >> 8) & 0xff;
    // Encode index
    buffer[11] = inc & 0xff;
    buffer[10] = (inc >> 8) & 0xff;
    buffer[9] = (inc >> 16) & 0xff;
    // Return the buffer
    return buffer.reduce((memo, i) => memo + `0${i.toString(16)}`.slice(-2), '');
}

const canvas2 = document.createElement('canvas');
const ctx2 = canvas2.getContext('2d');
const image2 = new Image();
function convertURIToImageData(URI) {
    return new Promise((resolve, reject) => {
        if (!URI) {
            reject();
        }
        else {
            image2.addEventListener('load', () => {
                canvas2.width = image2.width;
                canvas2.height = image2.height;
                ctx2 === null || ctx2 === void 0 ? void 0 : ctx2.drawImage(image2, 0, 0, canvas2.width, canvas2.height);
                resolve(ctx2 === null || ctx2 === void 0 ? void 0 : ctx2.getImageData(0, 0, canvas2.width, canvas2.height));
            }, false);
            image2.src = URI;
        }
    });
}

function addObjectId(context) {
    const { data, service } = context;
    context.data = {
        [service.id]: genId(),
        ...data,
    };
    return context;
}
function renameIdField(context) {
    const { result, params } = context;
    if (result) {
        if (result._id) {
            result.id = result._id;
            delete result._id;
        }
        else if (result.total && Array.isArray(result.data)) {
            for (const [i, x] of result.data.entries()) {
                if (x._id) {
                    result.data[i].id = result.data[i]._id;
                    delete result.data[i]._id;
                }
            }
        }
    }
    else if (params && params.query) {
        if (params.query.id) {
            context.params.query._id = context.params.query.id;
            delete context.params.query.id;
        }
        if (params.query.$select &&
            params.query.$select.includes('id') &&
            !params.query.$select.includes('_id')) {
            context.params.query.$select.push('_id');
        }
    }
    return context;
}
function createDate(context) {
    if (!context.data) {
        context.data = {};
    }
    context.data.createdAt = new Date();
    context.data.updatedAt = context.data.createdAt;
    return context;
}
function updateDate(context) {
    if (!context.data || !context.data.createdAt) {
        return context;
    }
    context.data.updatedAt = new Date();
    return context;
}
function addScope(key, value) {
    return (context) => {
        const { data } = context;
        context.data = {
            [key]: value,
            ...data,
        };
        return context;
    };
}
function limitToScope(key, value) {
    return (context) => {
        context.params = context.params || {};
        context.params.query = context.params.query || {};
        context.params.query[key] = value;
        return context;
    };
}
const canvas1 = document.createElement('canvas');
const ctx1 = canvas1.getContext('2d');
async function imageData2DataURL(context) {
    const { data } = context;
    for (const [key, val] of Object.entries(data)) {
        if (val instanceof ImageData) {
            const w = val.width;
            const h = val.height;
            canvas1.width = w;
            canvas1.height = h;
            ctx1.putImageData(val, 0, 0); // synchronous
            context.data[key] = canvas1.toDataURL('image/jpeg');
        }
    }
    return context;
}
async function dataURL2ImageData(context) {
    if (!context.result)
        return context;
    const { result } = context;
    const hasImageData = (data) => data && typeof data === 'string' && data.slice(0, 22) === 'data:image/jpeg;base64';
    if (result._id) {
        for (const [key, val] of Object.entries(result).filter(([k]) => k !== 'thumbnail')) {
            if (hasImageData(val)) {
                result[key] = await convertURIToImageData(val);
            }
        }
    }
    else if (result.total && Array.isArray(result.data)) {
        for (const [i, v] of result.data.entries()) {
            for (const [key, val] of Object.entries(v).filter(([k]) => k !== 'thumbnail')) {
                if (hasImageData(val)) {
                    result.data[i][key] = await convertURIToImageData(val);
                }
            }
        }
    }
    return context;
}
async function findDistinct(context) {
    var _a, _b;
    if (!((_b = (_a = context.params) === null || _a === void 0 ? void 0 : _a.query) === null || _b === void 0 ? void 0 : _b.$distinct) || context.type !== 'before' || context.method !== 'find') {
        return context;
    }
    const { $distinct, ...query } = context.params.query;
    query.$select = [$distinct];
    query.$skip = 0;
    let tot = 1;
    const distinct = new Set();
    while (query.$skip < tot) {
        const res = (await context.service.find({ query }));
        for (const x of res.data) {
            distinct.add(x[$distinct]);
        }
        query.$skip += res.limit;
        tot = res.total;
    }
    context.result = Array.from(distinct);
    return context;
}

/* src/core/data-store/Login.svelte generated by Svelte v3.52.0 */

function create_else_block_2(ctx) {
	let t;

	return {
		c() {
			t = text$1("Register");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (39:8) {#if mode === 'login'}
function create_if_block_3$5(ctx) {
	let t;

	return {
		c() {
			t = text$1("Log In");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (43:4) {#if loginError}
function create_if_block_2$8(ctx) {
	let div;
	let span0;
	let t0;
	let span1;
	let b;
	let t2;
	let t3;
	let t4;
	let button;

	return {
		c() {
			div = element("div");
			span0 = element("span");
			span0.innerHTML = `<i class="fas fa-bell"></i>`;
			t0 = space();
			span1 = element("span");
			b = element("b");
			b.textContent = "Login Error";
			t2 = space();
			t3 = text$1(/*loginError*/ ctx[1]);
			t4 = space();
			button = element("button");
			button.innerHTML = `<span>×</span>`;
			attr(span0, "class", "text-xl inline-block mr-5 align-middle");
			attr(b, "class", "capitalize");
			attr(span1, "class", "inline-block align-middle mr-8");
			attr(button, "class", "absolute bg-transparent text-2xl font-semibold leading-none right-0 top-0 mt-4 mr-6 outline-none focus:outline-none");
			attr(div, "class", "text-white px-6 py-4 border-0 rounded relative mb-4 bg-red-500");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, span0);
			append(div, t0);
			append(div, span1);
			append(span1, b);
			append(span1, t2);
			append(span1, t3);
			append(div, t4);
			append(div, button);
		},
		p(ctx, dirty) {
			if (dirty & /*loginError*/ 2) set_data(t3, /*loginError*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (90:38) {:else}
function create_else_block_1$1(ctx) {
	let t;

	return {
		c() {
			t = text$1("Register");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (90:10) {#if mode === 'login'}
function create_if_block_1$d(ctx) {
	let t;

	return {
		c() {
			t = text$1("Log In");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (98:6) {:else}
function create_else_block$j(ctx) {
	let t0;
	let button;
	let mounted;
	let dispose;

	return {
		c() {
			t0 = text$1("Already have an account?\n        ");
			button = element("button");
			button.textContent = "Log In";
			attr(button, "class", "text-blue-500");
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, button, anchor);

			if (!mounted) {
				dispose = listen(button, "click", /*toggleMode*/ ctx[2]);
				mounted = true;
			}
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (95:6) {#if mode === 'login'}
function create_if_block$t(ctx) {
	let t0;
	let button;
	let mounted;
	let dispose;

	return {
		c() {
			t0 = text$1("Don't have an account?\n        ");
			button = element("button");
			button.textContent = "Register Here";
			attr(button, "class", "text-blue-500");
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, button, anchor);

			if (!mounted) {
				dispose = listen(button, "click", /*toggleMode*/ ctx[2]);
				mounted = true;
			}
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (35:0) <Modal>
function create_default_slot$A(ctx) {
	let div4;
	let div0;
	let h2;
	let t0;
	let p0;
	let t2;
	let t3;
	let form;
	let div1;
	let t6;
	let div2;
	let t9;
	let div3;
	let button;
	let t10;
	let p1;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*mode*/ ctx[0] === 'login') return create_if_block_3$5;
		return create_else_block_2;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type(ctx);
	let if_block1 = /*loginError*/ ctx[1] && create_if_block_2$8(ctx);

	function select_block_type_1(ctx, dirty) {
		if (/*mode*/ ctx[0] === 'login') return create_if_block_1$d;
		return create_else_block_1$1;
	}

	let current_block_type_1 = select_block_type_1(ctx);
	let if_block2 = current_block_type_1(ctx);

	function select_block_type_2(ctx, dirty) {
		if (/*mode*/ ctx[0] === 'login') return create_if_block$t;
		return create_else_block$j;
	}

	let current_block_type_2 = select_block_type_2(ctx);
	let if_block3 = current_block_type_2(ctx);

	return {
		c() {
			div4 = element("div");
			div0 = element("div");
			h2 = element("h2");
			if_block0.c();
			t0 = space();
			p0 = element("p");
			p0.textContent = "This Marcelle application requires authentication.";
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			form = element("form");
			div1 = element("div");

			div1.innerHTML = `<label class="block uppercase text-gray-700 text-xs font-bold mb-2" for="grid-password">Email</label> 
        <input type="email" name="email" class="bg-gray-200 appearance-none border-2 border-gray-200 rounded w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none focus:bg-white focus:border-purple-500" placeholder="Email" style="transition: all 0.15s ease 0s;"/>`;

			t6 = space();
			div2 = element("div");

			div2.innerHTML = `<label class="block uppercase text-gray-700 text-xs font-bold mb-2" for="grid-password">Password</label> 
        <input type="password" name="password" class="bg-gray-200 appearance-none border-2 border-gray-200 rounded w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none focus:bg-white focus:border-purple-500" placeholder="Password" style="transition: all 0.15s ease 0s;"/>`;

			t9 = space();
			div3 = element("div");
			button = element("button");
			if_block2.c();
			t10 = space();
			p1 = element("p");
			if_block3.c();
			attr(h2, "class", "text-xl");
			attr(p0, "class", "text-gray-600");
			attr(div0, "class", "p-4 text-center");
			attr(div1, "class", "relative w-full mb-3");
			attr(div2, "class", "relative w-full mb-3");
			attr(button, "class", "bg-gray-900 text-white active:bg-gray-700 text-sm font-bold uppercase px-6 py-3 rounded shadow hover:shadow-lg outline-none focus:outline-none mr-1 mb-1 w-full");
			attr(button, "type", "submit");
			set_style(button, "transition", "all 0.15s ease 0s");
			attr(div3, "class", "text-center mt-6");
			attr(p1, "class", "my-4");
			attr(div4, "class", "marcelle p-12");
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			append(div4, div0);
			append(div0, h2);
			if_block0.m(h2, null);
			append(div0, t0);
			append(div0, p0);
			append(div4, t2);
			if (if_block1) if_block1.m(div4, null);
			append(div4, t3);
			append(div4, form);
			append(form, div1);
			append(form, t6);
			append(form, div2);
			append(form, t9);
			append(form, div3);
			append(div3, button);
			if_block2.m(button, null);
			append(div4, t10);
			append(div4, p1);
			if_block3.m(p1, null);

			if (!mounted) {
				dispose = listen(form, "submit", prevent_default(/*submit_handler*/ ctx[7]));
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(h2, null);
				}
			}

			if (/*loginError*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2$8(ctx);
					if_block1.c();
					if_block1.m(div4, t3);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (current_block_type_1 !== (current_block_type_1 = select_block_type_1(ctx))) {
				if_block2.d(1);
				if_block2 = current_block_type_1(ctx);

				if (if_block2) {
					if_block2.c();
					if_block2.m(button, null);
				}
			}

			if (current_block_type_2 === (current_block_type_2 = select_block_type_2(ctx)) && if_block3) {
				if_block3.p(ctx, dirty);
			} else {
				if_block3.d(1);
				if_block3 = current_block_type_2(ctx);

				if (if_block3) {
					if_block3.c();
					if_block3.m(p1, null);
				}
			}
		},
		d(detaching) {
			if (detaching) detach(div4);
			if_block0.d();
			if (if_block1) if_block1.d();
			if_block2.d();
			if_block3.d();
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$L(ctx) {
	let modal;
	let current;

	modal = new Modal({
			props: {
				$$slots: { default: [create_default_slot$A] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(modal.$$.fragment);
		},
		m(target, anchor) {
			mount_component(modal, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const modal_changes = {};

			if (dirty & /*$$scope, mode, loginError*/ 515) {
				modal_changes.$$scope = { dirty, ctx };
			}

			modal.$set(modal_changes);
		},
		i(local) {
			if (current) return;
			transition_in(modal.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(modal.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(modal, detaching);
		}
	};
}

function instance$L($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { dataStore } = $$props;
	let { mode = 'login' } = $$props;
	let loginError;

	function toggleMode() {
		$$invalidate(0, mode = mode === 'login' ? 'register' : 'login');
	}

	function terminate(user) {
		dispatch('terminate', user);
	}

	async function login(e) {
		const data = new FormData(e.target);

		try {
			const user = await dataStore.login(data.get('email'), data.get('password'));
			terminate(user);
		} catch(error) {
			$$invalidate(1, loginError = error);
		}
	}

	async function signup(e) {
		const data = new FormData(e.target);

		try {
			const user = await dataStore.signup(data.get('email'), data.get('password'));
			terminate(user);
		} catch(error) {
			terminate(null);
		}
	}

	const submit_handler = e => mode === 'login' ? login(e) : signup(e);

	$$self.$$set = $$props => {
		if ('dataStore' in $$props) $$invalidate(5, dataStore = $$props.dataStore);
		if ('mode' in $$props) $$invalidate(0, mode = $$props.mode);
	};

	return [
		mode,
		loginError,
		toggleMode,
		login,
		signup,
		dataStore,
		terminate,
		submit_handler
	];
}

class Login extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$L, create_fragment$L, safe_not_equal, { dataStore: 5, mode: 0, terminate: 6 });
	}

	get terminate() {
		return this.$$.ctx[6];
	}
}

class ServiceIterable extends LazyIterable {
    constructor(service, params = {}) {
        super(async function* () {
            const p = { query: {}, skip: 0, take: -1, ...params };
            const take = p.take;
            let took = 0;
            let buffer = [];
            const nextQuery = {
                ...p.query,
                $skip: p.skip,
                $limit: 10,
            };
            // eslint-disable-next-line no-constant-condition
            while (true) {
                try {
                    if (take > 0 && took >= take) {
                        return;
                    }
                    took++;
                    if (buffer.length > 0) {
                        const value = buffer.shift();
                        yield value;
                    }
                    else {
                        const found = (await service.find({ query: nextQuery }));
                        nextQuery.$skip = found.skip + found.limit;
                        buffer = found.data;
                        if (buffer.length > 0) {
                            const value = buffer.shift();
                            yield value;
                        }
                        else {
                            return;
                        }
                    }
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                }
                catch (e) {
                    // Modify the error message but leave the stack trace intact
                    e.message = `Error thrown while iterating through a service: ${e.message}`;
                    throw e;
                }
            }
        });
        this.service = service;
        this.params = { query: {}, skip: 0, take: -1, ...params };
    }
    skip(n) {
        return new ServiceIterable(this.service, { ...this.params, skip: n });
    }
    take(n) {
        return new ServiceIterable(this.service, { ...this.params, take: n });
    }
    select(fields) {
        const p = cloneDeep(this.params);
        p.query.$select = fields;
        return new ServiceIterable(this.service, p);
    }
    query(q) {
        return new ServiceIterable(this.service, mergeDeep(this.params, { query: q }));
    }
}
function iterableFromService(service) {
    return new ServiceIterable(service);
}

var _DataStore_initPromise, _DataStore_connectPromise, _DataStore_authenticationPromise, _DataStore_authenticating, _DataStore_createService;
function isValidUrl(str) {
    try {
        // eslint-disable-next-line no-new
        new URL(str);
    }
    catch (_) {
        return false;
    }
    return true;
}
var DataStoreBackend;
(function (DataStoreBackend) {
    DataStoreBackend[DataStoreBackend["Memory"] = 0] = "Memory";
    DataStoreBackend[DataStoreBackend["LocalStorage"] = 1] = "LocalStorage";
    DataStoreBackend[DataStoreBackend["Remote"] = 2] = "Remote";
})(DataStoreBackend || (DataStoreBackend = {}));
class DataStore {
    constructor(location = 'memory') {
        this.requiresAuth = false;
        this.apiPrefix = '';
        this.$services = new Stream([], true);
        _DataStore_initPromise.set(this, void 0);
        _DataStore_connectPromise.set(this, void 0);
        _DataStore_authenticationPromise.set(this, Promise.resolve());
        _DataStore_authenticating.set(this, false);
        _DataStore_createService.set(this, noop);
        this.feathers = feathers();
        this.location = location;
        if (isValidUrl(location)) {
            this.backend = DataStoreBackend.Remote;
            const locUrl = new URL(location);
            const host = locUrl.host;
            this.apiPrefix = locUrl.pathname.replace(/\/$/, '');
            const socket = io(host, {
                transports: ['websocket'],
                reconnectionAttempts: 5,
                path: this.apiPrefix + '/socket.io',
            });
            this.feathers.configure(socketio(socket, { timeout: 15000 }));
            __classPrivateFieldSet(this, _DataStore_initPromise, new Promise((resolve) => {
                this.feathers.io.on('init', ({ auth }) => {
                    this.requiresAuth = auth;
                    if (auth) {
                        this.feathers.configure(authentication({ path: `${this.apiPrefix}/authentication` }));
                    }
                    resolve();
                });
            }), "f");
        }
        else if (location === 'localStorage') {
            this.backend = DataStoreBackend.LocalStorage;
            const storageService = (name) => localStorageService({
                storage: window.localStorage,
                name,
                id: '_id',
                multi: true,
                paginate: {
                    default: 100,
                    max: 200,
                },
            });
            __classPrivateFieldSet(this, _DataStore_createService, (name) => {
                this.feathers.use(`/${name}`, storageService(name));
            }, "f");
        }
        else if (location === 'memory') {
            this.backend = DataStoreBackend.Memory;
            __classPrivateFieldSet(this, _DataStore_createService, (name) => {
                this.feathers.use(`/${name}`, memoryService({
                    id: '_id',
                    paginate: {
                        default: 100,
                        max: 200,
                    },
                }));
            }, "f");
        }
        else {
            throw new Error(`Cannot process backend location '${location}'`);
        }
        this.setupAppHooks();
    }
    async connect() {
        if (this.backend !== DataStoreBackend.Remote) {
            return { email: null };
        }
        if (!__classPrivateFieldGet(this, _DataStore_connectPromise, "f")) {
            logger.log(`Connecting to backend ${this.location}...`);
            __classPrivateFieldSet(this, _DataStore_connectPromise, new Promise((resolve, reject) => {
                this.feathers.io.on('connect', () => {
                    logger.log(`Connected to backend ${this.location}!`);
                    resolve();
                });
                this.feathers.io.on('reconnect_failed', () => {
                    const e = new Error(`Cannot reach backend at location ${this.location}. Is the server running?
          If using locally, run 'npm run backend'`);
                    e.name = 'DataStore connection error';
                    reject();
                    throwError(e, { duration: 0 });
                });
            }), "f");
        }
        await __classPrivateFieldGet(this, _DataStore_initPromise, "f");
        await __classPrivateFieldGet(this, _DataStore_connectPromise, "f");
        return this.authenticate();
    }
    async authenticate() {
        if (!this.requiresAuth) {
            this.user = { email: null };
            return this.user;
        }
        if (this.user) {
            return this.user;
        }
        const doAuth = () => {
            __classPrivateFieldSet(this, _DataStore_authenticating, true, "f");
            return new Promise((resolve, reject) => {
                this.feathers
                    .reAuthenticate()
                    .then(({ user }) => {
                    __classPrivateFieldSet(this, _DataStore_authenticating, false, "f");
                    this.user = user;
                    logger.log(`Authenticated as ${user.email}`);
                    resolve();
                })
                    .catch((err) => {
                    __classPrivateFieldSet(this, _DataStore_authenticating, false, "f");
                    reject(err);
                });
            });
        };
        __classPrivateFieldSet(this, _DataStore_authenticationPromise, __classPrivateFieldGet(this, _DataStore_authenticationPromise, "f").then(() => __classPrivateFieldGet(this, _DataStore_authenticating, "f") ? null : doAuth()), "f");
        return __classPrivateFieldGet(this, _DataStore_authenticationPromise, "f").then(() => this.user);
    }
    async login(email, password) {
        const res = await this.feathers.authenticate({ strategy: 'local', email, password });
        this.user = res.user;
        return this.user;
    }
    async loginWithUI() {
        const app = new Login({
            target: document.body,
            props: { dataStore: this },
        });
        return new Promise((resolve, reject) => {
            app.$on('terminate', (user) => {
                app.$destroy();
                if (user) {
                    resolve(user);
                }
                else {
                    reject();
                }
            });
        });
    }
    async signup(email, password) {
        try {
            await this.service('users').create({ email, password });
            await this.login(email, password);
            return this.user;
        }
        catch (error) {
            logger.error('An error occurred during signup', error);
            return { email: null };
        }
    }
    async logout() {
        await this.feathers.logout();
        document.location.reload();
    }
    service(name) {
        const serviceExists = Object.keys(this.feathers.services).includes(name);
        if (!serviceExists) {
            __classPrivateFieldGet(this, _DataStore_createService, "f").call(this, name);
            this.$services.set(Object.keys(this.feathers.services));
        }
        const s = this.backend === DataStoreBackend.Remote
            ? this.feathers.service(`${this.apiPrefix}/${name}`)
            : this.feathers.service(name);
        if (!serviceExists) {
            s.items = () => iterableFromService(s);
        }
        return s;
    }
    setupAppHooks() {
        const beforeCreate = this.backend !== DataStoreBackend.Remote ? [addObjectId] : [];
        const findDistinctHook = this.backend !== DataStoreBackend.Remote ? [findDistinct] : [];
        this.feathers.hooks({
            before: {
                find: [...findDistinctHook, renameIdField],
                create: [...beforeCreate, createDate],
                update: [updateDate],
                patch: [updateDate],
            },
            after: {
                find: [renameIdField],
                get: [renameIdField],
                create: [renameIdField],
                update: [renameIdField],
                patch: [renameIdField],
                remove: [renameIdField],
            },
        });
    }
}
_DataStore_initPromise = new WeakMap(), _DataStore_connectPromise = new WeakMap(), _DataStore_authenticationPromise = new WeakMap(), _DataStore_authenticating = new WeakMap(), _DataStore_createService = new WeakMap();

function dataStore(location) {
    return new DataStore(location);
}

async function saveBlob(data, name, type) {
    const link = document.createElement('a');
    link.style.display = 'none';
    document.body.appendChild(link);
    const blob = new Blob([data], { type });
    link.href = URL.createObjectURL(blob);
    link.download = name;
    link.click();
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function readJSONFile(f) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
            const fileContent = JSON.parse(reader.result);
            resolve(fileContent);
        };
        reader.onerror = (e) => {
            reject(e);
        };
        reader.readAsText(f);
    });
}

function toKebabCase(str) {
    return str
        .replace(/([a-z])([A-Z])/g, '$1-$2')
        .replace(/[\s_]+/g, '-')
        .toLowerCase();
}

var _Dataset_store, _Dataset_updatedCreate;
class Dataset extends Component {
    constructor(name, store = dataStore()) {
        super();
        this.title = 'dataset';
        this.isDataset = true;
        _Dataset_store.set(this, void 0);
        this.query = {};
        _Dataset_updatedCreate.set(this, new Set());
        this.$count = new Stream(0, true);
        this.$changes = new Stream([]);
        this.name = name;
        this.title = `dataset (${name})`;
        __classPrivateFieldSet(this, _Dataset_store, store, "f");
        this.start();
        this.ready = new Promise((resolve, reject) => {
            __classPrivateFieldGet(this, _Dataset_store, "f")
                .connect()
                .then(() => this.setup())
                .then(resolve)
                .catch((e) => {
                const err = new Error(e === null || e === void 0 ? void 0 : e.message);
                err.name = `Dataset Error (${name}): datastore connection failed`;
                throwError(err, { duration: 0 });
                reject(err);
            });
        });
    }
    async setup() {
        const instanceServiceName = toKebabCase(`instances-${this.name}`);
        this.instanceService = __classPrivateFieldGet(this, _Dataset_store, "f").service(instanceServiceName);
        if (this.instanceService.__hooks.before.find === undefined) {
            this.instanceService.hooks({
                before: {
                    all: [],
                    create: [addScope('datasetName', this.name), imageData2DataURL],
                    find: [limitToScope('datasetName', this.name)],
                    get: [limitToScope('datasetName', this.name)],
                    update: [limitToScope('datasetName', this.name)],
                    patch: [limitToScope('datasetName', this.name)],
                    remove: [limitToScope('datasetName', this.name)],
                },
                after: {
                    find: [dataURL2ImageData],
                    get: [dataURL2ImageData],
                },
            });
        }
        this.instanceService.hooks({
            before: {
                update: [this.checkUpdates],
                patch: [this.checkUpdates],
            },
        });
        await this.reset();
        this.watchChanges();
    }
    async reset() {
        const { total } = (await this.find({ query: { $limit: 0 } }));
        this.$count.set(total);
        this.$changes.set([
            {
                level: 'dataset',
                type: 'created',
            },
        ]);
    }
    async checkUpdates(context) {
        if (Object.keys(this.query).length === 0)
            return;
        const respectsQuery = sift(this.query);
        const isTargetValid = respectsQuery(context.data);
        try {
            const current = await this.get(context.id);
            const isCurrentValid = respectsQuery(current);
            if (isCurrentValid && !isTargetValid) {
                this.$count.set(this.$count.get() - 1);
                this.$changes.set([
                    {
                        level: 'instance',
                        type: 'removed',
                        data: current,
                    },
                ]);
            }
        }
        catch (error) {
            __classPrivateFieldGet(this, _Dataset_updatedCreate, "f").add(context.id);
        }
    }
    watchChanges() {
        const respectsQuery = sift(this.query);
        this.instanceService.on('created', (x) => {
            if (!respectsQuery(x))
                return;
            const instance = {
                ...x,
                id: x.id || x._id,
            };
            this.$count.set(this.$count.get() + 1);
            this.$changes.set([
                {
                    level: 'instance',
                    type: 'created',
                    data: instance,
                },
            ]);
        });
        const cb = (x) => {
            if (!respectsQuery(x))
                return;
            const instance = {
                ...x,
                id: x.id || x._id,
            };
            if (__classPrivateFieldGet(this, _Dataset_updatedCreate, "f").has(instance.id)) {
                this.$count.set(this.$count.get() + 1);
                this.$changes.set([
                    {
                        level: 'instance',
                        type: 'created',
                        data: instance,
                    },
                ]);
                __classPrivateFieldGet(this, _Dataset_updatedCreate, "f").delete(instance.id);
            }
            else {
                this.$changes.set([
                    {
                        level: 'instance',
                        type: 'updated',
                        data: instance,
                    },
                ]);
            }
        };
        this.instanceService.on('updated', cb);
        this.instanceService.on('patched', cb);
        this.instanceService.on('removed', (x) => {
            if (!respectsQuery(x))
                return;
            this.$count.set(this.$count.get() - 1);
            const instance = {
                ...x,
                id: x.id || x._id,
            };
            this.$changes.set([
                {
                    level: 'instance',
                    type: 'removed',
                    data: instance,
                },
            ]);
        });
    }
    async sift(query = {}) {
        this.query = query;
        return this.ready.then(() => this.reset());
    }
    items() {
        return this.instanceService.items().query(this.query);
    }
    async find(params) {
        const p = mergeDeep(params || {}, { query: this.query });
        return this.instanceService.find(p);
    }
    async get(id, params) {
        const p = mergeDeep(params || {}, { query: this.query });
        return this.instanceService.get(id, p);
    }
    async create(instance, params) {
        const p = mergeDeep(params || {}, { query: this.query });
        return this.instanceService.create(instance, p);
    }
    async update(id, instance, params) {
        const p = mergeDeep(params || {}, { query: this.query });
        return this.instanceService.update(id, instance, p);
    }
    async patch(id, changes, params) {
        const p = mergeDeep(params || {}, { query: this.query });
        return this.instanceService.patch(id, changes, p);
    }
    async remove(id, params) {
        const p = mergeDeep(params || {}, { query: this.query });
        return this.instanceService.remove(id, p);
    }
    async clear() {
        await this.remove(null, { query: {} });
    }
    async distinct(field) {
        const query = { $distinct: field, ...this.query };
        return this.instanceService.find({ query });
    }
    async download() {
        const instances = await this.find();
        const fileContents = {
            marcelleMeta: {
                type: 'dataset',
            },
            instances: instances.data,
        };
        const today = new Date(Date.now());
        const fileName = `${this.title}-${today.toISOString()}.json`;
        await saveBlob(JSON.stringify(fileContents), fileName, 'text/plain');
    }
    async upload(files) {
        const filePromises = files
            .filter((f) => f.type === 'application/json')
            .map((f) => readJSONFile(f));
        const jsonFiles = await Promise.all(filePromises);
        const addPromises = jsonFiles.map((fileContent) => fileContent.instances.map((instance) => {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            const { id, ...instanceNoId } = instance;
            return this.create(instanceNoId).catch((e) => {
                throwError(e);
            });
        }));
        await Promise.all(addPromises);
    }
    mount() {
        // Nothing to show
    }
}
_Dataset_store = new WeakMap(), _Dataset_updatedCreate = new WeakMap();

function dataset(name, store) {
    return new Dataset(name, store);
}
function isDataset(x) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return typeof x === 'object' && x !== null && x.isDataset;
}

class Model extends Component {
    constructor() {
        super();
        this.ready = false;
        this.$training = new Stream({ status: 'idle' }, true);
        this.$training.start();
        this.$training.subscribe(({ status }) => {
            if (status === 'success' || status === 'loaded') {
                this.ready = true;
            }
        });
    }
    sync(store, name) {
        this.syncData = { name, store };
        this.syncData.store
            .connect()
            .then(() => {
            this.syncData.service = this.syncData.store.service(this.serviceName);
            this.setupSync();
        })
            .catch((e) => {
            const err = new Error(e === null || e === void 0 ? void 0 : e.message);
            err.name = `Model Sync Error (${name}): datastore connection failed`;
            throwError(err, { duration: 0 });
        });
        return this;
    }
    async setupSync() {
        if (!this.syncData.service)
            return;
        const { data } = (await this.syncData.service.find({
            query: {
                name: this.syncData.name,
                $select: ['id'],
                $limit: 1,
                $sort: {
                    updatedAt: -1,
                },
            },
        }));
        let id = null;
        if (data.length === 1) {
            id = data[0].id;
            this.load(this.syncData.store, id);
        }
        let skipNextUpdate = false;
        this.$training.subscribe(({ status, data: meta }) => {
            if (status === 'success' || (status === 'loaded' && (meta === null || meta === void 0 ? void 0 : meta.source) !== 'datastore')) {
                skipNextUpdate = true;
                this.save(this.syncData.store, this.syncData.name, {}, id).then((newId) => {
                    id = newId;
                });
            }
        });
        const cb = (s) => {
            if (s._id === id || (!id && s.name === this.syncData.name)) {
                id = s._id;
                if (!skipNextUpdate) {
                    this.load(this.syncData.store, id);
                }
                skipNextUpdate = false;
            }
        };
        this.syncData.service.on('created', cb);
        this.syncData.service.on('updated', cb);
        this.syncData.service.on('patched', cb);
    }
    async saveToDatastore(store, model, id = null) {
        await store.connect();
        const service = store.service(this.serviceName);
        if (!service)
            return null;
        if (!model)
            return null;
        let newId = id;
        if (id) {
            await service.update(id, model);
        }
        else {
            const res = await service.create(model);
            newId = res.id;
        }
        logger.info(`Model was saved to data store at location ${store.location}`);
        return newId;
    }
    async loadFromDatastore(store, idOrName) {
        await store.connect();
        const service = store.service(this.serviceName);
        if (!service || !idOrName)
            return null;
        let model;
        try {
            model = await service.get(idOrName);
        }
        catch (error) {
            const { data } = (await service.find({
                query: {
                    name: idOrName,
                    $limit: 1,
                    $sort: {
                        updatedAt: -1,
                    },
                },
            }));
            if (data.length === 1) {
                model = data[0];
            }
        }
        if (model) {
            const name = model.name;
            logger.info(`Model ${name} was loaded from data store at location ${store.location}`);
        }
        return model;
    }
    mount() {
        // Nothing to show
    }
}

function fixSeparableConv2D(artifacts) {
    if (!artifacts.modelTopology.model_config ||
        !artifacts.modelTopology.model_config.config ||
        !artifacts.modelTopology.model_config.config.layers ||
        (artifacts.modelTopology.model_config.config.layers.length > 0 &&
            !artifacts.modelTopology.model_config.config.layers[0].class_name)) {
        return artifacts;
    }
    try {
        let removeKernels = false;
        for (const [i, layer] of artifacts.modelTopology.model_config.config.layers.entries()) {
            if (layer.class_name === 'SeparableConv2D') {
                const fields = ['kernel_constraint', 'kernel_initializer', 'kernel_regularizer'];
                for (const field of fields) {
                    if (Object.keys(artifacts.modelTopology.model_config.config.layers[i].config).includes(field)) {
                        removeKernels = true;
                    }
                    // eslint-disable-next-line no-param-reassign
                    delete artifacts.modelTopology.model_config.config.layers[i].config[field];
                }
            }
        }
        if (removeKernels) {
            logger.warning('TFJS Model loading: experimentally removing Kernel attributes from SeparableConv2D layers');
        }
    }
    catch (error) {
        logger.warning('TFJS Model loading: An error occurred whil experimentally removing Kernel attributes from SeparableConv2D layers', error);
    }
    return artifacts;
}
function http(...args) {
    const loader = io$1.http(...args);
    const superLoad = loader.load.bind(loader);
    loader.load = async function loadx() {
        const x = await superLoad();
        return fixSeparableConv2D(x);
    };
    return loader;
}
function browserFiles(...args) {
    const loader = io$1.browserFiles(...args);
    const superLoad = loader.load.bind(loader);
    loader.load = async function loadx() {
        const x = await superLoad();
        return fixSeparableConv2D(x);
    };
    return loader;
}

class TFJSBaseModel extends Model {
    constructor() {
        super(...arguments);
        this.serviceName = 'tfjs-models';
    }
    async warmup() {
        const inputShape = this.model.inputs[0].shape.map((x) => (x && x > 0 ? x : 1));
        const warmupResult = this.model.predict(tidy$1(() => zeros$1(inputShape)));
        await warmupResult.data();
        warmupResult.dispose();
    }
    async save(store, name, metadata, id = null) {
        if (!this.model)
            return null;
        let files;
        if (store.backend === DataStoreBackend.LocalStorage) {
            await this.model.save(`indexeddb://${name}`);
            files = [['main', `indexeddb://${name}`]];
        }
        else if (store.backend === DataStoreBackend.Remote) {
            const requestOpts = {};
            if (store.requiresAuth) {
                const jwt = await store.feathers.authentication.getAccessToken();
                const headers = new Headers({ Authorization: `Bearer ${jwt}` });
                requestOpts.requestInit = { headers };
            }
            files = await this.model
                .save(http(`${store.location}/tfjs-models/upload`, requestOpts))
                .then((res) => res.responses[0].json());
        }
        const storedModel = {
            name,
            files,
            format: 'tfjs',
            metadata: {
                tfjsModelFormat: this.model instanceof LayersModel ? 'layers-model' : 'graph-model',
                ...(this.labels && { labels: this.labels }),
                ...metadata,
            },
        };
        return this.saveToDatastore(store, storedModel, id);
    }
    async load(store, idOrName) {
        if (!idOrName)
            return null;
        this.$training.set({
            status: 'loading',
        });
        this.ready = false;
        try {
            const storedModel = await this.loadFromDatastore(store, idOrName);
            this.loadFn =
                storedModel.metadata.tfjsModelFormat === 'graph-model' ? loadGraphModel : loadLayersModel;
            let model;
            if (store.backend === DataStoreBackend.LocalStorage) {
                model = await this.loadFn(storedModel.files[0][1]);
            }
            else if (store.backend === DataStoreBackend.Remote) {
                const requestOpts = {};
                if (store.requiresAuth) {
                    const jwt = await store.feathers.authentication.getAccessToken();
                    const headers = new Headers({ Authorization: `Bearer ${jwt}` });
                    requestOpts.requestInit = { headers };
                }
                model = await this.loadFn(http(`${store.location}/tfjs-models/${storedModel.id}/model.json`, requestOpts));
            }
            if (model) {
                this.model = model;
                await this.warmup();
            }
            if (storedModel.metadata && storedModel.metadata.labels) {
                this.labels = storedModel.metadata.labels;
            }
            else {
                // logger.log("Couldn't Find labels in the stored model's metadata");
                this.labels = undefined;
            }
            this.$training.set({
                status: 'loaded',
                data: {
                    source: 'datastore',
                    url: store.location,
                },
            });
            return storedModel;
        }
        catch (error) {
            // eslint-disable-next-line no-console
            console.log('[tfjs-model] Loading error', error);
            this.$training.set({
                status: 'error',
            });
            throw error;
        }
    }
    async download(metadata) {
        const name = toKebabCase(this.title);
        const meta = {
            type: 'tfjs-model',
            tfjsModelFormat: this.model instanceof LayersModel ? 'layers-model' : 'graph-model',
            name,
            ...(this.labels && { labels: this.labels }),
            ...metadata,
        };
        const dateSaved = new Date(Date.now());
        await this.model.save(io$1.withSaveHandler(async (data) => {
            const weightsManifest = {
                modelTopology: data.modelTopology,
                weightsManifest: [
                    {
                        paths: [`./${name}.weights.bin`],
                        weights: data.weightSpecs,
                    },
                ],
                marcelle: meta,
            };
            await saveBlob(data.weightData, `${name}.weights.bin`, 'application/octet-stream');
            await saveBlob(JSON.stringify(weightsManifest), `${name}.json`, 'text/plain');
            return { modelArtifactsInfo: { dateSaved, modelTopologyType: 'JSON' } };
        }));
    }
    async upload(...files) {
        this.$training.set({
            status: 'loading',
        });
        try {
            const jsonFiles = files.filter((x) => x.name.includes('.json'));
            const weightFiles = files.filter((x) => x.name.includes('.bin'));
            const { marcelle: meta } = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    const obj = JSON.parse(reader.result);
                    resolve(obj);
                };
                reader.onerror = (err) => reject(new Error(`The provided files are not a valid marcelle model ${err}`));
                reader.readAsText(jsonFiles[0]);
            });
            this.loadFn = meta.tfjsModelFormat === 'graph-model' ? loadGraphModel : loadLayersModel;
            if (jsonFiles.length === 1 && files.length) {
                const model = await this.loadFn(browserFiles([jsonFiles[0], ...weightFiles]));
                if (model) {
                    this.model = model;
                    await this.warmup();
                }
                if (meta && meta.labels) {
                    this.labels = meta.labels;
                }
                else {
                    // logger.log("Couldn't Find labels in the stored model's metadata");
                    this.labels = null;
                }
                this.$training.set({
                    status: 'loaded',
                    data: {
                        source: 'file',
                    },
                });
                return { name: meta.name, format: 'tfjs', files: [], metadata: meta };
            }
            const e = new Error('The provided files are not compatible with this model');
            e.name = 'File upload error';
            throw e;
        }
        catch (error) {
            this.$training.set({
                status: 'error',
            });
            throw error;
        }
    }
}
__decorate([
    Catch
], TFJSBaseModel.prototype, "warmup", null);
__decorate([
    Catch
], TFJSBaseModel.prototype, "upload", null);

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const EPSILON_FLOAT32 = 1e-7;
const EPSILON_FLOAT16 = 1e-4;
/**
 * The interface that defines the kernels that should be implemented when
 * adding a new backend. New backends don't need to implement every one of the
 * methods, this can be done gradually (throw an error for unimplemented
 * methods).
 */
class KernelBackend {
    refCount(dataId) {
        return notYetImplemented('refCount');
    }
    incRef(dataId) {
        return notYetImplemented('incRef');
    }
    timerAvailable() {
        return true;
    }
    time(f) {
        return notYetImplemented('time');
    }
    read(dataId) {
        return notYetImplemented('read');
    }
    readSync(dataId) {
        return notYetImplemented('readSync');
    }
    readToGPU(dataId, options) {
        return notYetImplemented('readToGPU');
    }
    numDataIds() {
        return notYetImplemented('numDataIds');
    }
    disposeData(dataId, force) {
        return notYetImplemented('disposeData');
    }
    write(values, shape, dtype) {
        return notYetImplemented('write');
    }
    move(dataId, values, shape, dtype, refCount) {
        return notYetImplemented('move');
    }
    memory() {
        return notYetImplemented('memory');
    }
    /** Returns the highest precision for floats in bits (e.g. 16 or 32) */
    floatPrecision() {
        return notYetImplemented('floatPrecision');
    }
    /** Returns the smallest representable number.  */
    epsilon() {
        return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;
    }
    dispose() {
        return notYetImplemented('dispose');
    }
}
function notYetImplemented(kernelName) {
    throw new Error(`'${kernelName}' not yet implemented or not found in the registry. ` +
        `This kernel may not be supported by the tfjs backend you have chosen`);
}

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Asserts that the expression is true. Otherwise throws an error with the
 * provided message.
 *
 * ```js
 * const x = 2;
 * tf.util.assert(x === 2, 'x is not 2');
 * ```
 *
 * @param expr The expression to assert (as a boolean).
 * @param msg A function that returns the message to report when throwing an
 *     error. We use a function for performance reasons.
 *
 * @doc {heading: 'Util', namespace: 'util'}
 */
function assert(expr, msg) {
    if (!expr) {
        throw new Error(typeof msg === 'string' ? msg : msg());
    }
}
function assertShapesMatch(shapeA, shapeB, errorMessagePrefix = '') {
    assert(arraysEqual(shapeA, shapeB), () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);
}
function assertNonNull(a) {
    assert(a != null, () => `The input to the tensor constructor must be a non-null value.`);
}
// NOTE: We explicitly type out what T extends instead of any so that
// util.flatten on a nested array of number doesn't try to infer T as a
// number[][], causing us to explicitly type util.flatten<number>().
/**
 *  Flattens an arbitrarily nested array.
 *
 * ```js
 * const a = [[1, 2], [3, 4], [5, [6, [7]]]];
 * const flat = tf.util.flatten(a);
 * console.log(flat);
 * ```
 *
 *  @param arr The nested array to flatten.
 *  @param result The destination array which holds the elements.
 *  @param skipTypedArray If true, avoids flattening the typed arrays. Defaults
 *      to false.
 *
 * @doc {heading: 'Util', namespace: 'util'}
 */
function flatten(arr, result = [], skipTypedArray = false) {
    if (result == null) {
        result = [];
    }
    if (Array.isArray(arr) || isTypedArray(arr) && !skipTypedArray) {
        for (let i = 0; i < arr.length; ++i) {
            flatten(arr[i], result, skipTypedArray);
        }
    }
    else {
        result.push(arr);
    }
    return result;
}
/**
 * Returns the size (number of elements) of the tensor given its shape.
 *
 * ```js
 * const shape = [3, 4, 2];
 * const size = tf.util.sizeFromShape(shape);
 * console.log(size);
 * ```
 *
 * @doc {heading: 'Util', namespace: 'util'}
 */
function sizeFromShape(shape) {
    if (shape.length === 0) {
        // Scalar.
        return 1;
    }
    let size = shape[0];
    for (let i = 1; i < shape.length; i++) {
        size *= shape[i];
    }
    return size;
}
function arraysEqual(n1, n2) {
    if (n1 === n2) {
        return true;
    }
    if (n1 == null || n2 == null) {
        return false;
    }
    if (n1.length !== n2.length) {
        return false;
    }
    for (let i = 0; i < n1.length; i++) {
        if (n1[i] !== n2[i]) {
            return false;
        }
    }
    return true;
}
function isInt(a) {
    return a % 1 === 0;
}
function rightPad(a, size) {
    if (size <= a.length) {
        return a;
    }
    return a + ' '.repeat(size - a.length);
}
function parseAxisParam(axis, shape) {
    const rank = shape.length;
    // Normalize input
    axis = axis == null ? shape.map((s, i) => i) : [].concat(axis);
    // Check for valid range
    assert(axis.every(ax => ax >= -rank && ax < rank), () => `All values in axis param must be in range [-${rank}, ${rank}) but ` +
        `got axis ${axis}`);
    // Check for only integers
    assert(axis.every(ax => isInt(ax)), () => `All values in axis param must be integers but ` +
        `got axis ${axis}`);
    // Handle negative axis.
    return axis.map(a => a < 0 ? rank + a : a);
}
/** Reduces the shape by removing all dimensions of shape 1. */
function squeezeShape(shape, axis) {
    const newShape = [];
    const keptDims = [];
    const isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;
    const axes = (axis == null || isEmptyArray) ?
        null :
        parseAxisParam(axis, shape).sort();
    let j = 0;
    for (let i = 0; i < shape.length; ++i) {
        if (axes != null) {
            if (axes[j] === i && shape[i] !== 1) {
                throw new Error(`Can't squeeze axis ${i} since its dim '${shape[i]}' is not 1`);
            }
            if ((axes[j] == null || axes[j] > i) && shape[i] === 1) {
                newShape.push(shape[i]);
                keptDims.push(i);
            }
            if (axes[j] <= i) {
                j++;
            }
        }
        if (shape[i] !== 1) {
            newShape.push(shape[i]);
            keptDims.push(i);
        }
    }
    return { newShape, keptDims };
}
function getArrayFromDType(dtype, size) {
    let values = null;
    if (dtype == null || dtype === 'float32') {
        values = new Float32Array(size);
    }
    else if (dtype === 'int32') {
        values = new Int32Array(size);
    }
    else if (dtype === 'bool') {
        values = new Uint8Array(size);
    }
    else if (dtype === 'string') {
        values = new Array(size);
    }
    else {
        throw new Error(`Unknown data type ${dtype}`);
    }
    return values;
}
function checkConversionForErrors(vals, dtype) {
    for (let i = 0; i < vals.length; i++) {
        const num = vals[i];
        if (isNaN(num) || !isFinite(num)) {
            throw Error(`A tensor of type ${dtype} being uploaded contains ${num}.`);
        }
    }
}
/** Returns true if the dtype is valid. */
function isValidDtype(dtype) {
    return dtype === 'bool' || dtype === 'complex64' || dtype === 'float32' ||
        dtype === 'int32' || dtype === 'string';
}
function isTypedArray(a) {
    return a instanceof Float32Array || a instanceof Int32Array ||
        a instanceof Uint8Array || a instanceof Uint8ClampedArray;
}
function bytesPerElement(dtype) {
    if (dtype === 'float32' || dtype === 'int32') {
        return 4;
    }
    else if (dtype === 'complex64') {
        return 8;
    }
    else if (dtype === 'bool') {
        return 1;
    }
    else {
        throw new Error(`Unknown dtype ${dtype}`);
    }
}
/**
 * Returns the approximate number of bytes allocated in the string array - 2
 * bytes per character. Computing the exact bytes for a native string in JS
 * is not possible since it depends on the encoding of the html page that
 * serves the website.
 */
function bytesFromStringArray(arr) {
    if (arr == null) {
        return 0;
    }
    let bytes = 0;
    arr.forEach(x => bytes += x.length);
    return bytes;
}
/** Returns true if the value is a string. */
function isString(value) {
    return typeof value === 'string' || value instanceof String;
}
function isBoolean(value) {
    return typeof value === 'boolean';
}
function isNumber(value) {
    return typeof value === 'number';
}
function inferDtype(values) {
    if (Array.isArray(values)) {
        return inferDtype(values[0]);
    }
    if (values instanceof Float32Array) {
        return 'float32';
    }
    else if (values instanceof Int32Array || values instanceof Uint8Array ||
        values instanceof Uint8ClampedArray) {
        return 'int32';
    }
    else if (isNumber(values)) {
        return 'float32';
    }
    else if (isString(values)) {
        return 'string';
    }
    else if (isBoolean(values)) {
        return 'bool';
    }
    return 'float32';
}
function isFunction(f) {
    return !!(f && f.constructor && f.call && f.apply);
}
function computeStrides(shape) {
    const rank = shape.length;
    if (rank < 2) {
        return [];
    }
    // Last dimension has implicit stride of 1, thus having D-1 (instead of D)
    // strides.
    const strides = new Array(rank - 1);
    strides[rank - 2] = shape[rank - 1];
    for (let i = rank - 3; i >= 0; --i) {
        strides[i] = strides[i + 1] * shape[i + 1];
    }
    return strides;
}
function createNestedArray(offset, shape, a, isComplex = false) {
    const ret = new Array();
    if (shape.length === 1) {
        const d = shape[0] * (isComplex ? 2 : 1);
        for (let i = 0; i < d; i++) {
            ret[i] = a[offset + i];
        }
    }
    else {
        const d = shape[0];
        const rest = shape.slice(1);
        const len = rest.reduce((acc, c) => acc * c) * (isComplex ? 2 : 1);
        for (let i = 0; i < d; i++) {
            ret[i] = createNestedArray(offset + i * len, rest, a, isComplex);
        }
    }
    return ret;
}
// Provide a nested array of TypedArray in given shape.
function toNestedArray(shape, a, isComplex = false) {
    if (shape.length === 0) {
        // Scalar type should return a single number.
        return a[0];
    }
    const size = shape.reduce((acc, c) => acc * c) * (isComplex ? 2 : 1);
    if (size === 0) {
        // A tensor with shape zero should be turned into empty list.
        return [];
    }
    if (size !== a.length) {
        throw new Error(`[${shape}] does not match the input size ${a.length}${isComplex ? ' for a complex tensor' : ''}.`);
    }
    return createNestedArray(0, shape, a, isComplex);
}
function makeOnesTypedArray(size, dtype) {
    const array = makeZerosTypedArray(size, dtype);
    for (let i = 0; i < array.length; i++) {
        array[i] = 1;
    }
    return array;
}
function makeZerosTypedArray(size, dtype) {
    if (dtype == null || dtype === 'float32' || dtype === 'complex64') {
        return new Float32Array(size);
    }
    else if (dtype === 'int32') {
        return new Int32Array(size);
    }
    else if (dtype === 'bool') {
        return new Uint8Array(size);
    }
    else {
        throw new Error(`Unknown data type ${dtype}`);
    }
}
function assertNonNegativeIntegerDimensions(shape) {
    shape.forEach(dimSize => {
        assert(Number.isInteger(dimSize) && dimSize >= 0, () => `Tensor must have a shape comprised of positive integers but got ` +
            `shape [${shape}].`);
    });
}
/**
 * This method asserts whether an object is a Promise instance.
 * @param object
 */
// tslint:disable-next-line: no-any
function isPromise(object) {
    //  We chose to not use 'obj instanceOf Promise' for two reasons:
    //  1. It only reliably works for es6 Promise, not other Promise
    //  implementations.
    //  2. It doesn't work with framework that uses zone.js. zone.js monkey
    //  patch the async calls, so it is possible the obj (patched) is
    //  comparing to a pre-patched Promise.
    return object && object.then && typeof object.then === 'function';
}

/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
// Expects flags from URL in the format ?tfjsflags=FLAG1:1,FLAG2:true.
const TENSORFLOWJS_FLAGS_PREFIX = 'tfjsflags';
/**
 * The environment contains evaluated flags as well as the registered platform.
 * This is always used as a global singleton and can be retrieved with
 * `tf.env()`.
 *
 * @doc {heading: 'Environment'}
 */
class Environment {
    // tslint:disable-next-line: no-any
    constructor(global) {
        this.global = global;
        this.flags = {};
        this.flagRegistry = {};
        this.urlFlags = {};
        // Jasmine spies on this in 'environment_test.ts'
        this.getQueryParams = getQueryParams;
        this.populateURLFlags();
    }
    setPlatform(platformName, platform) {
        if (this.platform != null) {
            if (!(env().getBool('IS_TEST') || env().getBool('PROD'))) {
                console.warn(`Platform ${this.platformName} has already been set. ` +
                    `Overwriting the platform with ${platformName}.`);
            }
        }
        this.platformName = platformName;
        this.platform = platform;
    }
    registerFlag(flagName, evaluationFn, setHook) {
        this.flagRegistry[flagName] = { evaluationFn, setHook };
        // Override the flag value from the URL. This has to happen here because
        // the environment is initialized before flags get registered.
        if (this.urlFlags[flagName] != null) {
            const flagValue = this.urlFlags[flagName];
            if (!(env().getBool('IS_TEST') || env().getBool('PROD'))) {
                console.warn(`Setting feature override from URL ${flagName}: ${flagValue}.`);
            }
            this.set(flagName, flagValue);
        }
    }
    async getAsync(flagName) {
        if (flagName in this.flags) {
            return this.flags[flagName];
        }
        this.flags[flagName] = await this.evaluateFlag(flagName);
        return this.flags[flagName];
    }
    get(flagName) {
        if (flagName in this.flags) {
            return this.flags[flagName];
        }
        const flagValue = this.evaluateFlag(flagName);
        if (isPromise(flagValue)) {
            throw new Error(`Flag ${flagName} cannot be synchronously evaluated. ` +
                `Please use getAsync() instead.`);
        }
        this.flags[flagName] = flagValue;
        return this.flags[flagName];
    }
    getNumber(flagName) {
        return this.get(flagName);
    }
    getBool(flagName) {
        return this.get(flagName);
    }
    getFlags() {
        return this.flags;
    }
    // For backwards compatibility.
    get features() {
        return this.flags;
    }
    set(flagName, value) {
        if (this.flagRegistry[flagName] == null) {
            throw new Error(`Cannot set flag ${flagName} as it has not been registered.`);
        }
        this.flags[flagName] = value;
        if (this.flagRegistry[flagName].setHook != null) {
            this.flagRegistry[flagName].setHook(value);
        }
    }
    evaluateFlag(flagName) {
        if (this.flagRegistry[flagName] == null) {
            throw new Error(`Cannot evaluate flag '${flagName}': no evaluation function found.`);
        }
        return this.flagRegistry[flagName].evaluationFn();
    }
    setFlags(flags) {
        this.flags = Object.assign({}, flags);
    }
    reset() {
        this.flags = {};
        this.urlFlags = {};
        this.populateURLFlags();
    }
    populateURLFlags() {
        if (typeof this.global === 'undefined' ||
            typeof this.global.location === 'undefined' ||
            typeof this.global.location.search === 'undefined') {
            return;
        }
        const urlParams = this.getQueryParams(this.global.location.search);
        if (TENSORFLOWJS_FLAGS_PREFIX in urlParams) {
            const keyValues = urlParams[TENSORFLOWJS_FLAGS_PREFIX].split(',');
            keyValues.forEach(keyValue => {
                const [key, value] = keyValue.split(':');
                this.urlFlags[key] = parseValue(key, value);
            });
        }
    }
}
function getQueryParams(queryString) {
    const params = {};
    queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (s, ...t) => {
        decodeParam(params, t[0], t[1]);
        return t.join('=');
    });
    return params;
}
function decodeParam(params, name, value) {
    params[decodeURIComponent(name)] = decodeURIComponent(value || '');
}
function parseValue(flagName, value) {
    value = value.toLowerCase();
    if (value === 'true' || value === 'false') {
        return value === 'true';
    }
    else if (`${+value}` === value) {
        return +value;
    }
    throw new Error(`Could not parse value flag value ${value} for flag ${flagName}.`);
}
/**
 * Returns the current environment (a global singleton).
 *
 * The environment object contains the evaluated feature values as well as the
 * active platform.
 *
 * @doc {heading: 'Environment'}
 */
function env() {
    return ENV;
}
let ENV = null;
function setEnvironmentGlobal(environment) {
    ENV = environment;
}

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
// Note that the identifier globalNameSpace is scoped to this module, but will
// always resolve to the same global object regardless of how the module is
// resolved.
// tslint:disable-next-line:no-any
let globalNameSpace;
// tslint:disable-next-line:no-any
function getGlobalNamespace() {
    if (globalNameSpace == null) {
        // tslint:disable-next-line:no-any
        let ns;
        if (typeof (window) !== 'undefined') {
            ns = window;
        }
        else if (typeof (global) !== 'undefined') {
            ns = global;
        }
        else if (typeof (process) !== 'undefined') {
            ns = process;
        }
        else if (typeof (self) !== 'undefined') {
            ns = self;
        }
        else {
            throw new Error('Could not find a global object');
        }
        globalNameSpace = ns;
    }
    return globalNameSpace;
}
// tslint:disable-next-line:no-any
function getGlobalMap() {
    const ns = getGlobalNamespace();
    if (ns._tfGlobals == null) {
        ns._tfGlobals = new Map();
    }
    return ns._tfGlobals;
}
/**
 * Returns a globally accessible 'singleton' object.
 *
 * @param key the name of the object
 * @param init a function to initialize to initialize this object
 *             the first time it is fetched.
 */
function getGlobal(key, init) {
    const globalMap = getGlobalMap();
    if (globalMap.has(key)) {
        return globalMap.get(key);
    }
    else {
        const singleton = init();
        globalMap.set(key, singleton);
        return globalMap.get(key);
    }
}

const Abs = 'Abs';
const Acos = 'Acos';
const Acosh = 'Acosh';
const Add = 'Add';
const AddN = 'AddN';
const All = 'All';
const Any = 'Any';
const ArgMax = 'ArgMax';
const ArgMin = 'ArgMin';
const Asin = 'Asin';
const Asinh = 'Asinh';
const Atan = 'Atan';
const Atanh = 'Atanh';
const Atan2 = 'Atan2';
const AvgPool = 'AvgPool';
const AvgPool3D = 'AvgPool3D';
const BatchMatMul = 'BatchMatMul';
const BatchToSpaceND = 'BatchToSpaceND';
const Bincount = 'Bincount';
const BroadcastArgs = 'BroadcastArgs';
const Cast = 'Cast';
const Ceil = 'Ceil';
const ClipByValue = 'ClipByValue';
const Complex = 'Complex';
const ComplexAbs = 'ComplexAbs';
const Concat = 'Concat';
const Conv2D = 'Conv2D';
const Conv2DBackpropFilter = 'Conv2DBackpropFilter';
const Conv2DBackpropInput = 'Conv2DBackpropInput';
const Conv3D = 'Conv3D';
const Conv3DBackpropInputV2 = 'Conv3DBackpropInputV2';
const Cos = 'Cos';
const Cosh = 'Cosh';
const Cumprod = 'Cumprod';
const Cumsum = 'Cumsum';
const CropAndResize = 'CropAndResize';
const DenseBincount = 'DenseBincount';
const DepthToSpace = 'DepthToSpace';
const DepthwiseConv2dNative = 'DepthwiseConv2dNative';
const DepthwiseConv2dNativeBackpropFilter = 'DepthwiseConv2dNativeBackpropFilter';
const DepthwiseConv2dNativeBackpropInput = 'DepthwiseConv2dNativeBackpropInput';
const Diag = 'Diag';
const Dilation2D = 'Dilation2D';
const RealDiv = 'RealDiv';
const Einsum = 'Einsum';
const Elu = 'Elu';
const Erf = 'Erf';
const Equal = 'Equal';
const Exp = 'Exp';
const ExpandDims = 'ExpandDims';
const Expm1 = 'Expm1';
const FFT = 'FFT';
const Fill = 'Fill';
const FlipLeftRight = 'FlipLeftRight';
const Floor = 'Floor';
const FloorDiv = 'FloorDiv';
const FusedBatchNorm = 'FusedBatchNorm';
const GatherV2 = 'GatherV2';
const GatherNd = 'GatherNd';
const Greater = 'Greater';
const GreaterEqual = 'GreaterEqual';
const Identity = 'Identity';
const IFFT = 'IFFT';
const Imag = 'Imag';
const IsFinite = 'IsFinite';
const IsInf = 'IsInf';
const IsNan = 'IsNan';
const LeakyRelu = 'LeakyRelu';
const Less = 'Less';
const LessEqual = 'LessEqual';
const Log = 'Log';
const Log1p = 'Log1p';
const LogicalAnd = 'LogicalAnd';
const LogicalNot = 'LogicalNot';
const LogicalOr = 'LogicalOr';
const LRN = 'LRN';
const Max = 'Max';
const Maximum = 'Maximum';
const MaxPool = 'MaxPool';
const MaxPool3D = 'MaxPool3D';
const MaxPoolWithArgmax = 'MaxPoolWithArgmax';
const Mean = 'Mean';
const Min = 'Min';
const Minimum = 'Minimum';
const MirrorPad = 'MirrorPad';
const Mod = 'Mod';
const Multinomial = 'Multinomial';
const Multiply = 'Multiply';
const Neg = 'Neg';
const NotEqual = 'NotEqual';
const NonMaxSuppressionV3 = 'NonMaxSuppressionV3';
const NonMaxSuppressionV4 = 'NonMaxSuppressionV4';
const NonMaxSuppressionV5 = 'NonMaxSuppressionV5';
const OnesLike = 'OnesLike';
const OneHot = 'OneHot';
const Pack = 'Pack';
const PadV2 = 'PadV2';
const Pow = 'Pow';
const Prelu = 'Prelu';
const Prod = 'Prod';
const RaggedGather = 'RaggedGather';
const RaggedTensorToTensor = 'RaggedTensorToTensor';
const Range = 'Range';
const Real = 'Real';
const Reciprocal = 'Reciprocal';
const Relu = 'Relu';
const Reshape = 'Reshape';
const ResizeNearestNeighbor = 'ResizeNearestNeighbor';
const ResizeBilinear = 'ResizeBilinear';
const Relu6 = 'Relu6';
const Reverse = 'Reverse';
const Round = 'Round';
const Rsqrt = 'Rsqrt';
const ScatterNd = 'ScatterNd';
const SearchSorted = 'SearchSorted';
const Select$1 = 'Select';
const Selu = 'Selu';
const Slice = 'Slice';
const Sin = 'Sin';
const Sinh = 'Sinh';
const Sign = 'Sign';
const Sigmoid = 'Sigmoid';
const Softplus = 'Softplus';
const Sqrt = 'Sqrt';
const Sum = 'Sum';
const SpaceToBatchND = 'SpaceToBatchND';
const SplitV = 'SplitV';
const Softmax = 'Softmax';
const SparseFillEmptyRows = 'SparseFillEmptyRows';
const SparseReshape = 'SparseReshape';
const SparseSegmentMean = 'SparseSegmentMean';
const SparseSegmentSum = 'SparseSegmentSum';
const SparseToDense = 'SparseToDense';
const SquaredDifference = 'SquaredDifference';
const StridedSlice = 'StridedSlice';
const StringNGrams = 'StringNGrams';
const StringSplit = 'StringSplit';
const StringToHashBucketFast = 'StringToHashBucketFast';
const Sub = 'Sub';
const Tan = 'Tan';
const Tanh = 'Tanh';
const Tile = 'Tile';
const TopK = 'TopK';
const Transform = 'Transform';
const Transpose = 'Transpose';
const Unique = 'Unique';
const Unpack = 'Unpack';
const UnsortedSegmentSum = 'UnsortedSegmentSum';
const ZerosLike = 'ZerosLike';
/**
 * TensorFlow.js-only kernels
 */
const Step = 'Step';
const RotateWithOffset = 'RotateWithOffset';
const _FusedMatMul = '_FusedMatMul';
const FusedConv2D = 'FusedConv2D';
const FusedDepthwiseConv2D = 'FusedDepthwiseConv2D';

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function warn(...msg) {
    if (!(env().getBool('IS_TEST') || env().getBool('PROD'))) {
        console.warn(...msg);
    }
}

/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const kernelRegistry = getGlobal('kernelRegistry', () => new Map());
const gradRegistry = getGlobal('gradRegistry', () => new Map());
/**
 * Returns the kernel function (code) associated with the provided names.
 *
 * @param kernelName The official name of the kernel.
 * @param backendName The official name of the backend.
 */
function getKernel(kernelName, backendName) {
    const key = makeKey(kernelName, backendName);
    return kernelRegistry.get(key);
}
/**
 * Returns the registered gradient info associated with the provided kernel.
 * @param kernelName The official TF kernel name.
 */
function getGradient(kernelName) {
    return gradRegistry.get(kernelName);
}
function getKernelsForBackend(backendName) {
    const it = kernelRegistry.entries();
    const result = [];
    while (true) {
        const { done, value } = it.next();
        if (done) {
            break;
        }
        const [key, config] = value;
        const [backend,] = key.split('_');
        if (backend === backendName) {
            result.push(config);
        }
    }
    return result;
}
function makeKey(kernelName, backendName) {
    return `${backendName}_${kernelName}`;
}

var long = Long$1;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long$1(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long$1.prototype.__isLong__;

Object.defineProperty(Long$1.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long$1.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long$1.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long$1.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long$1(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long$1.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long$1.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long$1.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long$1.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long$1.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long$1.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long$1.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long$1.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long$1.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long$1.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long$1.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long$1.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long$1.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long$1.fromBytesLE(bytes, unsigned) : Long$1.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long$1.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long$1(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long$1.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long$1(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};

var LongExports = /*#__PURE__*/_mergeNamespaces({
    __proto__: null,
    'default': long
}, [long]);

/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
// tslint:disable-next-line
const Long = 
// tslint:disable-next-line
long || LongExports;
function hexToLong(hex) {
    return Long.fromString(hex, true, 16);
}
// Some primes between 2^63 and 2^64 for various uses.
// Hex 0xc3a5c85c97cb3127
hexToLong('c3a5c85c97cb3127');
// Hex 0xb492b66fbe98f273
hexToLong('b492b66fbe98f273');
// Hex 0x9ae16a3b2f90404f
hexToLong('9ae16a3b2f90404f');

/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function noConversionNeeded(a, dtype) {
    return (a instanceof Float32Array && dtype === 'float32') ||
        (a instanceof Int32Array && dtype === 'int32') ||
        (a instanceof Uint8Array && dtype === 'bool');
}
function toTypedArray(a, dtype) {
    if (dtype === 'string') {
        throw new Error('Cannot convert a string[] to a TypedArray');
    }
    if (Array.isArray(a)) {
        a = flatten(a);
    }
    if (env().getBool('DEBUG')) {
        checkConversionForErrors(a, dtype);
    }
    if (noConversionNeeded(a, dtype)) {
        return a;
    }
    if (dtype == null || dtype === 'float32' || dtype === 'complex64') {
        return new Float32Array(a);
    }
    else if (dtype === 'int32') {
        return new Int32Array(a);
    }
    else if (dtype === 'bool') {
        const bool = new Uint8Array(a.length);
        for (let i = 0; i < bool.length; ++i) {
            if (Math.round(a[i]) !== 0) {
                bool[i] = 1;
            }
        }
        return bool;
    }
    else {
        throw new Error(`Unknown data type ${dtype}`);
    }
}
/**
 * Returns the current high-resolution time in milliseconds relative to an
 * arbitrary time in the past. It works across different platforms (node.js,
 * browsers).
 *
 * ```js
 * console.log(tf.util.now());
 * ```
 *
 * @doc {heading: 'Util', namespace: 'util'}
 */
function now() {
    return env().platform.now();
}
/**
 * Encodes the provided string into bytes using the provided encoding scheme.
 *
 * @param s The string to encode.
 * @param encoding The encoding scheme. Defaults to utf-8.
 *
 * @doc {heading: 'Util'}
 */
function encodeString(s, encoding = 'utf-8') {
    encoding = encoding || 'utf-8';
    return env().platform.encode(s, encoding);
}
/**
 * Decodes the provided bytes into a string using the provided encoding scheme.
 * @param bytes The bytes to decode.
 *
 * @param encoding The encoding scheme. Defaults to utf-8.
 *
 * @doc {heading: 'Util'}
 */
function decodeString(bytes, encoding = 'utf-8') {
    encoding = encoding || 'utf-8';
    return env().platform.decode(bytes, encoding);
}

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Profiler {
    constructor(backendTimer, logger) {
        this.backendTimer = backendTimer;
        this.logger = logger;
        if (logger == null) {
            this.logger = new Logger();
        }
    }
    profileKernel(kernelName, inputs, f) {
        let outputs;
        const holdResultWrapperFn = () => {
            outputs = f();
        };
        let timer;
        const start = now();
        if (this.backendTimer.timerAvailable()) {
            timer = this.backendTimer.time(holdResultWrapperFn);
        }
        else {
            holdResultWrapperFn();
            for (const output of outputs) {
                output.dataSync();
            }
            timer = Promise.resolve({ kernelMs: now() - start });
        }
        if (env().getBool('CHECK_COMPUTATION_FOR_ERRORS')) {
            for (let i = 0; i < outputs.length; i++) {
                const output = outputs[i];
                // Dangling promise here because we don't want to propagate up
                // asynchronicity.
                output.data().then(tensorVals => {
                    checkComputationForErrors(tensorVals, output.dtype, kernelName);
                });
            }
        }
        const kernelProfile = {
            kernelName,
            outputs,
            inputs,
            timeMs: timer.then(timing => timing.kernelMs),
            extraInfo: timer.then(timing => timing.getExtraProfileInfo != null ?
                timing.getExtraProfileInfo() :
                '')
        };
        return kernelProfile;
    }
    logKernelProfile(kernelProfile) {
        const { kernelName, outputs, timeMs, inputs, extraInfo } = kernelProfile;
        outputs.forEach(result => {
            Promise.all([result.data(), timeMs, extraInfo]).then(valueContainer => {
                this.logger.logKernelProfile(kernelName, result, valueContainer[0], valueContainer[1], inputs, valueContainer[2]);
            });
        });
    }
}
function checkComputationForErrors(vals, dtype, kernelName) {
    if (dtype !== 'float32') {
        // Only floating point computations will generate NaN values
        return false;
    }
    for (let i = 0; i < vals.length; i++) {
        const num = vals[i];
        if (isNaN(num) || !isFinite(num)) {
            // Throwing custom exception so behavior is testable.
            console.warn(`Found ${num} in the result of '${kernelName}'`);
            return true;
        }
    }
    return false;
}
class Logger {
    logKernelProfile(name, result, vals, timeMs, inputs, extraInfo) {
        const time = typeof timeMs === 'number' ? rightPad(`${timeMs}ms`, 9) :
            timeMs['error'];
        const paddedName = rightPad(name, 25);
        const rank = result.rank;
        const size = result.size;
        const shape = rightPad(result.shape.toString(), 14);
        let inputShapesDescription = '';
        for (const name in inputs) {
            const input = inputs[name];
            if (input != null) {
                // The input might be a non-tensor (e.g HTMLImageElement), in which case
                // we claim the output shape as input shape.
                const inputShape = input.shape || result.shape;
                const inputRank = inputShape.length;
                inputShapesDescription +=
                    `${name}: ${inputRank}D ${inputRank > 0 ? inputShape : ''} `;
            }
        }
        console.log(`%c${paddedName}\t%c${time}\t%c${rank}D ${shape}\t%c${size}\t%c${inputShapesDescription}\t%c${extraInfo}`, 'font-weight:bold', 'color:red', 'color:blue', 'color: orange', 'color: green', 'color: steelblue');
    }
}

/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes a list of TapeNodes that connect x to y, filtering everything else
 * out and preserving the order of the original tape elements.
 *
 * @param tape The tape elements to filter.
 * @param xs The input Tensors.
 * @param y The output Tensor.
 */
function getFilteredNodesXToY(tape, xs, y) {
    // Forward pass to compute all the nodes and Tensors that are transitively a
    // function of x.
    const tensorsFromX = {};
    const nodesFromX = {};
    for (let i = 0; i < xs.length; i++) {
        tensorsFromX[xs[i].id] = true;
    }
    for (let i = 0; i < tape.length; i++) {
        const node = tape[i];
        const nodeInputs = node.inputs;
        for (const inputName in nodeInputs) {
            const input = nodeInputs[inputName];
            let anyInputFromX = false;
            for (let j = 0; j < xs.length; j++) {
                if (tensorsFromX[input.id]) {
                    node.outputs.forEach(output => tensorsFromX[output.id] = true);
                    anyInputFromX = true;
                    nodesFromX[node.id] = true;
                    break;
                }
            }
            if (anyInputFromX) {
                break;
            }
        }
    }
    // Backward pass to find all of the nodes and Tensors that lead to y.
    const tensorsLeadToY = {};
    tensorsLeadToY[y.id] = true;
    const nodesToY = {};
    for (let i = tape.length - 1; i >= 0; i--) {
        const node = tape[i];
        const nodeInputs = node.inputs;
        // If any of the outputs lead to y, mark all of the inputs as leading to y.
        for (let j = 0; j < node.outputs.length; j++) {
            if (tensorsLeadToY[node.outputs[j].id]) {
                for (const inputName in nodeInputs) {
                    tensorsLeadToY[nodeInputs[inputName].id] = true;
                    nodesToY[node.id] = true;
                }
                break;
            }
        }
    }
    // Return the paths that come from x and lead to y.
    const filteredTape = [];
    for (let i = 0; i < tape.length; i++) {
        const node = tape[i];
        if (nodesFromX[node.id] && nodesToY[node.id]) {
            // Prune the inputs from the node that aren't a function of x.
            const prunedInputs = {};
            for (const inputName in node.inputs) {
                const nodeInput = node.inputs[inputName];
                if (tensorsFromX[nodeInput.id]) {
                    prunedInputs[inputName] = nodeInput;
                }
            }
            // Copy the node and overwrite inputsAndArgs to the pruned version.
            const prunedNode = Object.assign({}, node);
            prunedNode.inputs = prunedInputs;
            prunedNode.outputs = node.outputs;
            filteredTape.push(prunedNode);
        }
    }
    return filteredTape;
}
/**
 * Backpropagate gradients through the filtered TapeNodes.
 *
 * @param tensorAccumulatedGradientMap A map of Tensor to its gradient. This map
 * is mutated by this method.
 * @param filteredTape The filtered TapeNodes to backprop through.
 */
function backpropagateGradients(tensorAccumulatedGradientMap, filteredTape, tidy, add) {
    // Walk the tape backward and keep a map of Tensor to its gradient.
    for (let i = filteredTape.length - 1; i >= 0; i--) {
        const node = filteredTape[i];
        const dys = [];
        node.outputs.forEach(o => {
            const gradTensor = tensorAccumulatedGradientMap[o.id];
            if (gradTensor != null) {
                dys.push(gradTensor);
            }
            else {
                // This particular output is not in the back-propagation subgraph, so it
                // does not affect the final output, thus we put null for its dy.
                dys.push(null);
            }
        });
        if (node.gradient == null) {
            throw new Error(`Cannot compute gradient: gradient function not found ` +
                `for ${node.kernelName}.`);
        }
        // Backprop dy through this node and accumulate gradients over the inputs.
        const inputGradients = node.gradient(dys);
        for (const inputName in node.inputs) {
            if (!(inputName in inputGradients)) {
                throw new Error(`Cannot backprop through input ${inputName}. ` +
                    `Available gradients found: ${Object.keys(inputGradients)}.`);
            }
            // Call the gradient function.
            const dx = tidy(() => inputGradients[inputName]());
            if (dx.dtype !== 'float32') {
                throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input ` +
                    `${inputName} must have 'float32' dtype, but has '${dx.dtype}'`);
            }
            const x = node.inputs[inputName];
            if (!arraysEqual(dx.shape, x.shape)) {
                throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input ` +
                    `'${inputName}' has shape '${dx.shape}', which does not match ` +
                    `the shape of the input '${x.shape}'`);
            }
            if (tensorAccumulatedGradientMap[x.id] == null) {
                tensorAccumulatedGradientMap[x.id] = dx;
            }
            else {
                const curGradient = tensorAccumulatedGradientMap[x.id];
                tensorAccumulatedGradientMap[x.id] = add(curGradient, dx);
                curGradient.dispose();
            }
        }
    }
}

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
// Maximum number of values before we decide to show ellipsis.
const FORMAT_LIMIT_NUM_VALS = 20;
// Number of first and last values to show when displaying a, b,...,y, z.
const FORMAT_NUM_FIRST_LAST_VALS = 3;
// Number of significant digits to show.
const FORMAT_NUM_SIG_DIGITS = 7;
function tensorToString(vals, shape, dtype, verbose) {
    const strides = computeStrides(shape);
    const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);
    const rank = shape.length;
    const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);
    const lines = ['Tensor'];
    if (verbose) {
        lines.push(`  dtype: ${dtype}`);
        lines.push(`  rank: ${rank}`);
        lines.push(`  shape: [${shape}]`);
        lines.push(`  values:`);
    }
    lines.push(valsLines.map(l => '    ' + l).join('\n'));
    return lines.join('\n');
}
function computeMaxSizePerColumn(vals, shape, dtype, strides) {
    const n = sizeFromShape(shape);
    const numCols = strides[strides.length - 1];
    const padPerCol = new Array(numCols).fill(0);
    const rank = shape.length;
    const valuesOrTuples = dtype === 'complex64' ? createComplexTuples(vals) : vals;
    if (rank > 1) {
        for (let row = 0; row < n / numCols; row++) {
            const offset = row * numCols;
            for (let j = 0; j < numCols; j++) {
                padPerCol[j] = Math.max(padPerCol[j], valToString(valuesOrTuples[offset + j], 0, dtype).length);
            }
        }
    }
    return padPerCol;
}
function valToString(val, pad, dtype) {
    let valStr;
    if (Array.isArray(val)) {
        valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ` +
            `${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`;
    }
    else if (isString(val)) {
        valStr = `'${val}'`;
    }
    else if (dtype === 'bool') {
        valStr = boolNumToString(val);
    }
    else {
        valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();
    }
    return rightPad(valStr, pad);
}
function boolNumToString(v) {
    return v === 0 ? 'false' : 'true';
}
function subTensorToString(vals, shape, dtype, strides, padPerCol, isLast = true) {
    const storagePerElement = dtype === 'complex64' ? 2 : 1;
    const size = shape[0];
    const rank = shape.length;
    if (rank === 0) {
        if (dtype === 'complex64') {
            const complexTuple = createComplexTuples(vals);
            return [valToString(complexTuple[0], 0, dtype)];
        }
        if (dtype === 'bool') {
            return [boolNumToString(vals[0])];
        }
        return [vals[0].toString()];
    }
    if (rank === 1) {
        if (size > FORMAT_LIMIT_NUM_VALS) {
            const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;
            let firstVals = Array.from(vals.slice(0, firstValsSize));
            let lastVals = Array.from(vals.slice((size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size * storagePerElement));
            if (dtype === 'complex64') {
                firstVals = createComplexTuples(firstVals);
                lastVals = createComplexTuples(lastVals);
            }
            return [
                '[' +
                    firstVals.map((x, i) => valToString(x, padPerCol[i], dtype))
                        .join(', ') +
                    ', ..., ' +
                    lastVals
                        .map((x, i) => valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype))
                        .join(', ') +
                    ']'
            ];
        }
        const displayVals = dtype === 'complex64' ? createComplexTuples(vals) :
            Array.from(vals);
        return [
            '[' +
                displayVals.map((x, i) => valToString(x, padPerCol[i], dtype))
                    .join(', ') +
                ']'
        ];
    }
    // The array is rank 2 or more.
    const subshape = shape.slice(1);
    const substrides = strides.slice(1);
    const stride = strides[0] * storagePerElement;
    const lines = [];
    if (size > FORMAT_LIMIT_NUM_VALS) {
        for (let i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {
            const start = i * stride;
            const end = start + stride;
            lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false /* isLast */));
        }
        lines.push('...');
        for (let i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {
            const start = i * stride;
            const end = start + stride;
            lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1 /* isLast */));
        }
    }
    else {
        for (let i = 0; i < size; i++) {
            const start = i * stride;
            const end = start + stride;
            lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1 /* isLast */));
        }
    }
    const sep = rank === 2 ? ',' : '';
    lines[0] = '[' + lines[0] + sep;
    for (let i = 1; i < lines.length - 1; i++) {
        lines[i] = ' ' + lines[i] + sep;
    }
    let newLineSep = ',\n';
    for (let i = 2; i < rank; i++) {
        newLineSep += '\n';
    }
    lines[lines.length - 1] =
        ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);
    return lines;
}
function createComplexTuples(vals) {
    const complexTuples = [];
    for (let i = 0; i < vals.length; i += 2) {
        complexTuples.push([vals[i], vals[i + 1]]);
    }
    return complexTuples;
}

/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * A mutable object, similar to `tf.Tensor`, that allows users to set values
 * at locations before converting to an immutable `tf.Tensor`.
 *
 * See `tf.buffer` for creating a tensor buffer.
 *
 * @doc {heading: 'Tensors', subheading: 'Classes'}
 */
class TensorBuffer {
    constructor(shape, dtype, values) {
        this.dtype = dtype;
        this.shape = shape.slice();
        this.size = sizeFromShape(shape);
        if (values != null) {
            const n = values.length;
            assert(n === this.size, () => `Length of values '${n}' does not match the size ` +
                `inferred by the shape '${this.size}'.`);
        }
        if (dtype === 'complex64') {
            throw new Error(`complex64 dtype TensorBuffers are not supported. Please create ` +
                `a TensorBuffer for the real and imaginary parts separately and ` +
                `call tf.complex(real, imag).`);
        }
        this.values = values || getArrayFromDType(dtype, this.size);
        this.strides = computeStrides(shape);
    }
    /**
     * Sets a value in the buffer at a given location.
     *
     * @param value The value to set.
     * @param locs  The location indices.
     *
     * @doc {heading: 'Tensors', subheading: 'Creation'}
     */
    set(value, ...locs) {
        if (locs.length === 0) {
            locs = [0];
        }
        assert(locs.length === this.rank, () => `The number of provided coordinates (${locs.length}) must ` +
            `match the rank (${this.rank})`);
        const index = this.locToIndex(locs);
        this.values[index] = value;
    }
    /**
     * Returns the value in the buffer at the provided location.
     *
     * @param locs The location indices.
     *
     * @doc {heading: 'Tensors', subheading: 'Creation'}
     */
    get(...locs) {
        if (locs.length === 0) {
            locs = [0];
        }
        let i = 0;
        for (const loc of locs) {
            if (loc < 0 || loc >= this.shape[i]) {
                const msg = `Requested out of range element at ${locs}. ` +
                    `  Buffer shape=${this.shape}`;
                throw new Error(msg);
            }
            i++;
        }
        let index = locs[locs.length - 1];
        for (let i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return this.values[index];
    }
    locToIndex(locs) {
        if (this.rank === 0) {
            return 0;
        }
        else if (this.rank === 1) {
            return locs[0];
        }
        let index = locs[locs.length - 1];
        for (let i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return index;
    }
    indexToLoc(index) {
        if (this.rank === 0) {
            return [];
        }
        else if (this.rank === 1) {
            return [index];
        }
        const locs = new Array(this.shape.length);
        for (let i = 0; i < locs.length - 1; ++i) {
            locs[i] = Math.floor(index / this.strides[i]);
            index -= locs[i] * this.strides[i];
        }
        locs[locs.length - 1] = index;
        return locs;
    }
    get rank() {
        return this.shape.length;
    }
    /**
     * Creates an immutable `tf.Tensor` object from the buffer.
     *
     * @doc {heading: 'Tensors', subheading: 'Creation'}
     */
    toTensor() {
        return trackerFn().makeTensor(this.values, this.shape, this.dtype);
    }
}
// For tracking tensor creation and disposal.
let trackerFn = null;
// Used by chaining methods to call into ops.
let opHandler = null;
/**
 * An external consumer can register itself as the tensor tracker. This way
 * the Tensor class can notify the tracker for every tensor created and
 * disposed.
 */
function setTensorTracker(fn) {
    trackerFn = fn;
}
/**
 * A `tf.Tensor` object represents an immutable, multidimensional array of
 * numbers that has a shape and a data type.
 *
 * For performance reasons, functions that create tensors do not necessarily
 * perform a copy of the data passed to them (e.g. if the data is passed as a
 * `Float32Array`), and changes to the data will change the tensor. This is not
 * a feature and is not supported. To avoid this behavior, use the tensor before
 * changing the input data or create a copy with `copy = tf.add(yourTensor, 0)`.
 *
 * See `tf.tensor` for details on how to create a `tf.Tensor`.
 *
 * @doc {heading: 'Tensors', subheading: 'Classes'}
 */
class Tensor {
    constructor(shape, dtype, dataId, id) {
        /** Whether this tensor has been globally kept. */
        this.kept = false;
        this.isDisposedInternal = false;
        this.shape = shape.slice();
        this.dtype = dtype || 'float32';
        this.size = sizeFromShape(shape);
        this.strides = computeStrides(shape);
        this.dataId = dataId;
        this.id = id;
        this.rankType = (this.rank < 5 ? this.rank.toString() : 'higher');
    }
    get rank() {
        return this.shape.length;
    }
    /**
     * Returns a promise of `tf.TensorBuffer` that holds the underlying data.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    async buffer() {
        const vals = await this.data();
        return opHandler.buffer(this.shape, this.dtype, vals);
    }
    /**
     * Returns a `tf.TensorBuffer` that holds the underlying data.
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    bufferSync() {
        return opHandler.buffer(this.shape, this.dtype, this.dataSync());
    }
    /**
     * Returns the tensor data as a nested array. The transfer of data is done
     * asynchronously.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    async array() {
        const vals = await this.data();
        return toNestedArray(this.shape, vals, this.dtype === 'complex64');
    }
    /**
     * Returns the tensor data as a nested array. The transfer of data is done
     * synchronously.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    arraySync() {
        return toNestedArray(this.shape, this.dataSync(), this.dtype === 'complex64');
    }
    /**
     * Asynchronously downloads the values from the `tf.Tensor`. Returns a
     * promise of `TypedArray` that resolves when the computation has finished.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    async data() {
        this.throwIfDisposed();
        const data = trackerFn().read(this.dataId);
        if (this.dtype === 'string') {
            const bytes = await data;
            try {
                return bytes.map(b => decodeString(b));
            }
            catch (_a) {
                throw new Error('Failed to decode the string bytes into utf-8. ' +
                    'To get the original bytes, call tensor.bytes().');
            }
        }
        return data;
    }
    /**
     * Copy the tensor's data to a new GPU resource. Comparing to the `dataSync()`
     * and `data()`, this method prevents data from being downloaded to CPU.
     *
     * For WebGL backend, the data will be stored on a densely packed texture.
     * This means that the texture will use the RGBA channels to store value.
     *
     * For WebGPU backend, the data will be stored on a buffer. There is no
     * parameter, so can not use a user-defined size to create the buffer.
     *
     * @param options:
     *     For WebGL,
     *         - customTexShape: Optional. If set, will use the user defined
     *     texture shape to create the texture.
     *
     * @returns For WebGL backend, a GPUData contains the new texture and
     *     its information.
     *     {
     *        tensorRef: The tensor that is associated with this texture,
     *        texture: WebGLTexture,
     *        texShape: [number, number] // [height, width]
     *     }
     *
     *     For WebGPU backend, a GPUData contains the new buffer and
     *     its information.
     *     {
     *        tensorRef: The tensor that is associated with this buffer,
     *        buffer: GPUBuffer,
     *        bufSize: number
     *     }
     *
     *     Remember to dispose the GPUData after it is used by
     *     `res.tensorRef.dispose()`.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    dataToGPU(options) {
        this.throwIfDisposed();
        return trackerFn().readToGPU(this.dataId, options);
    }
    /**
     * Synchronously downloads the values from the `tf.Tensor`. This blocks the
     * UI thread until the values are ready, which can cause performance issues.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    dataSync() {
        this.throwIfDisposed();
        const data = trackerFn().readSync(this.dataId);
        if (this.dtype === 'string') {
            try {
                return data.map(b => decodeString(b));
            }
            catch (_a) {
                throw new Error('Failed to decode the string bytes into utf-8. ' +
                    'To get the original bytes, call tensor.bytes().');
            }
        }
        return data;
    }
    /** Returns the underlying bytes of the tensor's data. */
    async bytes() {
        this.throwIfDisposed();
        const data = await trackerFn().read(this.dataId);
        if (this.dtype === 'string') {
            return data;
        }
        else {
            return new Uint8Array(data.buffer);
        }
    }
    /**
     * Disposes `tf.Tensor` from memory.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        trackerFn().disposeTensor(this);
        this.isDisposedInternal = true;
    }
    get isDisposed() {
        return this.isDisposedInternal;
    }
    throwIfDisposed() {
        if (this.isDisposed) {
            throw new Error(`Tensor is disposed.`);
        }
    }
    /**
     * Prints the `tf.Tensor`. See `tf.print` for details.
     *
     * @param verbose Whether to print verbose information about the tensor,
     *    including dtype and size.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    print(verbose = false) {
        return opHandler.print(this, verbose);
    }
    /**
     * Returns a copy of the tensor. See `tf.clone` for details.
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    clone() {
        this.throwIfDisposed();
        return opHandler.clone(this);
    }
    /**
     * Returns a human-readable description of the tensor. Useful for logging.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    toString(verbose = false) {
        const vals = this.dataSync();
        return tensorToString(vals, this.shape, this.dtype, verbose);
    }
    cast(dtype) {
        this.throwIfDisposed();
        return opHandler.cast(this, dtype);
    }
    variable(trainable = true, name, dtype) {
        this.throwIfDisposed();
        return trackerFn().makeVariable(this, trainable, name, dtype);
    }
}
Object.defineProperty(Tensor, Symbol.hasInstance, {
    value: (instance) => {
        // Implementation note: we should use properties of the object that will be
        // defined before the constructor body has finished executing (methods).
        // This is because when this code is transpiled by babel, babel will call
        // classCallCheck before the constructor body is run.
        // See https://github.com/tensorflow/tfjs/issues/3384 for backstory.
        return !!instance && instance.data != null && instance.dataSync != null &&
            instance.throwIfDisposed != null;
    }
});
function getGlobalTensorClass() {
    // Use getGlobal so that we can augment the Tensor class across package
    // boundaries becase the node resolution alg may result in different modules
    // being returned for this file depending on the path they are loaded from.
    return getGlobal('Tensor', () => {
        return Tensor;
    });
}
// Global side effect. Cache global reference to Tensor class
getGlobalTensorClass();
/**
 * A mutable `tf.Tensor`, useful for persisting state, e.g. for training.
 *
 * @doc {heading: 'Tensors', subheading: 'Classes'}
 */
class Variable extends Tensor {
    constructor(initialValue, trainable, name, tensorId) {
        super(initialValue.shape, initialValue.dtype, initialValue.dataId, tensorId);
        this.trainable = trainable;
        this.name = name;
    }
    /**
     * Assign a new `tf.Tensor` to this variable. The new `tf.Tensor` must have
     * the same shape and dtype as the old `tf.Tensor`.
     *
     * @param newValue New tensor to be assigned to this variable.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */
    assign(newValue) {
        if (newValue.dtype !== this.dtype) {
            throw new Error(`dtype of the new value (${newValue.dtype}) and ` +
                `previous value (${this.dtype}) must match`);
        }
        if (!arraysEqual(newValue.shape, this.shape)) {
            throw new Error(`shape of the new value (${newValue.shape}) and ` +
                `previous value (${this.shape}) must match`);
        }
        trackerFn().disposeTensor(this);
        this.dataId = newValue.dataId;
        trackerFn().incRef(this, null /* backend */);
    }
    dispose() {
        trackerFn().disposeVariable(this);
        this.isDisposedInternal = true;
    }
}
Object.defineProperty(Variable, Symbol.hasInstance, {
    value: (instance) => {
        return instance instanceof Tensor && instance.assign != null &&
            instance.assign instanceof Function;
    }
});

/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var Rank;
(function (Rank) {
    Rank["R0"] = "R0";
    Rank["R1"] = "R1";
    Rank["R2"] = "R2";
    Rank["R3"] = "R3";
    Rank["R4"] = "R4";
    Rank["R5"] = "R5";
    Rank["R6"] = "R6";
})(Rank || (Rank = {}));
// Looks for upcasting types. Used, for example, in operations with mixed dtype
// inputs.
var UpcastInt32AndMap;
(function (UpcastInt32AndMap) {
    UpcastInt32AndMap["float32"] = "float32";
    UpcastInt32AndMap["int32"] = "int32";
    UpcastInt32AndMap["bool"] = "int32";
    UpcastInt32AndMap["complex64"] = "complex64";
})(UpcastInt32AndMap || (UpcastInt32AndMap = {}));
var UpcastBoolAndMap;
(function (UpcastBoolAndMap) {
    UpcastBoolAndMap["float32"] = "float32";
    UpcastBoolAndMap["int32"] = "int32";
    UpcastBoolAndMap["bool"] = "bool";
    UpcastBoolAndMap["complex64"] = "complex64";
})(UpcastBoolAndMap || (UpcastBoolAndMap = {}));
var UpcastFloat32AndMap;
(function (UpcastFloat32AndMap) {
    UpcastFloat32AndMap["float32"] = "float32";
    UpcastFloat32AndMap["int32"] = "float32";
    UpcastFloat32AndMap["bool"] = "float32";
    UpcastFloat32AndMap["complex64"] = "complex64";
})(UpcastFloat32AndMap || (UpcastFloat32AndMap = {}));
var UpcastComplex64AndMap;
(function (UpcastComplex64AndMap) {
    UpcastComplex64AndMap["float32"] = "complex64";
    UpcastComplex64AndMap["int32"] = "complex64";
    UpcastComplex64AndMap["bool"] = "complex64";
    UpcastComplex64AndMap["complex64"] = "complex64";
})(UpcastComplex64AndMap || (UpcastComplex64AndMap = {}));
const upcastTypeMap = {
    'float32': UpcastFloat32AndMap,
    'int32': UpcastInt32AndMap,
    'bool': UpcastBoolAndMap,
    'complex64': UpcastComplex64AndMap
};
function upcastType(typeA, typeB) {
    if (typeA === 'string' || typeB === 'string') {
        if (typeA === 'string' && typeB === 'string') {
            return 'string';
        }
        throw new Error(`Can not upcast ${typeA} with ${typeB}`);
    }
    return upcastTypeMap[typeA][typeB];
}

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function makeTypesMatch(a, b) {
    if (a.dtype === b.dtype) {
        return [a, b];
    }
    const dtype = upcastType(a.dtype, b.dtype);
    return [a.cast(dtype), b.cast(dtype)];
}
function assertTypesMatch(a, b) {
    assert(a.dtype === b.dtype, () => `The dtypes of the first(${a.dtype}) and` +
        ` second(${b.dtype}) input must match`);
}
/**
 * Extracts any `Tensor`s found within the provided object.
 *
 * @param container an object that may be a `Tensor` or may directly contain
 *   `Tensor`s, such as a `Tensor[]` or `{key: Tensor, ...}`. In general it
 *   is safe to pass any object here, except that `Promise`s are not
 *   supported.
 * @returns An array of `Tensors` found within the passed object. If the
 *   argument is simply a `Tensor', a list containing that `Tensor` is
 *   returned. If the object is not a `Tensor` or does not
 *   contain `Tensors`, an empty list is returned.
 */
function getTensorsInContainer(result) {
    const list = [];
    const seen = new Set();
    walkTensorContainer(result, list, seen);
    return list;
}
function walkTensorContainer(container, list, seen) {
    if (container == null) {
        return;
    }
    if (container instanceof Tensor) {
        list.push(container);
        return;
    }
    if (!isIterable(container)) {
        return;
    }
    // Iteration over keys works also for arrays.
    const iterable = container;
    for (const k in iterable) {
        const val = iterable[k];
        if (!seen.has(val)) {
            seen.add(val);
            walkTensorContainer(val, list, seen);
        }
    }
}
// tslint:disable-next-line:no-any
function isIterable(obj) {
    return Array.isArray(obj) || typeof obj === 'object';
}

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function isRegisteredKernelInvocation(kernelInvocation) {
    return kernelInvocation.kernelName != null;
}
class EngineState {
    constructor() {
        // Public since optimizers will use it.
        this.registeredVariables = {};
        this.nextTapeNodeId = 0;
        this.numBytes = 0;
        this.numTensors = 0;
        this.numStringTensors = 0;
        this.numDataBuffers = 0;
        // Number of nested tf.grad() statements when computing higher-order
        // gradients. E.g. `1` for first-order gradients and `2` for second-order
        // gradients. Used to track if the tape should be removed after a backprop.
        this.gradientDepth = 0;
        // Number of nested kernel calls. When kernel depth is greater than 1, we turn
        // off the tape.
        this.kernelDepth = 0;
        this.scopeStack = [];
        /**
         * Keeps track of the number of data moves during a kernel execution. We
         * maintain a stack since kernels can call other kernels, recursively.
         */
        this.numDataMovesStack = [];
        this.nextScopeId = 0;
        this.tensorInfo = new WeakMap();
        this.profiling = false;
        this.activeProfile = {
            newBytes: 0,
            newTensors: 0,
            peakBytes: 0,
            kernels: [],
            result: null,
            get kernelNames() {
                return Array.from(new Set(this.kernels.map(k => k.name)));
            }
        };
    }
    dispose() {
        for (const variableName in this.registeredVariables) {
            this.registeredVariables[variableName].dispose();
        }
    }
}
class Engine {
    constructor(ENV) {
        this.ENV = ENV;
        this.registry = {};
        this.registryFactory = {};
        this.pendingBackendInitId = 0;
        this.state = new EngineState();
    }
    async ready() {
        if (this.pendingBackendInit != null) {
            return this.pendingBackendInit.then(() => { });
        }
        if (this.backendInstance != null) {
            return;
        }
        const sortedBackends = this.getSortedBackends();
        for (let i = 0; i < sortedBackends.length; i++) {
            const backendName = sortedBackends[i];
            const success = await this.initializeBackend(backendName).success;
            if (success) {
                await this.setBackend(backendName);
                return;
            }
        }
        throw new Error(`Could not initialize any backends, all backend initializations ` +
            `failed.`);
    }
    get backend() {
        if (this.pendingBackendInit != null) {
            throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make ` +
                `sure to await tf.ready() or await tf.setBackend() before calling ` +
                `other methods`);
        }
        if (this.backendInstance == null) {
            const { name, asyncInit } = this.initializeBackendsAndReturnBest();
            if (asyncInit) {
                throw new Error(`The highest priority backend '${name}' has not yet been ` +
                    `initialized. Make sure to await tf.ready() or ` +
                    `await tf.setBackend() before calling other methods`);
            }
            this.setBackend(name);
        }
        return this.backendInstance;
    }
    backendNames() {
        return Object.keys(this.registryFactory);
    }
    findBackend(backendName) {
        if (!(backendName in this.registry)) {
            // If the backend hasn't been initialized but we have a registry entry for
            // it, initialize it and return it.
            if (backendName in this.registryFactory) {
                const { asyncInit } = this.initializeBackend(backendName);
                if (asyncInit) {
                    // Backend is not ready yet.
                    return null;
                }
            }
            else {
                return null;
            }
        }
        return this.registry[backendName];
    }
    findBackendFactory(backendName) {
        if (!(backendName in this.registryFactory)) {
            return null;
        }
        return this.registryFactory[backendName].factory;
    }
    registerBackend(backendName, factory, priority = 1) {
        if (backendName in this.registryFactory) {
            warn(`${backendName} backend was already registered. ` +
                `Reusing existing backend factory.`);
            return false;
        }
        this.registryFactory[backendName] = { factory, priority };
        return true;
    }
    async setBackend(backendName) {
        if (this.registryFactory[backendName] == null) {
            throw new Error(`Backend name '${backendName}' not found in registry`);
        }
        this.backendName = backendName;
        if (this.registry[backendName] == null) {
            this.backendInstance = null;
            const { success, asyncInit } = this.initializeBackend(backendName);
            const result = asyncInit ? await success : success;
            if (!result) {
                return false;
            }
        }
        this.backendInstance = this.registry[backendName];
        this.setupRegisteredKernels();
        // Reset the profiler.
        this.profiler = new Profiler(this.backendInstance);
        return true;
    }
    setupRegisteredKernels() {
        const kernels = getKernelsForBackend(this.backendName);
        kernels.forEach(kernel => {
            if (kernel.setupFunc != null) {
                kernel.setupFunc(this.backendInstance);
            }
        });
    }
    disposeRegisteredKernels(backendName) {
        const kernels = getKernelsForBackend(backendName);
        kernels.forEach(kernel => {
            if (kernel.disposeFunc != null) {
                kernel.disposeFunc(this.registry[backendName]);
            }
        });
    }
    /**
     * Initializes a backend by looking up the backend name in the factory
     * registry and calling the factory method. Returns a boolean representing
     * whether the initialization of the backend suceeded. Throws an error if
     * there is no backend in the factory registry.
     */
    initializeBackend(backendName) {
        const registryFactoryEntry = this.registryFactory[backendName];
        if (registryFactoryEntry == null) {
            throw new Error(`Cannot initialize backend ${backendName}, no registration found.`);
        }
        try {
            const backend = registryFactoryEntry.factory();
            /* Test if the factory returns a promise.
            Done in a more liberal way than
            previous 'Promise.resolve(backend)===backend'
            as we needed to account for custom Promise
            implementations (e.g. Angular) */
            if (backend && !(backend instanceof KernelBackend) &&
                typeof backend.then === 'function') {
                const promiseId = ++this.pendingBackendInitId;
                const success = backend
                    .then(backendInstance => {
                    // Outdated promise. Another backend was set in the meantime.
                    if (promiseId < this.pendingBackendInitId) {
                        return false;
                    }
                    this.registry[backendName] = backendInstance;
                    this.pendingBackendInit = null;
                    return true;
                })
                    .catch(err => {
                    // Outdated promise. Another backend was set in the meantime.
                    if (promiseId < this.pendingBackendInitId) {
                        return false;
                    }
                    this.pendingBackendInit = null;
                    warn(`Initialization of backend ${backendName} failed`);
                    warn(err.stack || err.message);
                    return false;
                });
                this.pendingBackendInit = success;
                return { success, asyncInit: true };
            }
            else {
                this.registry[backendName] = backend;
                return { success: true, asyncInit: false };
            }
        }
        catch (err) {
            warn(`Initialization of backend ${backendName} failed`);
            warn(err.stack || err.message);
            return { success: false, asyncInit: false };
        }
    }
    removeBackend(backendName) {
        if (!(backendName in this.registryFactory)) {
            throw new Error(`${backendName} backend not found in registry`);
        }
        if (this.backendName === backendName && this.pendingBackendInit != null) {
            // There is a pending promise of the backend we want to remove. Make it
            // obsolete.
            this.pendingBackendInitId++;
        }
        if (backendName in this.registry) {
            this.disposeRegisteredKernels(backendName);
            this.registry[backendName].dispose();
            delete this.registry[backendName];
        }
        delete this.registryFactory[backendName];
        // Unset the backend if it is active.
        if (this.backendName === backendName) {
            this.pendingBackendInit = null;
            this.backendName = null;
            this.backendInstance = null;
        }
    }
    getSortedBackends() {
        if (Object.keys(this.registryFactory).length === 0) {
            throw new Error('No backend found in registry.');
        }
        return Object.keys(this.registryFactory).sort((a, b) => {
            // Highest priority comes first.
            return this.registryFactory[b].priority -
                this.registryFactory[a].priority;
        });
    }
    initializeBackendsAndReturnBest() {
        const sortedBackends = this.getSortedBackends();
        for (let i = 0; i < sortedBackends.length; i++) {
            const backendName = sortedBackends[i];
            const { success, asyncInit } = this.initializeBackend(backendName);
            if (asyncInit || success) {
                return { name: backendName, asyncInit };
            }
        }
        throw new Error(`Could not initialize any backends, all backend initializations ` +
            `failed.`);
    }
    moveData(backend, dataId) {
        const info = this.state.tensorInfo.get(dataId);
        const srcBackend = info.backend;
        const values = this.readSync(dataId);
        const refCount = srcBackend.refCount(dataId);
        // Delete the tensor from the old backend and move it to the new
        // backend.
        srcBackend.disposeData(dataId, true);
        info.backend = backend;
        backend.move(dataId, values, info.shape, info.dtype, refCount);
        if (this.shouldCheckForMemLeaks()) {
            // Track the number of moves during a kernel execution to correctly
            // detect memory leaks.
            this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
        }
    }
    tidy(nameOrFn, fn) {
        let name = null;
        if (fn == null) {
            // Called with only 1 argument.
            if (typeof nameOrFn !== 'function') {
                throw new Error('Please provide a function to tidy()');
            }
            fn = nameOrFn;
        }
        else {
            // Called with 2 arguments.
            if (typeof nameOrFn !== 'string' && !(nameOrFn instanceof String)) {
                throw new Error('When calling with two arguments, the first argument ' +
                    'to tidy() must be a string');
            }
            if (typeof fn !== 'function') {
                throw new Error('When calling with two arguments, the 2nd argument ' +
                    'to tidy() must be a function');
            }
            name = nameOrFn;
            // TODO(nsthorat,smilkov): Do operation logging and performance
            // profiling.
        }
        let result;
        return this.scopedRun(() => this.startScope(name), () => this.endScope(result), () => {
            result = fn();
            if (result instanceof Promise) {
                console.error('Cannot return a Promise inside of tidy.');
            }
            return result;
        });
    }
    scopedRun(start, end, f) {
        start();
        try {
            const res = f();
            end();
            return res;
        }
        catch (ex) {
            end();
            throw ex;
        }
    }
    nextTensorId() {
        return Engine.nextTensorId++;
    }
    nextVariableId() {
        return Engine.nextVariableId++;
    }
    /**
     * This method is called instead of the public-facing tensor.clone() when
     * saving a tensor for backwards pass. It makes sure to add the clone
     * operation to the tape regardless of being called inside a kernel
     * execution.
     */
    clone(x) {
        const y = ENGINE.runKernel(Identity, { x });
        const inputs = { x };
        const grad = (dy) => ({
            x: () => {
                const dtype = 'float32';
                const gradInputs = { x: dy };
                const attrs = { dtype };
                return ENGINE.runKernel(Cast, gradInputs, 
                // tslint:disable-next-line: no-unnecessary-type-assertion
                attrs);
            }
        });
        const saved = [];
        this.addTapeNode(this.state.activeScope.name, inputs, [y], grad, saved, {});
        return y;
    }
    /**
     * Execute a kernel with the given name and return the output tensor.
     *
     * @param kernelName The name of the kernel to execute.
     * @param inputs A map of input names to tensors.
     * @param attrs A map of attribute names to their values. An attribute is a
     *     primitive (non-tensor) input to the kernel.
     * @param inputsToSave A list of tensors, inputs to save for the backprop
     *     computation.
     * @param outputsToSave A list of booleans, specifying which output to save
     *     for the backprop computation. These are booleans since the output
     * tensors are not visible to the user.
     */
    runKernel(kernelName, inputs, attrs) {
        if (this.backendName == null) {
            // backend has not been initialized yet (backend initialization is lazy
            // can be deferred until an op/ kernel is run).
            // The below getter has side effects that will try to initialize the
            // backend and set properties like this.backendName
            // tslint:disable-next-line: no-unused-expression
            this.backend;
        }
        const hasKernel = getKernel(kernelName, this.backendName) != null;
        if (!hasKernel) {
            throw new Error(`Kernel '${kernelName}' not registered for backend '${this.backendName}'`);
        }
        return this.runKernelFunc({ kernelName, inputs, attrs });
    }
    shouldCheckForMemLeaks() {
        return this.ENV.getBool('IS_TEST');
    }
    checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos) {
        const numDataIdsAfter = this.backend.numDataIds();
        // Count the number of data ids associated with the result of the kernel.
        let numOutputDataIds = 0;
        outInfos.forEach(info => {
            // Complex numbers allocate 3 data ids, one for 'real', one for
            // 'imaginary', and one for the container that holds the former two.
            numOutputDataIds += (info.dtype === 'complex64' ? 3 : 1);
        });
        // Account for the number of moves during kernel execution. A "data move"
        // can happen in the middle of a kernel execution, placing a new (key,value)
        // pair in the data storage. Since data moves have net zero effect (we
        // always remove the data from the old backend), we have to cancel them out
        // when detecting memory leaks.
        const numMoves = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1];
        const dataIdsLeaked = numDataIdsAfter - numDataIdsBefore - numOutputDataIds - numMoves;
        if (dataIdsLeaked > 0) {
            throw new Error(`Backend '${this.backendName}' has an internal memory leak ` +
                `(${dataIdsLeaked} data ids) after running '${kernelName}'`);
        }
    }
    /**
     * Internal helper method to execute a kernel Func
     *
     * Use `runKernel` to execute kernels from outside of engine.
     */
    runKernelFunc(kernelParams) {
        let outputs;
        let saved = [];
        const isTapeOn = this.isTapeOn();
        const startingBytecount = this.state.numBytes;
        const startingNumTensors = this.state.numTensors;
        if (this.shouldCheckForMemLeaks()) {
            this.state.numDataMovesStack.push(0);
        }
        let kernelFunc;
        if (this.backendName == null) {
            // backend has not been initialized yet (backend initialization is lazy
            // can be deferred until an op/ kernel is run).
            // The below getter has side effects that will try to initialize the
            // backend and set properties like this.backendName
            // tslint:disable-next-line: no-unused-expression
            this.backend;
        }
        let out;
        const kernelOrScopeName = isRegisteredKernelInvocation(kernelParams) ?
            kernelParams.kernelName :
            this.state.activeScope != null ? this.state.activeScope.name : '';
        // Create the kernelFunc from either a registered kernel OR passed in
        // forward/backward functions (used by custom grad). In this context a
        // kernelFunc wraps a kernel implementation with some bookkeeping.
        if (isRegisteredKernelInvocation(kernelParams)) {
            const { kernelName, inputs, attrs } = kernelParams;
            if (this.backendName == null) {
                // backend has not been initialized yet (backend initialization is lazy
                // can be deferred until an op/ kernel is run).
                // The below getter has side effects that will try to initialize the
                // backend and set properties like this.backendName
                // tslint:disable-next-line: no-unused-expression
                this.backend;
            }
            const kernel = getKernel(kernelName, this.backendName);
            assert(kernel != null, () => `Cannot find registered kernel '${kernelName}' for backend '${this.backendName}'`);
            kernelFunc = () => {
                const numDataIdsBefore = this.backend.numDataIds();
                out = kernel.kernelFunc({ inputs, attrs, backend: this.backend });
                const outInfos = Array.isArray(out) ? out : [out];
                if (this.shouldCheckForMemLeaks()) {
                    this.checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos);
                }
                const outTensors = outInfos.map((outInfo) => {
                    // todo (yassogba) remove this option (Tensor) when node backend
                    // methods have been modularized and they all return tensorInfo.
                    // TensorInfos do not have a rank attribute.
                    if (outInfo.rank != null) {
                        return outInfo;
                    }
                    return this.makeTensorFromTensorInfo(outInfo);
                });
                // Save any required inputs and outputs.
                // Do not save unless we are recording to the tape. Otherwise it would
                // cause a mem leak since there would be no backprop for these tensors
                // (which would otherwise dispose them).
                if (isTapeOn) {
                    const tensorsToSave = this.getTensorsForGradient(kernelName, inputs, outTensors);
                    saved = this.saveTensorsForBackwardMode(tensorsToSave);
                }
                return outTensors;
            };
        }
        else {
            const { forwardFunc } = kernelParams;
            // Running a customGrad op.
            const saveFunc = (tensors) => {
                // Do not save unless we are recording to the tape. Otherwise it would
                // cause a mem leak since we would never run backprop, which disposes
                // the kept tensors.
                if (!isTapeOn) {
                    return;
                }
                saved = tensors.map(tensor => this.keep(this.clone(tensor)));
            };
            kernelFunc = () => {
                const numDataIdsBefore = this.backend.numDataIds();
                out = this.tidy(() => forwardFunc(this.backend, saveFunc));
                const outs = (Array.isArray(out) ? out : [out]);
                if (this.shouldCheckForMemLeaks()) {
                    // Scope name is used to print a more helpful error message if needed.
                    this.checkKernelForMemLeak(kernelOrScopeName, numDataIdsBefore, outs);
                }
                return outs;
            };
        }
        //
        // Run the kernelFunc. Optionally profiling it.
        //
        const { inputs, attrs } = kernelParams;
        const backwardsFunc = isRegisteredKernelInvocation(kernelParams) ?
            null :
            kernelParams.backwardsFunc;
        let kernelProfile;
        this.scopedRun(
        // Stop recording to a tape when running a kernel.
        () => this.state.kernelDepth++, () => this.state.kernelDepth--, () => {
            if (!this.ENV.getBool('DEBUG') && !this.state.profiling) {
                outputs = kernelFunc();
            }
            else {
                kernelProfile = this.profiler.profileKernel(kernelOrScopeName, inputs, () => kernelFunc());
                if (this.ENV.getBool('DEBUG')) {
                    this.profiler.logKernelProfile(kernelProfile);
                }
                outputs = kernelProfile.outputs;
            }
        });
        if (isTapeOn) {
            this.addTapeNode(kernelOrScopeName, inputs, outputs, backwardsFunc, saved, attrs);
        }
        if (this.state.profiling) {
            this.state.activeProfile.kernels.push({
                name: kernelOrScopeName,
                bytesAdded: this.state.numBytes - startingBytecount,
                totalBytesSnapshot: this.state.numBytes,
                tensorsAdded: this.state.numTensors - startingNumTensors,
                totalTensorsSnapshot: this.state.numTensors,
                inputShapes: Object.keys(inputs).map(key => inputs[key] != null ? inputs[key].shape : null),
                outputShapes: outputs.map(item => item.shape),
                kernelTimeMs: kernelProfile.timeMs,
                extraInfo: kernelProfile.extraInfo
            });
        }
        return (Array.isArray(out) ? outputs : outputs[0]);
    }
    /**
     * Saves tensors used in forward mode for use in backward mode.
     *
     * @param tensors the list of tensors to save.
     */
    saveTensorsForBackwardMode(tensors) {
        const saved = tensors.map(tensor => this.keep(this.clone(tensor)));
        return saved;
    }
    /**
     * Returns a list of tensors to save for a given gradient calculation.
     *
     * @param kernelName name of kernel to look up gradient for.
     * @param inputs a map of input tensors.
     * @param outputs an array of output tensors from forward mode of kernel.
     */
    getTensorsForGradient(kernelName, inputs, outputs) {
        const gradConfig = getGradient(kernelName);
        if (gradConfig != null) {
            const inputsToSave = gradConfig.inputsToSave || [];
            const outputsToSave = gradConfig.outputsToSave || [];
            // If saveAllInputs is true, all inputs will be saved. Otherwise, inputs
            // specified in inputsToSave will be saved.
            let inputTensorsToSave;
            if (gradConfig.saveAllInputs) {
                assert(Array.isArray(inputs), () => 'saveAllInputs is true, expected inputs to be an array.');
                inputTensorsToSave = Object.keys(inputs).map((key) => inputs[key]);
            }
            else {
                inputTensorsToSave = inputsToSave.map((inputName) => inputs[inputName]);
            }
            const outputTensorsToSave = outputs.filter((_, i) => outputsToSave[i]);
            return inputTensorsToSave.concat(outputTensorsToSave);
        }
        // We return an empty list rather than throw an error because the kernel we
        // are looking up may not actually be relevant to backproping through the
        // overall function
        //
        // See 'does not error if irrelevant (pruned) ops are missing grads' test
        // in gradients_test.ts for an example.
        return [];
    }
    /**
     * Internal method used by public APIs for tensor creation. Makes a new
     * tensor with the provided shape, dtype and values. It always
     * creates a new data id and writes the values to the underlying backend.
     */
    makeTensor(values, shape, dtype, backend) {
        if (values == null) {
            throw new Error('Values passed to engine.makeTensor() are null');
        }
        dtype = dtype || 'float32';
        backend = backend || this.backend;
        let backendVals = values;
        if (dtype === 'string' && isString(values[0])) {
            backendVals = values.map(d => encodeString(d));
        }
        const dataId = backend.write(backendVals, shape, dtype);
        const t = new Tensor(shape, dtype, dataId, this.nextTensorId());
        this.trackTensor(t, backend);
        // Count bytes for string tensors.
        if (dtype === 'string') {
            const info = this.state.tensorInfo.get(dataId);
            const newBytes = bytesFromStringArray(backendVals);
            this.state.numBytes += newBytes - info.bytes;
            info.bytes = newBytes;
        }
        return t;
    }
    /**
     * Internal method used by backends. Makes a new tensor
     * that is a wrapper around an existing data id. It doesn't create
     * a new data id, only increments the ref count used in memory tracking.
     * @deprecated
     */
    makeTensorFromDataId(dataId, shape, dtype, backend) {
        dtype = dtype || 'float32';
        const tensorInfo = { dataId, shape, dtype };
        return this.makeTensorFromTensorInfo(tensorInfo, backend);
    }
    /**
     * Internal method used by backends. Makes a new tensor that is a wrapper
     * around an existing data id in TensorInfo. It doesn't create a new data id,
     * only increments the ref count used in memory tracking.
     */
    makeTensorFromTensorInfo(tensorInfo, backend) {
        const { dataId, shape, dtype } = tensorInfo;
        const t = new Tensor(shape, dtype, dataId, this.nextTensorId());
        this.trackTensor(t, backend);
        return t;
    }
    makeVariable(initialValue, trainable = true, name, dtype) {
        name = name || this.nextVariableId().toString();
        if (dtype != null && dtype !== initialValue.dtype) {
            initialValue = initialValue.cast(dtype);
        }
        const v = new Variable(initialValue, trainable, name, this.nextTensorId());
        if (this.state.registeredVariables[v.name] != null) {
            throw new Error(`Variable with name ${v.name} was already registered`);
        }
        this.state.registeredVariables[v.name] = v;
        this.incRef(v, this.backend);
        return v;
    }
    trackTensor(a, backend) {
        this.state.numTensors++;
        if (a.dtype === 'string') {
            this.state.numStringTensors++;
        }
        // Bytes for complex numbers are counted by their components. Bytes for
        // string tensors are counted when writing values.
        let bytes = 0;
        if (a.dtype !== 'complex64' && a.dtype !== 'string') {
            bytes = a.size * bytesPerElement(a.dtype);
        }
        this.state.numBytes += bytes;
        if (!this.state.tensorInfo.has(a.dataId)) {
            this.state.numDataBuffers++;
            this.state.tensorInfo.set(a.dataId, {
                backend: backend || this.backend,
                dtype: a.dtype,
                shape: a.shape,
                bytes
            });
        }
        if (!(a instanceof Variable)) {
            this.track(a);
        }
    }
    // Track the tensor by dataId and increase the refCount for the dataId in the
    // backend.
    // TODO(pyu10055): This is currently used by makeVariable method, to increase
    // refCount on the backend for the dataId. It can potentially be replaced with
    // Identity op indead of calling backend directly.
    incRef(a, backend) {
        this.trackTensor(a, backend);
        this.backend.incRef(a.dataId);
    }
    removeDataId(dataId, backend) {
        if (this.state.tensorInfo.has(dataId) &&
            this.state.tensorInfo.get(dataId).backend === backend) {
            this.state.tensorInfo.delete(dataId);
            this.state.numDataBuffers--;
        }
    }
    disposeTensor(a) {
        if (!this.state.tensorInfo.has(a.dataId)) {
            return;
        }
        const info = this.state.tensorInfo.get(a.dataId);
        this.state.numTensors--;
        if (a.dtype === 'string') {
            this.state.numStringTensors--;
            this.state.numBytes -= info.bytes;
        }
        // Don't count bytes for complex numbers as they are counted by their
        // components.
        if (a.dtype !== 'complex64' && a.dtype !== 'string') {
            const bytes = a.size * bytesPerElement(a.dtype);
            this.state.numBytes -= bytes;
        }
        // Remove the reference to dataId if backend dispose the data successfully
        if (info.backend.disposeData(a.dataId)) {
            this.removeDataId(a.dataId, info.backend);
        }
        // TODO(nsthorat): Construct an error and save the stack trace for
        // debugging when in debug mode. Creating a stack trace is too expensive
        // to do unconditionally.
    }
    disposeVariables() {
        for (const varName in this.state.registeredVariables) {
            const v = this.state.registeredVariables[varName];
            this.disposeVariable(v);
        }
    }
    disposeVariable(v) {
        this.disposeTensor(v);
        if (this.state.registeredVariables[v.name] != null) {
            delete this.state.registeredVariables[v.name];
        }
    }
    memory() {
        const info = this.backend.memory();
        info.numTensors = this.state.numTensors;
        info.numDataBuffers = this.state.numDataBuffers;
        info.numBytes = this.state.numBytes;
        if (this.state.numStringTensors > 0) {
            info.unreliable = true;
            if (info.reasons == null) {
                info.reasons = [];
            }
            info.reasons.push('Memory usage by string tensors is approximate ' +
                '(2 bytes per character)');
        }
        return info;
    }
    async profile(query) {
        this.state.profiling = true;
        const startBytes = this.state.numBytes;
        const startNumTensors = this.state.numTensors;
        this.state.activeProfile.kernels = [];
        this.state.activeProfile.result = await query();
        this.state.profiling = false;
        this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map(d => d.totalBytesSnapshot));
        this.state.activeProfile.newBytes = this.state.numBytes - startBytes;
        this.state.activeProfile.newTensors =
            this.state.numTensors - startNumTensors;
        for (const kernel of this.state.activeProfile.kernels) {
            kernel.kernelTimeMs = await kernel.kernelTimeMs;
            kernel.extraInfo = await kernel.extraInfo;
        }
        return this.state.activeProfile;
    }
    isTapeOn() {
        return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
    }
    addTapeNode(kernelName, inputs, outputs, gradientsFunc, saved, attrs) {
        const tapeNode = { id: this.state.nextTapeNodeId++, kernelName, inputs, outputs, saved };
        const gradConfig = getGradient(kernelName);
        if (gradConfig != null) {
            gradientsFunc = gradConfig.gradFunc;
        }
        if (gradientsFunc != null) {
            tapeNode.gradient = (dys) => {
                // TODO(smilkov): To optimize back-prop, pass dys that are not used in
                // the backprop graph to the user as null instead of zeros
                dys = dys.map((dy, i) => {
                    if (dy == null) {
                        const output = outputs[i];
                        const vals = makeZerosTypedArray(output.size, output.dtype);
                        return this.makeTensor(vals, output.shape, output.dtype);
                    }
                    return dy;
                });
                // Grad functions of ops with single outputs expect a dy, while ops
                // with multiple outputs expect dys (array of dy).
                return gradientsFunc(dys.length > 1 ? dys : dys[0], saved, attrs);
            };
        }
        this.state.activeTape.push(tapeNode);
    }
    keep(result) {
        result.kept = true;
        return result;
    }
    startTape() {
        if (this.state.gradientDepth === 0) {
            this.state.activeTape = [];
        }
        this.state.gradientDepth++;
    }
    endTape() {
        this.state.gradientDepth--;
    }
    /**
     * Start a scope. Use this with endScope() to achieve the same functionality
     * as scope() without the need for a function closure.
     */
    startScope(name) {
        const scopeInfo = {
            track: [],
            name: 'unnamed scope',
            id: this.state.nextScopeId++
        };
        if (name) {
            scopeInfo.name = name;
        }
        this.state.scopeStack.push(scopeInfo);
        this.state.activeScope = scopeInfo;
    }
    /**
     * End a scope. Use this with startScope() to achieve the same functionality
     * as scope() without the need for a function closure.
     */
    endScope(result) {
        const tensorsToTrackInParent = getTensorsInContainer(result);
        const tensorsToTrackInParentSet = new Set(tensorsToTrackInParent.map(t => t.id));
        // Dispose the arrays tracked in this scope.
        for (let i = 0; i < this.state.activeScope.track.length; i++) {
            const tensor = this.state.activeScope.track[i];
            if (!tensor.kept && !tensorsToTrackInParentSet.has(tensor.id)) {
                tensor.dispose();
            }
        }
        const oldScope = this.state.scopeStack.pop();
        this.state.activeScope = this.state.scopeStack.length === 0 ?
            null :
            this.state.scopeStack[this.state.scopeStack.length - 1];
        // Track the current result in the parent scope.
        tensorsToTrackInParent.forEach(tensor => {
            // Only track the tensor if was allocated in the inner scope and is not
            // globally kept.
            if (!tensor.kept && tensor.scopeId === oldScope.id) {
                this.track(tensor);
            }
        });
    }
    /**
     * Returns gradients of `f` with respect to each of the `xs`. The gradients
     * returned are of the same length as `xs`, but some might be null if `f`
     * was not a function of that `x`. It also takes optional dy to multiply the
     * gradient, which defaults to `1`.
     */
    gradients(f, xs, dy, allowNoGradients = false) {
        assert(xs.length > 0, () => 'gradients() received an empty list of xs.');
        if (dy != null && dy.dtype !== 'float32') {
            throw new Error(`dy must have 'float32' dtype, but has '${dy.dtype}'`);
        }
        const y = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy('forward', f));
        assert(y instanceof Tensor, () => 'The result y returned by f() must be a tensor.');
        // Filter out the nodes that don't connect x => y.
        const filteredTape = getFilteredNodesXToY(this.state.activeTape, xs, y);
        if (!allowNoGradients && filteredTape.length === 0 && xs.length > 0) {
            throw new Error('Cannot compute gradient of y=f(x) with respect to x. Make sure ' +
                'that the f you passed encloses all operations that lead from x ' +
                'to y.');
        }
        return this.tidy('backward', () => {
            const accumulatedGradientMap = {};
            accumulatedGradientMap[y.id] = (dy == null) ? ones$1(y.shape) : dy;
            // Backprop gradients through the filtered nodes.
            backpropagateGradients(accumulatedGradientMap, filteredTape, 
            // Pass the tidy function to avoid circular dep with `tape.ts`.
            f => this.tidy(f), 
            // Pass an add function to avoide a circular dep with `tape.ts`.
            add$1);
            const grads = xs.map(x => accumulatedGradientMap[x.id]);
            if (this.state.gradientDepth === 0) {
                // This means that we are not computing higher-order gradients
                // and can clean up the tape.
                this.state.activeTape.forEach(node => {
                    for (const tensor of node.saved) {
                        tensor.dispose();
                    }
                });
                this.state.activeTape = null;
            }
            return { value: y, grads };
        });
    }
    customGrad(f) {
        assert(isFunction(f), () => 'The f passed in customGrad(f) must be a function.');
        return (...inputs) => {
            assert(inputs.every(t => t instanceof Tensor), () => 'The args passed in customGrad(f)(x1, x2,...) must all be ' +
                'tensors');
            let res;
            const inputMap = {};
            inputs.forEach((input, i) => {
                inputMap[i] = input;
            });
            const forwardFunc = (_, save) => {
                res = f(...[...inputs, save]);
                assert(res.value instanceof Tensor, () => 'The function f passed in customGrad(f) must return an ' +
                    'object where `obj.value` is a tensor');
                assert(isFunction(res.gradFunc), () => 'The function f passed in customGrad(f) must return an ' +
                    'object where `obj.gradFunc` is a function.');
                return res.value;
            };
            const backwardsFunc = (dy, saved) => {
                const gradRes = res.gradFunc(dy, saved);
                const grads = Array.isArray(gradRes) ? gradRes : [gradRes];
                assert(grads.length === inputs.length, () => 'The function f passed in customGrad(f) must return an ' +
                    'object where `obj.gradFunc` is a function that returns ' +
                    'the same number of tensors as inputs passed to f(...).');
                assert(grads.every(t => t instanceof Tensor), () => 'The function f passed in customGrad(f) must return an ' +
                    'object where `obj.gradFunc` is a function that returns ' +
                    'a list of only tensors.');
                const gradMap = {};
                grads.forEach((grad, i) => {
                    gradMap[i] = () => grad;
                });
                return gradMap;
            };
            return this.runKernelFunc({
                forwardFunc,
                backwardsFunc,
                inputs: inputMap,
            });
        };
    }
    readSync(dataId) {
        // Route the read to the correct backend.
        const info = this.state.tensorInfo.get(dataId);
        return info.backend.readSync(dataId);
    }
    read(dataId) {
        // Route the read to the correct backend.
        const info = this.state.tensorInfo.get(dataId);
        return info.backend.read(dataId);
    }
    readToGPU(dataId, options) {
        // Route the read to the correct backend.
        const info = this.state.tensorInfo.get(dataId);
        return info.backend.readToGPU(dataId, options);
    }
    async time(query) {
        const start = now();
        const timingInfo = await this.backend.time(query);
        timingInfo.wallMs = now() - start;
        return timingInfo;
    }
    /**
     * Tracks a Tensor in the current scope to be automatically cleaned up
     * when the current scope ends, and returns the value.
     *
     * @param result The Tensor to track in the current scope.
     */
    track(result) {
        if (this.state.activeScope != null) {
            result.scopeId = this.state.activeScope.id;
            this.state.activeScope.track.push(result);
        }
        return result;
    }
    get registeredVariables() {
        return this.state.registeredVariables;
    }
    /**
     * Resets the engine state. Removes all backends but does not remove
     * registered backend factories.
     */
    reset() {
        // Make any pending promise obsolete.
        this.pendingBackendInitId++;
        this.state.dispose();
        this.ENV.reset();
        this.state = new EngineState();
        for (const backendName in this.registry) {
            this.disposeRegisteredKernels(backendName);
            this.registry[backendName].dispose();
            delete this.registry[backendName];
        }
        this.backendName = null;
        this.backendInstance = null;
        this.pendingBackendInit = null;
    }
}
Engine.nextTensorId = 0;
Engine.nextVariableId = 0;
function ones$1(shape) {
    const values = makeOnesTypedArray(sizeFromShape(shape), 'float32');
    return ENGINE.makeTensor(values, shape, 'float32');
}
function getOrMakeEngine() {
    const ns = getGlobalNamespace();
    if (ns._tfengine == null) {
        const environment = new Environment(ns);
        ns._tfengine = new Engine(environment);
    }
    setEnvironmentGlobal(ns._tfengine.ENV);
    // Tell the current tensor interface that the global engine is responsible
    // for tracking.
    setTensorTracker(() => ns._tfengine);
    return ns._tfengine;
}
const ENGINE = getOrMakeEngine();
/**
 * A implementation of the add op for use within engine and tape.
 *
 * This allows us to avoid a circular dependency between add.ts and engine.
 * It is exported to be available in tape tests.
 */
function add$1(a, b) {
    // We duplicate Add here to avoid a circular dependency with add.ts.
    const inputs = { a, b };
    return ENGINE.runKernel(Add, inputs);
}

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function inferShape(val, dtype) {
    let firstElem = val;
    if (isTypedArray(val)) {
        return dtype === 'string' ? [] : [val.length];
    }
    if (!Array.isArray(val)) {
        return []; // Scalar.
    }
    const shape = [];
    while (Array.isArray(firstElem) ||
        isTypedArray(firstElem) && dtype !== 'string') {
        shape.push(firstElem.length);
        firstElem = firstElem[0];
    }
    if (Array.isArray(val) &&
        env().getBool('TENSORLIKE_CHECK_SHAPE_CONSISTENCY')) {
        deepAssertShapeConsistency(val, shape, []);
    }
    return shape;
}
function deepAssertShapeConsistency(val, shape, indices) {
    indices = indices || [];
    if (!(Array.isArray(val)) && !isTypedArray(val)) {
        assert(shape.length === 0, () => `Element arr[${indices.join('][')}] is a primitive, ` +
            `but should be an array/TypedArray of ${shape[0]} elements`);
        return;
    }
    assert(shape.length > 0, () => `Element arr[${indices.join('][')}] should be a primitive, ` +
        `but is an array of ${val.length} elements`);
    assert(val.length === shape[0], () => `Element arr[${indices.join('][')}] should have ${shape[0]} ` +
        `elements, but has ${val.length} elements`);
    const subShape = shape.slice(1);
    for (let i = 0; i < val.length; ++i) {
        deepAssertShapeConsistency(val[i], subShape, indices.concat(i));
    }
}
function assertDtype(expectedDtype, actualDType, argName, functionName) {
    if (expectedDtype === 'string_or_numeric') {
        return;
    }
    if (expectedDtype == null) {
        throw new Error(`Expected dtype cannot be null.`);
    }
    if (expectedDtype !== 'numeric' && expectedDtype !== actualDType ||
        expectedDtype === 'numeric' && actualDType === 'string') {
        throw new Error(`Argument '${argName}' passed to '${functionName}' must ` +
            `be ${expectedDtype} tensor, but got ${actualDType} tensor`);
    }
}
function convertToTensor(x, argName, functionName, parseAsDtype = 'numeric') {
    if (x instanceof Tensor) {
        assertDtype(parseAsDtype, x.dtype, argName, functionName);
        return x;
    }
    let inferredDtype = inferDtype(x);
    // If the user expects a bool/int/float, use that info to update the
    // inferredDtype when it is not a string.
    if (inferredDtype !== 'string' &&
        ['bool', 'int32', 'float32'].indexOf(parseAsDtype) >= 0) {
        inferredDtype = parseAsDtype;
    }
    assertDtype(parseAsDtype, inferredDtype, argName, functionName);
    if ((x == null) ||
        (!isTypedArray(x) && !Array.isArray(x) && typeof x !== 'number' &&
            typeof x !== 'boolean' && typeof x !== 'string')) {
        const type = x == null ? 'null' : x.constructor.name;
        throw new Error(`Argument '${argName}' passed to '${functionName}' must be a ` +
            `Tensor or TensorLike, but got '${type}'`);
    }
    const inferredShape = inferShape(x, inferredDtype);
    if (!isTypedArray(x) && !Array.isArray(x)) {
        x = [x];
    }
    const skipTypedArray = true;
    const values = inferredDtype !== 'string' ?
        toTypedArray(x, inferredDtype) :
        flatten(x, [], skipTypedArray);
    return ENGINE.makeTensor(values, inferredShape, inferredDtype);
}
function convertToTensorArray(arg, argName, functionName, parseAsDtype = 'numeric') {
    if (!Array.isArray(arg)) {
        throw new Error(`Argument ${argName} passed to ${functionName} must be a ` +
            '`Tensor[]` or `TensorLike[]`');
    }
    const tensors = arg;
    return tensors.map((t, i) => convertToTensor(t, `${argName}[${i}]`, functionName, parseAsDtype));
}

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const OP_SCOPE_SUFFIX = '__op';
/**
 * Used for wrapping functions that perform math operations on
 * Tensors. The function will be wrapped in a named scope that cleans all
 * memory usage after the function is done.
 */
function op(f) {
    const keys = Object.keys(f);
    if (keys.length !== 1) {
        throw new Error(`Please provide an object with a single key ` +
            `(operation name) mapping to a function. Got an object with ` +
            `${keys.length} keys.`);
    }
    let opName = keys[0];
    const fn = f[opName];
    // Strip the underscore from the end of the function name.
    if (opName.endsWith('_')) {
        opName = opName.substring(0, opName.length - 1);
    }
    // add an __op suffix to distinguish ops from kernels in tf.profile
    opName = opName + OP_SCOPE_SUFFIX;
    // tslint:disable-next-line:no-any
    const f2 = (...args) => {
        ENGINE.startScope(opName);
        try {
            const result = fn(...args);
            if (isPromise(result)) {
                console.error('Cannot return a Promise inside of tidy.');
            }
            ENGINE.endScope(result);
            return result;
        }
        catch (ex) {
            ENGINE.endScope(null);
            throw ex;
        }
    };
    Object.defineProperty(f2, 'name', { value: opName, configurable: true });
    // tslint:disable-next-line:no-any
    return f2;
}

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Gather slices from tensor `x`'s axis `axis` according to `indices`.
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3, 4]);
 * const indices = tf.tensor1d([1, 3, 3], 'int32');
 *
 * x.gather(indices).print();
 * ```
 *
 * ```js
 * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);
 * const indices = tf.tensor1d([1, 1, 0], 'int32');
 *
 * x.gather(indices).print();
 * ```
 * @param x The input tensor whose slices are to be gathered.
 * @param indices The indices of the values to extract.
 * @param axis The axis over which to select values. Defaults to 0.
 * @param batchDims Optional. The number of batch dimensions. It must be less
 *     than or equal to rank(indices). Defaults to 0.
 *     The output tensor will have shape of
 *     `x.shape[:axis] + indices.shape[batchDims:] + x.shape[axis + 1:]`
 *
 * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}
 */
function gather_(x, indices, axis = 0, batchDims = 0) {
    const $x = convertToTensor(x, 'x', 'gather');
    const $indices = convertToTensor(indices, 'indices', 'gather', 'int32');
    const inputs = { x: $x, indices: $indices };
    const attrs = { axis, batchDims };
    return ENGINE.runKernel(GatherV2, inputs, attrs);
}
const gather = op({ gather_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
getGlobalTensorClass().prototype.gather = function (indices, axis) {
    this.throwIfDisposed();
    return gather(this, indices, axis);
};

/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns the indices of the maximum values along an `axis`.
 *
 * The result has the same shape as `input` with the dimension along `axis`
 * removed.
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3]);
 *
 * x.argMax().print();  // or tf.argMax(x)
 * ```
 *
 * ```js
 * const x = tf.tensor2d([1, 2, 4, 3], [2, 2]);
 *
 * const axis = 1;
 * x.argMax(axis).print();  // or tf.argMax(x, axis)
 * ```
 *
 * @param x The input tensor.
 * @param axis The dimension to reduce. Defaults to 0 (outer-most dimension).
 *
 * @doc {heading: 'Operations', subheading: 'Reduction'}
 */
function argMax_(x, axis = 0) {
    const $x = convertToTensor(x, 'x', 'argMax');
    const inputs = { x: $x };
    const attrs = { axis };
    return ENGINE.runKernel(ArgMax, inputs, attrs);
}
const argMax = op({ argMax_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
getGlobalTensorClass().prototype.argMax = function (axis) {
    this.throwIfDisposed();
    return argMax(this, axis);
};

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Reshapes a `tf.Tensor` to a given shape.
 *
 * Given an input tensor, returns a new tensor with the same values as the
 * input tensor with shape `shape`.
 *
 * If one component of shape is the special value -1, the size of that
 * dimension is computed so that the total size remains constant. In
 * particular, a shape of [-1] flattens into 1-D. At most one component of
 * shape can be -1.
 *
 * If shape is 1-D or higher, then the operation returns a tensor with shape
 * shape filled with the values of tensor. In this case, the number of
 * elements implied by shape must be the same as the number of elements in
 * tensor.
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3, 4]);
 * x.reshape([2, 2]).print();
 * ```
 *
 * @param x The input tensor to be reshaped.
 * @param shape An array of integers defining the output tensor shape.
 *
 * @doc {heading: 'Tensors', subheading: 'Transformations'}
 */
function reshape_(x, shape) {
    const $x = convertToTensor(x, 'x', 'reshape', 'string_or_numeric');
    const inputs = { x: $x };
    const attrs = { shape };
    return ENGINE.runKernel(Reshape, inputs, attrs);
}
const reshape = op({ reshape_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Removes dimensions of size 1 from the shape of a `tf.Tensor`.
 *
 * ```js
 * const x = tf.tensor([1, 2, 3, 4], [1, 1, 4]);
 * x.squeeze().print();
 * ```
 *
 * @param x The input tensor to be squeezed.
 * @param axis An optional list of numbers. If specified, only
 *     squeezes the dimensions listed. The dimension index starts at 0. It
 * is an error to squeeze a dimension that is not 1.
 *
 * @doc {heading: 'Tensors', subheading: 'Transformations'}
 */
function squeeze_(x, axis) {
    const $x = convertToTensor(x, 'x', 'squeeze', 'string_or_numeric');
    return reshape($x, squeezeShape($x.shape, axis).newShape);
}
const squeeze = op({ squeeze_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
getGlobalTensorClass().prototype.squeeze = function (axis) {
    this.throwIfDisposed();
    return squeeze(this, axis);
};

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns a `tf.Tensor` that has expanded rank, by inserting a dimension
 * into the tensor's shape.
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3, 4]);
 * const axis = 1;
 * x.expandDims(axis).print();
 * ```
 *
 * @param x The input tensor whose dimensions are to be expanded.
 * @param axis The dimension index at which to insert shape of `1`. Defaults
 *     to 0 (the first dimension).
 *
 * @doc {heading: 'Tensors', subheading: 'Transformations'}
 */
function expandDims_(x, axis = 0) {
    const $x = convertToTensor(x, 'x', 'expandDims', 'string_or_numeric');
    assert(axis <= $x.rank, () => 'Axis must be <= rank of the tensor');
    const inputs = { input: $x };
    const attrs = { dim: axis };
    return ENGINE.runKernel(ExpandDims, inputs, attrs);
}
const expandDims = op({ expandDims_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
getGlobalTensorClass().prototype.expandDims = function (axis) {
    this.throwIfDisposed();
    return expandDims(this, axis);
};

function dataset2tfjs(dataset, fields = null, cache = false) {
    const query = fields ? { $select: fields } : {};
    const ds = isDataset(dataset) ? dataset.items().query(query) : dataset;
    const dataSource = cache ? ds.toArray() : Promise.resolve(ds);
    async function* dataGenerator() {
        const instances = await dataSource;
        for await (const instance of instances) {
            yield instance;
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return generator(dataGenerator);
}

function transformEpochData(data) {
    const newData = {};
    for (const [key, val] of Object.entries(data)) {
        const newKey = key.startsWith('val_') ? key.replace('val_', '') + 'Val' : key;
        newData[newKey] = val;
    }
    return newData;
}
class TFJSCustomModel extends TFJSBaseModel {
    constructor({ epochs = 20, batchSize = 8, validationSplit = 0.2, } = {}) {
        super();
        this.title = 'TFJSCustomModel';
        this.loadFn = loadLayersModel;
        this.validationSplit = Math.max(Math.min(validationSplit, 1), 0);
        this.parameters = {
            epochs: new Stream(epochs, true),
            batchSize: new Stream(batchSize, true),
        };
    }
    transformDataset(ds) {
        return ds.map((instance) => ({
            xs: tensor$1(instance.x),
            ys: tensor$1(instance.y),
        }));
    }
    async train(dataset, validationDataset) {
        this.$training.set({ status: 'start', epochs: this.parameters.epochs.get() });
        const isDs = isDataset(dataset);
        const count = isDs ? dataset.$count.value : (await dataset.toArray()).length;
        const nFetch = Math.min(200, count);
        const ds = this.transformDataset(dataset2tfjs(dataset, ['x', 'y'], count < 200)).shuffle(nFetch);
        let dsTrain;
        let dsVal;
        if (validationDataset) {
            dsTrain = ds;
            dsVal = this.transformDataset(dataset2tfjs(validationDataset, ['x', 'y'], count < 200)).shuffle(nFetch);
        }
        else {
            const nTrain = Math.floor(count * (1 - this.validationSplit));
            dsTrain = ds.take(nTrain);
            dsVal = this.validationSplit > 0 && ds.skip(nTrain);
        }
        const [{ xs, ys }] = await dsTrain.take(1).toArray();
        this.buildModel(xs.shape, ys.shape);
        this.fit(dsTrain, dsVal);
    }
    _predict(x) {
        if (!this.model)
            return null;
        return tidy$1(() => {
            const pred = this.model.predict(tensor$1(x).expandDims(0)).gather(0);
            return pred;
        });
    }
    clear() {
        delete this.model;
    }
    fit(dsTrain, dsVal) {
        this.model
            .fitDataset(dsTrain.batch(this.parameters.batchSize.get()), {
            ...(dsVal ? { validationData: dsVal.batch(this.parameters.batchSize.get()) } : {}),
            epochs: this.parameters.epochs.get(),
            callbacks: {
                onEpochEnd: (epoch, logs) => {
                    this.$training.set({
                        status: 'epoch',
                        epoch: epoch + 1,
                        epochs: this.parameters.epochs.get(),
                        data: transformEpochData(logs),
                    });
                },
            },
        })
            .then((results) => {
            this.$training.set({
                status: 'success',
                data: transformEpochData(results.history),
            });
        })
            .catch((error) => {
            this.$training.set({ status: 'error', data: error });
            throw new TrainingError(error.message);
        });
    }
}
__decorate([
    Catch
], TFJSCustomModel.prototype, "train", null);

class TFJSCustomClassifier extends TFJSCustomModel {
    constructor() {
        super(...arguments);
        this.title = 'TFJSCustomClassifier';
    }
    async train(dataset, validationDataset) {
        const isDs = isDataset(dataset);
        this.labels = isDs
            ? await dataset.distinct('y')
            : (this.labels = Array.from(new Set(await dataset.map(({ y }) => y).toArray())));
        if (this.labels.length === 0) {
            throwError(new TrainingError('This dataset is empty or is missing labels'));
            this.$training.set({
                status: 'error',
            });
            return;
        }
        if (this.labels.length === 1) {
            throwError(new TrainingError('At least two classes are needed to train the classifier'));
            this.$training.set({
                status: 'error',
            });
            return;
        }
        const numClasses = this.labels.length;
        this.transformDataset = (ds) => ds.map((instance) => ({
            xs: tensor$1(instance.x),
            ys: oneHot(this.labels.indexOf(instance.y), numClasses),
        }));
        super.train(dataset, validationDataset);
    }
    async predict(x) {
        if (!this.model)
            return { label: undefined, confidences: {} };
        return tidy$1(() => {
            const pred = this._predict(x);
            const label = this.labels[pred.argMax().arraySync()];
            const softmaxes = pred.arraySync();
            const confidences = softmaxes.reduce((c, y, i) => ({ ...c, [this.labels[i]]: y }), {});
            return { label, confidences };
        });
    }
}
__decorate([
    Catch
], TFJSCustomClassifier.prototype, "train", null);

/* src/components/account/account.view.svelte generated by Svelte v3.52.0 */

function create_else_block$i(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			div.textContent = "This dataStore does not require authentication";
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop$1,
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (11:2) {#if dataStore.requiresAuth}
function create_if_block$s(ctx) {
	let await_block_anchor;
	let promise;
	let current;

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: false,
		pending: create_pending_block$2,
		then: create_then_block$2,
		catch: create_catch_block$2,
		value: 3,
		blocks: [,,,]
	};

	handle_promise(promise = /*dataStore*/ ctx[1].connect(), info);

	return {
		c() {
			await_block_anchor = empty();
			info.block.c();
		},
		m(target, anchor) {
			insert(target, await_block_anchor, anchor);
			info.block.m(target, info.anchor = anchor);
			info.mount = () => await_block_anchor.parentNode;
			info.anchor = await_block_anchor;
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			info.ctx = ctx;

			if (dirty & /*dataStore*/ 2 && promise !== (promise = /*dataStore*/ ctx[1].connect()) && handle_promise(promise, info)) ; else {
				update_await_block_branch(info, ctx, dirty);
			}
		},
		i(local) {
			if (current) return;
			transition_in(info.block);
			current = true;
		},
		o(local) {
			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				transition_out(block);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(await_block_anchor);
			info.block.d(detaching);
			info.token = null;
			info = null;
		}
	};
}

// (1:0) <script lang="ts">import { ViewContainer }
function create_catch_block$2(ctx) {
	return {
		c: noop$1,
		m: noop$1,
		p: noop$1,
		i: noop$1,
		o: noop$1,
		d: noop$1
	};
}

// (14:4) {:then user}
function create_then_block$2(ctx) {
	let p;
	let t0;
	let t1_value = /*user*/ ctx[3].email + "";
	let t1;
	let t2;
	let div;
	let button;
	let mounted;
	let dispose;

	return {
		c() {
			p = element("p");
			t0 = text$1("Hello, ");
			t1 = text$1(t1_value);
			t2 = space();
			div = element("div");
			button = element("button");
			button.textContent = "Log out";
			attr(p, "class", "pb-2");
			attr(button, "class", "btn danger");
			attr(div, "class", "flex");
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t0);
			append(p, t1);
			insert(target, t2, anchor);
			insert(target, div, anchor);
			append(div, button);

			if (!mounted) {
				dispose = listen(button, "click", /*logout*/ ctx[2]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*dataStore*/ 2 && t1_value !== (t1_value = /*user*/ ctx[3].email + "")) set_data(t1, t1_value);
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) detach(p);
			if (detaching) detach(t2);
			if (detaching) detach(div);
			mounted = false;
			dispose();
		}
	};
}

// (12:32)        <Spinner />     {:then user}
function create_pending_block$2(ctx) {
	let spinner;
	let current;
	spinner = new Spinner({});

	return {
		c() {
			create_component(spinner.$$.fragment);
		},
		m(target, anchor) {
			mount_component(spinner, target, anchor);
			current = true;
		},
		p: noop$1,
		i(local) {
			if (current) return;
			transition_in(spinner.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(spinner.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(spinner, detaching);
		}
	};
}

// (10:0) <ViewContainer {title}>
function create_default_slot$z(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$s, create_else_block$i];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*dataStore*/ ctx[1].requiresAuth) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$K(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				$$slots: { default: [create_default_slot$z] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];

			if (dirty & /*$$scope, dataStore*/ 18) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$K($$self, $$props, $$invalidate) {
	let { title } = $$props;
	let { dataStore } = $$props;

	function logout() {
		dataStore.logout();
	}

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('dataStore' in $$props) $$invalidate(1, dataStore = $$props.dataStore);
	};

	return [title, dataStore, logout];
}

class Account_view extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$K, create_fragment$K, safe_not_equal, { title: 0, dataStore: 1 });
	}
}

var _Account_dataStore;
class Account extends Component {
    constructor(dataStore) {
        super();
        this.title = 'account manager';
        _Account_dataStore.set(this, void 0);
        __classPrivateFieldSet(this, _Account_dataStore, dataStore, "f");
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Account_view({
            target: t,
            props: {
                title: this.title,
                dataStore: __classPrivateFieldGet(this, _Account_dataStore, "f"),
            },
        });
    }
}
_Account_dataStore = new WeakMap();

function account(...args) {
    return new Account(...args);
}

/* src/components/progress-bar/progress-bar.view.svelte generated by Svelte v3.52.0 */

function create_default_slot$y(ctx) {
	let div3;
	let div2;
	let div0;
	let span0;
	let t0_value = /*$progress*/ ctx[2]?.message + "";
	let t0;
	let t1;
	let div1;
	let span1;
	let t2_value = Math.floor(/*$progress*/ ctx[2]?.progress * 100) + "";
	let t2;
	let t3;
	let t4;
	let progress_1;
	let current;

	progress_1 = new Progress({
			props: {
				progress: /*$progress*/ ctx[2]?.progress,
				type: /*$progress*/ ctx[2]?.type
			}
		});

	return {
		c() {
			div3 = element("div");
			div2 = element("div");
			div0 = element("div");
			span0 = element("span");
			t0 = text$1(t0_value);
			t1 = space();
			div1 = element("div");
			span1 = element("span");
			t2 = text$1(t2_value);
			t3 = text$1("%");
			t4 = space();
			create_component(progress_1.$$.fragment);
			attr(span0, "class", "text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-blue-600 bg-blue-200 svelte-cymqgb");
			toggle_class(span0, "gray", /*$progress*/ ctx[2]?.type === 'idle');
			toggle_class(span0, "green", /*$progress*/ ctx[2]?.type === 'success');
			toggle_class(span0, "red", /*$progress*/ ctx[2]?.type === 'danger');
			attr(span1, "class", "text-xs font-semibold inline-block text-blue-600 svelte-cymqgb");
			toggle_class(span1, "tgray", /*$progress*/ ctx[2]?.type === 'idle');
			toggle_class(span1, "tgreen", /*$progress*/ ctx[2]?.type === 'success');
			toggle_class(span1, "tred", /*$progress*/ ctx[2]?.type === 'danger');
			attr(div1, "class", "text-right");
			attr(div2, "class", "flex mb-2 items-center justify-between");
			attr(div3, "class", "relative pt-6 w-full");
			set_style(div3, "min-width", "250px");
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div2);
			append(div2, div0);
			append(div0, span0);
			append(span0, t0);
			append(div2, t1);
			append(div2, div1);
			append(div1, span1);
			append(span1, t2);
			append(span1, t3);
			append(div3, t4);
			mount_component(progress_1, div3, null);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty & /*$progress*/ 4) && t0_value !== (t0_value = /*$progress*/ ctx[2]?.message + "")) set_data(t0, t0_value);

			if (!current || dirty & /*$progress*/ 4) {
				toggle_class(span0, "gray", /*$progress*/ ctx[2]?.type === 'idle');
			}

			if (!current || dirty & /*$progress*/ 4) {
				toggle_class(span0, "green", /*$progress*/ ctx[2]?.type === 'success');
			}

			if (!current || dirty & /*$progress*/ 4) {
				toggle_class(span0, "red", /*$progress*/ ctx[2]?.type === 'danger');
			}

			if ((!current || dirty & /*$progress*/ 4) && t2_value !== (t2_value = Math.floor(/*$progress*/ ctx[2]?.progress * 100) + "")) set_data(t2, t2_value);

			if (!current || dirty & /*$progress*/ 4) {
				toggle_class(span1, "tgray", /*$progress*/ ctx[2]?.type === 'idle');
			}

			if (!current || dirty & /*$progress*/ 4) {
				toggle_class(span1, "tgreen", /*$progress*/ ctx[2]?.type === 'success');
			}

			if (!current || dirty & /*$progress*/ 4) {
				toggle_class(span1, "tred", /*$progress*/ ctx[2]?.type === 'danger');
			}

			const progress_1_changes = {};
			if (dirty & /*$progress*/ 4) progress_1_changes.progress = /*$progress*/ ctx[2]?.progress;
			if (dirty & /*$progress*/ 4) progress_1_changes.type = /*$progress*/ ctx[2]?.type;
			progress_1.$set(progress_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(progress_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(progress_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div3);
			destroy_component(progress_1);
		}
	};
}

function create_fragment$J(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				$$slots: { default: [create_default_slot$y] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];

			if (dirty & /*$$scope, $progress*/ 12) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$J($$self, $$props, $$invalidate) {
	let $progress,
		$$unsubscribe_progress = noop$1,
		$$subscribe_progress = () => ($$unsubscribe_progress(), $$unsubscribe_progress = subscribe(progress, $$value => $$invalidate(2, $progress = $$value)), progress);

	$$self.$$.on_destroy.push(() => $$unsubscribe_progress());
	let { title } = $$props;
	let { progress } = $$props;
	$$subscribe_progress();

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('progress' in $$props) $$subscribe_progress($$invalidate(1, progress = $$props.progress));
	};

	return [title, progress, $progress];
}

class Progress_bar_view extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$J, create_fragment$J, safe_not_equal, { title: 0, progress: 1 });
	}
}

class ProgressBar extends Component {
    constructor($progress) {
        super();
        this.$progress = $progress;
        this.title = 'progress bar';
        this.start();
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Progress_bar_view({
            target: t,
            props: {
                title: this.title,
                progress: this.$progress,
            },
        });
    }
}

function progressBar(...args) {
    return new ProgressBar(...args);
}
function trainingProgress(m) {
    if (!m.$training) {
        throw new Error('The argument is not a valid MLP');
    }
    const $stream = m.$training
        .map(({ status, epoch, epochs }) => {
        let type = 'default';
        let progress = epochs > 0 ? epoch / epochs : null;
        if (status === 'error') {
            type = 'danger';
        }
        if (status === 'idle') {
            type = 'idle';
            progress = 0;
        }
        if (['success', 'loaded'].includes(status)) {
            type = 'success';
            progress = 1;
        }
        if (['start', 'loading'].includes(status)) {
            progress = null;
        }
        return {
            message: `Status: ${status}`,
            progress,
            type,
        };
    })
        .hold();
    const p = new ProgressBar($stream);
    p.title = 'Training Progress';
    return p;
}

var _BatchPrediction_store;
class BatchPrediction extends Component {
    constructor(name, store = dataStore()) {
        super();
        this.title = 'batch prediction';
        _BatchPrediction_store.set(this, void 0);
        this.$status = new Stream({ status: 'loading' }, true);
        this.name = name;
        this.title = `batch prediction (${name})`;
        __classPrivateFieldSet(this, _BatchPrediction_store, store || new DataStore(), "f");
        this.start();
        __classPrivateFieldGet(this, _BatchPrediction_store, "f")
            .connect()
            .then(() => {
            this.setup();
        })
            .catch((e) => {
            const err = new Error(e === null || e === void 0 ? void 0 : e.message);
            err.name = `Batch Prediction Error (${name}): Datastore connection failed`;
            throwError(err, { duration: 0 });
        });
    }
    async setup() {
        const serviceName = toKebabCase(`predictions-${this.name}`);
        this.predictionService = __classPrivateFieldGet(this, _BatchPrediction_store, "f").service(serviceName);
        const { total } = (await this.predictionService.find({
            query: { $limit: 1, $select: ['id'] },
        }));
        this.$status.set({ status: total > 0 ? 'loaded' : 'idle' });
    }
    async predict(model, dataset) {
        try {
            const total = isDataset(dataset) ? dataset.$count.value : (await dataset.toArray()).length;
            this.$status.set({ status: 'start' });
            const ds = isDataset(dataset) ? dataset.items() : dataset;
            let i = 0;
            for await (const { id, x, y } of ds) {
                const prediction = await model.predict(x);
                const storedPrediction = await this.predictionService.create({
                    ...prediction,
                    instanceId: id,
                    yTrue: y,
                });
                this.$status.set({
                    status: 'running',
                    count: ++i,
                    total,
                    data: storedPrediction,
                });
            }
            this.$status.set({ status: 'success', count: i, total });
        }
        catch (error) {
            this.$status.set({ status: 'error', data: { error } });
        }
    }
    async clear() {
        await this.predictionService.remove(null, { query: {} });
    }
    items() {
        return this.predictionService.items();
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    mount() { }
}
_BatchPrediction_store = new WeakMap();

function batchPrediction(...args) {
    return new BatchPrediction(...args);
}
function predictionProgress(m) {
    if (!m.$status) {
        throw new Error('The argument is not a valid Batch Prediction');
    }
    const $stream = m.$status
        .map(({ status, count, total }) => {
        let type = 'default';
        let progress = total > 0 ? (count + 1) / total : null;
        if (status === 'error') {
            type = 'danger';
        }
        if (status === 'idle') {
            type = 'idle';
            progress = 0;
        }
        if (['success', 'loaded'].includes(status)) {
            type = 'success';
            progress = 1;
        }
        if (['start', 'loading'].includes(status)) {
            progress = null;
        }
        return {
            message: `Status: ${status}`,
            progress,
            type,
        };
    })
        .hold();
    const p = progressBar($stream);
    p.title = 'Prediction Progress';
    return p;
}

/* src/components/button/button.view.svelte generated by Svelte v3.52.0 */

function create_default_slot_1$c(ctx) {
	let t;

	return {
		c() {
			t = text$1(/*$text*/ ctx[10]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$text*/ 1024) set_data(t, /*$text*/ ctx[10]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (11:0) <ViewContainer {title} loading={$loading}>
function create_default_slot$x(ctx) {
	let div;
	let button;
	let updating_pressed;
	let current;

	function button_pressed_binding(value) {
		/*button_pressed_binding*/ ctx[11](value);
	}

	let button_props = {
		disabled: /*$disabled*/ ctx[7],
		type: /*$type*/ ctx[8],
		$$slots: { default: [create_default_slot_1$c] },
		$$scope: { ctx }
	};

	if (/*$pressed*/ ctx[9] !== void 0) {
		button_props.pressed = /*$pressed*/ ctx[9];
	}

	button = new Button$1({ props: button_props });
	binding_callbacks.push(() => bind(button, 'pressed', button_pressed_binding));
	button.$on("click", /*click_handler*/ ctx[12]);

	return {
		c() {
			div = element("div");
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(button, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*$disabled*/ 128) button_changes.disabled = /*$disabled*/ ctx[7];
			if (dirty & /*$type*/ 256) button_changes.type = /*$type*/ ctx[8];

			if (dirty & /*$$scope, $text*/ 9216) {
				button_changes.$$scope = { dirty, ctx };
			}

			if (!updating_pressed && dirty & /*$pressed*/ 512) {
				updating_pressed = true;
				button_changes.pressed = /*$pressed*/ ctx[9];
				add_flush_callback(() => updating_pressed = false);
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(button);
		}
	};
}

function create_fragment$I(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				loading: /*$loading*/ ctx[6],
				$$slots: { default: [create_default_slot$x] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];
			if (dirty & /*$loading*/ 64) viewcontainer_changes.loading = /*$loading*/ ctx[6];

			if (dirty & /*$$scope, $disabled, $type, $pressed, $text*/ 10112) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$I($$self, $$props, $$invalidate) {
	let $loading,
		$$unsubscribe_loading = noop$1,
		$$subscribe_loading = () => ($$unsubscribe_loading(), $$unsubscribe_loading = subscribe(loading, $$value => $$invalidate(6, $loading = $$value)), loading);

	let $disabled,
		$$unsubscribe_disabled = noop$1,
		$$subscribe_disabled = () => ($$unsubscribe_disabled(), $$unsubscribe_disabled = subscribe(disabled, $$value => $$invalidate(7, $disabled = $$value)), disabled);

	let $type,
		$$unsubscribe_type = noop$1,
		$$subscribe_type = () => ($$unsubscribe_type(), $$unsubscribe_type = subscribe(type, $$value => $$invalidate(8, $type = $$value)), type);

	let $pressed,
		$$unsubscribe_pressed = noop$1,
		$$subscribe_pressed = () => ($$unsubscribe_pressed(), $$unsubscribe_pressed = subscribe(pressed, $$value => $$invalidate(9, $pressed = $$value)), pressed);

	let $text,
		$$unsubscribe_text = noop$1,
		$$subscribe_text = () => ($$unsubscribe_text(), $$unsubscribe_text = subscribe(text, $$value => $$invalidate(10, $text = $$value)), text);

	$$self.$$.on_destroy.push(() => $$unsubscribe_loading());
	$$self.$$.on_destroy.push(() => $$unsubscribe_disabled());
	$$self.$$.on_destroy.push(() => $$unsubscribe_type());
	$$self.$$.on_destroy.push(() => $$unsubscribe_pressed());
	$$self.$$.on_destroy.push(() => $$unsubscribe_text());
	let { title } = $$props;
	let { text } = $$props;
	$$subscribe_text();
	let { pressed } = $$props;
	$$subscribe_pressed();
	let { loading } = $$props;
	$$subscribe_loading();
	let { disabled } = $$props;
	$$subscribe_disabled();
	let { type } = $$props;
	$$subscribe_type();

	function button_pressed_binding(value) {
		$pressed = value;
		pressed.set($pressed);
	}

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('text' in $$props) $$subscribe_text($$invalidate(1, text = $$props.text));
		if ('pressed' in $$props) $$subscribe_pressed($$invalidate(2, pressed = $$props.pressed));
		if ('loading' in $$props) $$subscribe_loading($$invalidate(3, loading = $$props.loading));
		if ('disabled' in $$props) $$subscribe_disabled($$invalidate(4, disabled = $$props.disabled));
		if ('type' in $$props) $$subscribe_type($$invalidate(5, type = $$props.type));
	};

	return [
		title,
		text,
		pressed,
		loading,
		disabled,
		type,
		$loading,
		$disabled,
		$type,
		$pressed,
		$text,
		button_pressed_binding,
		click_handler
	];
}

class Button_view extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$I, create_fragment$I, safe_not_equal, {
			title: 0,
			text: 1,
			pressed: 2,
			loading: 3,
			disabled: 4,
			type: 5
		});
	}
}

class Button extends Component {
    constructor(text = 'click me') {
        super();
        this.title = 'button';
        this.$click = new Stream(never());
        this.$pressed = new Stream(false, true);
        this.$loading = new Stream(false, true);
        this.$disabled = new Stream(false, true);
        this.$type = new Stream('default', true);
        this.$text = new Stream(text, true);
        this.start();
        this.$loading.skip(1).subscribe((loading) => {
            this.$disabled.set(loading);
        });
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Button_view({
            target: t,
            props: {
                title: this.title,
                text: this.$text,
                pressed: this.$pressed,
                loading: this.$loading,
                disabled: this.$disabled,
                type: this.$type,
            },
        });
        this.$$.app.$on('click', this.$click.set);
    }
}

function button(...args) {
    return new Button(...args);
}

/* src/components/coco-ssd/coco-ssd.view.svelte generated by Svelte v3.52.0 */

function create_else_block$h(ctx) {
	let t0;
	let t1;

	return {
		c() {
			t0 = text$1("COCO-SSD loaded with base ");
			t1 = text$1(/*base*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*base*/ 4) set_data(t1, /*base*/ ctx[2]);
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
		}
	};
}

// (9:4) {#if $loading}
function create_if_block$r(ctx) {
	let t;

	return {
		c() {
			t = text$1(" ");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (7:0) <ViewContainer {title} loading={$loading}>
function create_default_slot$w(ctx) {
	let p;

	function select_block_type(ctx, dirty) {
		if (/*$loading*/ ctx[3]) return create_if_block$r;
		return create_else_block$h;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			p = element("p");
			if_block.c();
			attr(p, "class", "p-2 text-sm text-gray-600");
		},
		m(target, anchor) {
			insert(target, p, anchor);
			if_block.m(p, null);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(p, null);
				}
			}
		},
		d(detaching) {
			if (detaching) detach(p);
			if_block.d();
		}
	};
}

function create_fragment$H(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				loading: /*$loading*/ ctx[3],
				$$slots: { default: [create_default_slot$w] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];
			if (dirty & /*$loading*/ 8) viewcontainer_changes.loading = /*$loading*/ ctx[3];

			if (dirty & /*$$scope, $loading, base*/ 28) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$H($$self, $$props, $$invalidate) {
	let $loading,
		$$unsubscribe_loading = noop$1,
		$$subscribe_loading = () => ($$unsubscribe_loading(), $$unsubscribe_loading = subscribe(loading, $$value => $$invalidate(3, $loading = $$value)), loading);

	$$self.$$.on_destroy.push(() => $$unsubscribe_loading());
	let { title } = $$props;
	let { loading } = $$props;
	$$subscribe_loading();
	let { base } = $$props;

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('loading' in $$props) $$subscribe_loading($$invalidate(1, loading = $$props.loading));
		if ('base' in $$props) $$invalidate(2, base = $$props.base);
	};

	return [title, loading, base, $loading];
}

class Coco_ssd_view extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$H, create_fragment$H, safe_not_equal, { title: 0, loading: 1, base: 2 });
	}
}

var _CocoSsd_coco, _CocoSsd_base;
class CocoSsd extends Model {
    constructor({ base = 'lite_mobilenet_v2' } = {}) {
        super();
        this.title = 'COCO-SSD Object Detection';
        this.parameters = {};
        this.serviceName = 'undefined';
        _CocoSsd_coco.set(this, void 0);
        _CocoSsd_base.set(this, void 0);
        this.$loading = new Stream(true, true);
        __classPrivateFieldSet(this, _CocoSsd_base, base, "f");
        this.setup();
    }
    async setup() {
        const cachedModels = await io$1.listModels();
        const cachedCoco = Object.keys(cachedModels).filter((x) => x.includes('cocossd'));
        try {
            __classPrivateFieldSet(this, _CocoSsd_coco, await load({ base: __classPrivateFieldGet(this, _CocoSsd_base, "f"), modelUrl: `indexeddb://cocossd-${__classPrivateFieldGet(this, _CocoSsd_base, "f")}` }), "f");
        }
        catch (error) {
            if (cachedCoco.length > 0) {
                await io$1.removeModel(cachedCoco[0]);
            }
            __classPrivateFieldSet(this, _CocoSsd_coco, await load({ base: __classPrivateFieldGet(this, _CocoSsd_base, "f") }), "f");
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            await __classPrivateFieldGet(this, _CocoSsd_coco, "f").model.save(`indexeddb://cocossd-${__classPrivateFieldGet(this, _CocoSsd_base, "f")}`);
        }
        logger.info('COCO-SSD loaded with base `lite_mobilenet_v2`');
        this.$loading.set(false);
        this.start();
    }
    // eslint-disable-next-line class-methods-use-this
    train() {
        throw new TrainingError('Model `CocoSsd` cannot be trained');
    }
    async predict(img) {
        if (!__classPrivateFieldGet(this, _CocoSsd_coco, "f")) {
            throw new Error('Model is not loaded');
        }
        const predictions = await __classPrivateFieldGet(this, _CocoSsd_coco, "f").detect(img);
        const outputs = predictions.map((x) => ({
            bbox: x.bbox,
            class: x.class,
            confidence: x.score,
        }));
        return { outputs };
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Coco_ssd_view({
            target: t,
            props: {
                title: this.title,
                loading: this.$loading,
                base: __classPrivateFieldGet(this, _CocoSsd_base, "f"),
            },
        });
    }
    // eslint-disable-next-line class-methods-use-this
    save() {
        throw new Error('CocoSsd does not support saving');
    }
    // eslint-disable-next-line class-methods-use-this
    load() {
        throw new Error('CocoSsd does not support loading');
    }
    // eslint-disable-next-line class-methods-use-this
    download() {
        throw new Error('CocoSsd does not support downloading');
    }
    // eslint-disable-next-line class-methods-use-this
    upload() {
        throw new Error('CocoSsd does not support uploading');
    }
}
_CocoSsd_coco = new WeakMap(), _CocoSsd_base = new WeakMap();
__decorate([
    Catch
    // eslint-disable-next-line class-methods-use-this
], CocoSsd.prototype, "train", null);
__decorate([
    Catch
], CocoSsd.prototype, "predict", null);
__decorate([
    Catch
    // eslint-disable-next-line class-methods-use-this
], CocoSsd.prototype, "save", null);
__decorate([
    Catch
    // eslint-disable-next-line class-methods-use-this
], CocoSsd.prototype, "load", null);
__decorate([
    Catch
    // eslint-disable-next-line class-methods-use-this
], CocoSsd.prototype, "download", null);
__decorate([
    Catch
    // eslint-disable-next-line class-methods-use-this
], CocoSsd.prototype, "upload", null);

function cocoSsd(...args) {
    return new CocoSsd(...args);
}

/* src/components/generic-chart/generic-chart.view.svelte generated by Svelte v3.52.0 */

function create_default_slot$v(ctx) {
	let div;
	let canvas;

	return {
		c() {
			div = element("div");
			canvas = element("canvas");
			attr(div, "class", "w-full h-96");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, canvas);
			/*canvas_binding*/ ctx[6](canvas);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(div);
			/*canvas_binding*/ ctx[6](null);
		}
	};
}

function create_fragment$G(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				$$slots: { default: [create_default_slot$v] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];

			if (dirty & /*$$scope, canvasElement*/ 32770) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$G($$self, $$props, $$invalidate) {
	let { title } = $$props;
	let { preset } = $$props;
	let { options } = $$props;
	let { datasets } = $$props;

	// Note: typings are very dirty here...
	Chart.register(ArcElement, BarController, BubbleController, CategoryScale, DoughnutController, Filler, Legend, LineElement, LineController, LinearScale, LogarithmicScale, PieController, PointElement, PolarAreaController, RadarController, RadialLinearScale, BarElement, ScatterController, TimeScale, TimeSeriesScale, Title, Tooltip);

	const defaultColors = [
		'rgb(54, 162, 235)',
		'rgb(255, 99, 132)',
		'rgb(255, 206, 86)',
		'rgb(75, 192, 192)',
		'rgb(153, 102, 255)',
		'rgb(255, 159, 64)'
	];

	const defaultOptions = {
		data: {},
		options: {
			maintainAspectRatio: false,
			animation: { duration: 200 },
			borderWidth: 4
		}
	};

	function defaultDatasetOptions(index) {
		return {
			borderColor: defaultColors[index % 6],
			backgroundColor: defaultColors[index % 6],
			fill: false,
			lineTension: 0.2
		};
	}

	function transformDatasets(ds, opts, globalOptions) {
		const data = { labels: [] };
		let maxElts = 0;

		data.datasets = ds.map(({ dataStream, label, options: localOptions }, i) => {
			maxElts = Math.max(maxElts, dataStream.get() ? dataStream.get().length : 0);

			if (i === 0) {
				data.labels = localOptions.labels || [];

				if (!localOptions.labels && dataStream.get() && dataStream.get().length > 0) {
					if (typeof dataStream.get()[0] === 'number') {
						data.labels = Array.from(Array(dataStream.get().length), (_, j) => j.toString());
					} else {
						data.labels = dataStream.get().map(o => o.x.toString());
					}
				}
			}

			let o = {
				...defaultDatasetOptions(i),
				...opts,
				...localOptions,
				label,
				data: dataStream.get() || []
			};

			if ((['bar', 'bar-fast'].includes(localOptions.type) || ['bar', 'bar-fast'].includes(globalOptions.type) && !localOptions.type) && ds.length === 1) {
				o.borderColor = defaultColors;
				o.backgroundColor = defaultColors;
			}

			return o;
		});

		return data;
	}

	let chart;
	let unSub = [];
	let canvasElement;

	function setup() {
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		let chartOptions = mergeDeep(defaultOptions, preset.global);

		chartOptions = mergeDeep(chartOptions, {
			data: transformDatasets(datasets, preset.datasets, chartOptions),
			options
		});

		if (options.xlabel) {
			chartOptions = mergeDeep(chartOptions, {
				options: {
					scales: {
						x: {
							title: { display: true, text: options.xlabel }
						}
					}
				}
			});
		}

		if (options.ylabel) {
			chartOptions = mergeDeep(chartOptions, {
				options: {
					scales: {
						y: {
							title: { display: true, text: options.ylabel }
						}
					}
				}
			});
		}

		const pointsPerSeries = datasets.map(({ dataStream }) => {
			var _a;

			return ((_a = dataStream.get()) === null || _a === void 0
			? void 0
			: _a.length) || 0;
		});

		unSub = datasets.map(({ dataStream, options: localOptions }, i) => dataStream.subscribe(values => {
			if (values && chart) {
				const prevMaxPoint = pointsPerSeries.reduce((m, x) => Math.max(m, x));
				pointsPerSeries[i] = values.length;

				if (!localOptions.labels && values.length > 0 && pointsPerSeries[i] > prevMaxPoint) {
					if (typeof values[0] === 'number') {
						chartOptions.data.labels = Array.from(Array(values.length), (_, j) => j.toString());
					} else {
						chartOptions.data.labels = values.map(o => o.x.toString());
					}
				}

				// eslint-disable-next-line @typescript-eslint/no-explicit-any
				chartOptions.data.datasets[i].data = values;

				try {
					chart.update();
				} catch(error) {
					// eslint-disable-next-line no-console
					console.log(error);
				}
			}
		}));

		const ctx = canvasElement.getContext('2d');
		chart = new Chart(ctx, chartOptions);
	}

	function destroy() {
		for (const f of unSub) {
			f();
		}

		chart === null || chart === void 0
		? void 0
		: chart.destroy();
	}

	onMount(async () => {
		await tick();
		await tick();
		setup();
	});

	let numDatasets = datasets.length;
	onDestroy(destroy);

	function canvas_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			canvasElement = $$value;
			$$invalidate(1, canvasElement);
		});
	}

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('preset' in $$props) $$invalidate(2, preset = $$props.preset);
		if ('options' in $$props) $$invalidate(3, options = $$props.options);
		if ('datasets' in $$props) $$invalidate(4, datasets = $$props.datasets);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*datasets, numDatasets*/ 48) {
			{
				if (datasets.length !== numDatasets) {
					destroy();
					setup();
					$$invalidate(5, numDatasets = datasets.length);
				}
			}
		}
	};

	return [title, canvasElement, preset, options, datasets, numDatasets, canvas_binding];
}

class Generic_chart_view extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$G, create_fragment$G, safe_not_equal, {
			title: 0,
			preset: 2,
			options: 3,
			datasets: 4
		});
	}
}

var _GenericChart_presetName, _GenericChart_preset, _GenericChart_datasets;
// TODO: Automatic switch to fast mode when high number of points
const presets = {
    line: {
        global: {
            type: 'line',
            options: {
                animation: { duration: 200 },
                scales: {
                    x: {
                        ticks: {
                            sampleSize: 11,
                        },
                    },
                },
            },
        },
        datasets: {
            fill: false,
            lineTension: 0.2,
        },
    },
    'line-fast': {
        global: {
            type: 'line',
            options: {
                elements: {
                    point: {
                        radius: 0,
                    },
                },
                animation: false,
                tooltips: false,
                spanGaps: true,
                scales: {
                    x: {
                        ticks: {
                            sampleSize: 11,
                        },
                    },
                },
            },
        },
        datasets: {
            fill: false,
            lineTension: 0,
        },
    },
    bar: {
        global: {
            type: 'bar',
            options: {
                animation: { duration: 200 },
                scales: {
                    y: {
                        beginAtZero: true,
                    },
                },
            },
        },
    },
    'bar-fast': {
        global: {
            type: 'bar',
            options: {
                animation: false,
                scales: {
                    y: {
                        beginAtZero: true,
                    },
                },
            },
        },
    },
    scatter: {
        global: {
            type: 'scatter',
            options: {
                scales: {
                    x: {
                        type: 'linear',
                        position: 'bottom',
                    },
                },
            },
        },
    },
};
class GenericChart extends Component {
    constructor({ preset = 'line', options = {} } = {}) {
        super();
        this.title = 'generic chart';
        _GenericChart_presetName.set(this, void 0);
        _GenericChart_preset.set(this, void 0);
        _GenericChart_datasets.set(this, []);
        if (!Object.keys(presets).includes(preset)) {
            throwError(new Error(`Preset ${preset} is not recognized`));
        }
        __classPrivateFieldSet(this, _GenericChart_presetName, preset, "f");
        __classPrivateFieldSet(this, _GenericChart_preset, presets[preset], "f");
        this.options = options;
        this.start();
    }
    addSeries(series, label, options = {}) {
        if (isStream(series)) {
            if (__classPrivateFieldGet(this, _GenericChart_presetName, "f") === 'line-fast') {
                const throttledStream = series.debounce(10);
                throttledStream.value = series.get();
                __classPrivateFieldGet(this, _GenericChart_datasets, "f").push({
                    dataStream: throttledStream,
                    label,
                    options,
                });
            }
            else {
                __classPrivateFieldGet(this, _GenericChart_datasets, "f").push({ dataStream: series, label, options });
            }
            this.updateView();
        }
        else {
            series
                .toArray()
                .then((values) => {
                const dataStream = new Stream(values, true);
                __classPrivateFieldGet(this, _GenericChart_datasets, "f").push({ dataStream, label, options });
                this.updateView();
            });
        }
    }
    setColors(colorStream) {
        __classPrivateFieldGet(this, _GenericChart_datasets, "f")[0].label = 'clusters';
        __classPrivateFieldGet(this, _GenericChart_datasets, "f")[0].options.backgroundColor = colorStream.get();
        __classPrivateFieldGet(this, _GenericChart_datasets, "f")[0].options.color = colorStream.get(); //alternatePointStyles;
    }
    removeSeries(dataStream) {
        const index = __classPrivateFieldGet(this, _GenericChart_datasets, "f").map((x) => x.dataStream).indexOf(dataStream);
        if (index > -1) {
            __classPrivateFieldGet(this, _GenericChart_datasets, "f").splice(index, 1);
        }
    }
    clear() {
        __classPrivateFieldSet(this, _GenericChart_datasets, [], "f");
        this.updateView();
    }
    updateView() {
        if (this.$$.app) {
            this.$$.app.$set({ datasets: __classPrivateFieldGet(this, _GenericChart_datasets, "f") });
        }
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Generic_chart_view({
            target: t,
            props: {
                title: this.title,
                preset: __classPrivateFieldGet(this, _GenericChart_preset, "f"),
                options: this.options,
                datasets: __classPrivateFieldGet(this, _GenericChart_datasets, "f"),
            },
        });
    }
}
_GenericChart_presetName = new WeakMap(), _GenericChart_preset = new WeakMap(), _GenericChart_datasets = new WeakMap();

function genericChart(...args) {
    return new GenericChart(...args);
}

/* src/components/text/text.view.svelte generated by Svelte v3.52.0 */

function create_if_block$q(ctx) {
	let html_tag;
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTag(false);
			html_anchor = empty();
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(/*$text*/ ctx[2], target, anchor);
			insert(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$text*/ 4) html_tag.p(/*$text*/ ctx[2]);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (8:0) <ViewContainer {title}>
function create_default_slot$u(ctx) {
	let div;
	let if_block = /*$text*/ ctx[2] && create_if_block$q(ctx);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			attr(div, "class", "grow");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
		},
		p(ctx, dirty) {
			if (/*$text*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$q(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
		}
	};
}

function create_fragment$F(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				$$slots: { default: [create_default_slot$u] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];

			if (dirty & /*$$scope, $text*/ 12) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$F($$self, $$props, $$invalidate) {
	let $text,
		$$unsubscribe_text = noop$1,
		$$subscribe_text = () => ($$unsubscribe_text(), $$unsubscribe_text = subscribe(text, $$value => $$invalidate(2, $text = $$value)), text);

	$$self.$$.on_destroy.push(() => $$unsubscribe_text());
	let { title } = $$props;
	let { text } = $$props;
	$$subscribe_text();

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('text' in $$props) $$subscribe_text($$invalidate(1, text = $$props.text));
	};

	return [title, text, $text];
}

class Text_view extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$F, create_fragment$F, safe_not_equal, { title: 0, text: 1 });
	}

	get title() {
		return this.$$.ctx[0];
	}

	set title(title) {
		this.$$set({ title });
		flush();
	}

	get text() {
		return this.$$.ctx[1];
	}

	set text(text) {
		this.$$set({ text });
		flush();
	}
}

class Text extends Component {
    constructor(initial = 'click me') {
        super();
        this.title = 'text';
        this.$value = new Stream(initial, true);
        this.start();
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Text_view({
            target: t,
            props: {
                title: this.title,
                text: this.$value,
            },
        });
    }
}

function text(...args) {
    return new Text(...args);
}

var _ConfidencePlot_plotConfidences, _ConfidencePlot_displayLabel;
class ConfidencePlot extends Component {
    constructor(predictionStream) {
        super();
        this.title = 'confidence plot';
        _ConfidencePlot_plotConfidences.set(this, void 0);
        _ConfidencePlot_displayLabel.set(this, void 0);
        this.$confidenceStream = predictionStream.map(({ confidences }) => Object.entries(confidences)
            .map(([label, value]) => ({ x: label, y: value }))
            .sort((a, b) => {
            if (a.x < b.x)
                return -1;
            if (a.x > b.x)
                return 1;
            return 0;
        }));
        __classPrivateFieldSet(this, _ConfidencePlot_plotConfidences, genericChart({
            preset: 'bar-fast',
            options: {
                xlabel: 'Label',
                ylabel: 'Confidence',
                scales: { y: { suggestedMax: 1 } },
            },
        }), "f");
        __classPrivateFieldGet(this, _ConfidencePlot_plotConfidences, "f").addSeries(this.$confidenceStream, 'Confidences');
        __classPrivateFieldGet(this, _ConfidencePlot_plotConfidences, "f").title = '';
        __classPrivateFieldSet(this, _ConfidencePlot_displayLabel, text('Waiting for predictions...'), "f");
        __classPrivateFieldGet(this, _ConfidencePlot_displayLabel, "f").title = this.title;
        __classPrivateFieldGet(this, _ConfidencePlot_displayLabel, "f").$value = new Stream(predictionStream
            .map(({ label }) => `<p>Predicted Label: <code style="font-size: 1.5rem;">${label}</code></p>`)
            .startWith('Waiting for predictions...'), true);
        this.start();
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        const divLab = document.createElement('div');
        divLab.id = `${t.id}-${__classPrivateFieldGet(this, _ConfidencePlot_displayLabel, "f").id}`;
        const divConf = document.createElement('div');
        divConf.id = `${t.id}-${__classPrivateFieldGet(this, _ConfidencePlot_plotConfidences, "f").id}`;
        t.appendChild(divLab);
        t.appendChild(divConf);
        __classPrivateFieldGet(this, _ConfidencePlot_displayLabel, "f").title = this.title;
        __classPrivateFieldGet(this, _ConfidencePlot_displayLabel, "f").mount(divLab);
        __classPrivateFieldGet(this, _ConfidencePlot_plotConfidences, "f").mount(divConf);
        this.destroy = () => {
            divLab.parentElement.removeChild(divLab);
            divConf.parentElement.removeChild(divConf);
            __classPrivateFieldGet(this, _ConfidencePlot_displayLabel, "f").destroy();
            __classPrivateFieldGet(this, _ConfidencePlot_plotConfidences, "f").destroy();
        };
    }
    destroy() {
        __classPrivateFieldGet(this, _ConfidencePlot_displayLabel, "f").destroy();
        __classPrivateFieldGet(this, _ConfidencePlot_plotConfidences, "f").destroy();
    }
}
_ConfidencePlot_plotConfidences = new WeakMap(), _ConfidencePlot_displayLabel = new WeakMap();

function confidencePlot(...args) {
    return new ConfidencePlot(...args);
}

/* src/components/confusion-matrix/confusion-matrix.view.svelte generated by Svelte v3.52.0 */

function create_else_block$g(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "Waiting for predictions...";
			attr(p, "class", "m-2");
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (153:2) {#if $accuracy !== undefined}
function create_if_block$p(ctx) {
	let p;
	let t0;
	let t1_value = /*$accuracy*/ ctx[6].toFixed(2) + "";
	let t1;
	let t2;
	let div;
	let canvas;
	let mounted;
	let dispose;

	return {
		c() {
			p = element("p");
			t0 = text$1("Global Accuracy: ");
			t1 = text$1(t1_value);
			t2 = space();
			div = element("div");
			canvas = element("canvas");
			attr(p, "class", "m-2");
			attr(div, "class", "confusion-container svelte-1d2i0ke");
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t0);
			append(p, t1);
			insert(target, t2, anchor);
			insert(target, div, anchor);
			append(div, canvas);

			if (!mounted) {
				dispose = action_destroyer(/*setup*/ ctx[7].call(null, canvas));
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*$accuracy*/ 64 && t1_value !== (t1_value = /*$accuracy*/ ctx[6].toFixed(2) + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(p);
			if (detaching) detach(t2);
			if (detaching) detach(div);
			mounted = false;
			dispose();
		}
	};
}

// (152:0) <ViewContainer {title} loading={$loading} progress={$progress}>
function create_default_slot$t(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*$accuracy*/ ctx[6] !== undefined) return create_if_block$p;
		return create_else_block$g;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$E(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				loading: /*$loading*/ ctx[4],
				progress: /*$progress*/ ctx[5],
				$$slots: { default: [create_default_slot$t] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];
			if (dirty & /*$loading*/ 16) viewcontainer_changes.loading = /*$loading*/ ctx[4];
			if (dirty & /*$progress*/ 32) viewcontainer_changes.progress = /*$progress*/ ctx[5];

			if (dirty & /*$$scope, $accuracy*/ 131136) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$E($$self, $$props, $$invalidate) {
	let $loading,
		$$unsubscribe_loading = noop$1,
		$$subscribe_loading = () => ($$unsubscribe_loading(), $$unsubscribe_loading = subscribe(loading, $$value => $$invalidate(4, $loading = $$value)), loading);

	let $progress,
		$$unsubscribe_progress = noop$1,
		$$subscribe_progress = () => ($$unsubscribe_progress(), $$unsubscribe_progress = subscribe(progress, $$value => $$invalidate(5, $progress = $$value)), progress);

	let $accuracy,
		$$unsubscribe_accuracy = noop$1,
		$$subscribe_accuracy = () => ($$unsubscribe_accuracy(), $$unsubscribe_accuracy = subscribe(accuracy, $$value => $$invalidate(6, $accuracy = $$value)), accuracy);

	$$self.$$.on_destroy.push(() => $$unsubscribe_loading());
	$$self.$$.on_destroy.push(() => $$unsubscribe_progress());
	$$self.$$.on_destroy.push(() => $$unsubscribe_accuracy());
	let { title } = $$props;
	let { loading } = $$props;
	$$subscribe_loading();
	let { progress } = $$props;
	$$subscribe_progress();
	let { accuracy } = $$props;
	$$subscribe_accuracy();
	let { confusion } = $$props;
	let { labels } = $$props;
	let { selected } = $$props;
	Chart.register(CategoryScale, Title, Tooltip, MatrixElement, MatrixController);
	let maxCount = 1;
	let nLabels = 1;
	let selectedDataIndex = -1;

	const defaultOptions = {
		type: 'matrix',
		data: {
			datasets: [
				{
					label: 'Confusion Matrix',
					data: [],
					backgroundColor(context) {
						if (context.dataset.data.length > 0) {
							if (context.dataIndex === selectedDataIndex) {
								const { x, y } = context.dataset.data[context.dataIndex];
								return x === y ? 'green' : 'red';
							}

							const value = context.dataset.data[context.dataIndex].v;
							return `rgba(54, 162, 235, ${value / maxCount})`;
						}

						return 'rgba(54, 162, 235, 0)';
					},
					width(context) {
						const a = context.chart.chartArea;

						if (!a) {
							return 0;
						}

						return (a.right - a.left) / nLabels - 2;
					},
					height(context) {
						const a = context.chart.chartArea;

						if (!a) {
							return 0;
						}

						return (a.bottom - a.top) / nLabels - 2;
					}
				}
			]
		},
		options: {
			aspectRatio: 1,
			legend: { display: false },
			plugins: {
				tooltip: {
					callbacks: {
						title([context]) {
							const v = context.dataset.data[context.dataIndex];
							return ['count: ' + v.v];
						},
						label(context) {
							const v = context.dataset.data[context.dataIndex];
							return ['true label: ' + v.y, 'predicted label: ' + v.x];
						}
					}
				}
			},
			scales: {
				x: {
					type: 'category',
					labels: [],
					ticks: { display: true, autoSkip: false },
					gridLines: { display: false },
					title: { display: true, text: 'Predicted Label' }
				},
				y: {
					type: 'category',
					labels: [],
					offset: true,
					reverse: true,
					ticks: { display: true, autoSkip: false },
					gridLines: { display: false },
					title: { display: true, text: 'True Label' }
				}
			},
			onClick(e) {
				try {
					const dataIndex = e.chart.tooltip.dataPoints[0].dataIndex;

					if (selectedDataIndex === dataIndex) {
						selected.set(null);
						selectedDataIndex = -1;
					} else {
						selected.set(e.chart.tooltip.dataPoints[0].raw);
						selectedDataIndex = dataIndex;
						e.chart.update();
					}
				} catch(error) {
					// eslint-disable-next-line no-console
					console.log('[confusion matrix] selection error:', error);
				}
			}
		}
	};

	let chart;
	let unSub = [];

	function setup(canvasElement) {
		const ctx = canvasElement.getContext('2d');
		chart = new Chart(ctx, defaultOptions);

		unSub.push(labels.subscribe(labs => {
			nLabels = labs.length;
			defaultOptions.options.scales.x.labels = labs.sort();
			defaultOptions.options.scales.y.labels = labs.sort();
			chart.update();
		}));

		unSub.push(confusion.subscribe(conf => {
			maxCount = conf.reduce((m, { v }) => Math.max(m, v), 0);
			defaultOptions.data.datasets[0].data = conf;
			chart.update();
		}));
	}

	onDestroy(() => {
		for (const f of unSub) {
			f();
		}
	});

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('loading' in $$props) $$subscribe_loading($$invalidate(1, loading = $$props.loading));
		if ('progress' in $$props) $$subscribe_progress($$invalidate(2, progress = $$props.progress));
		if ('accuracy' in $$props) $$subscribe_accuracy($$invalidate(3, accuracy = $$props.accuracy));
		if ('confusion' in $$props) $$invalidate(8, confusion = $$props.confusion);
		if ('labels' in $$props) $$invalidate(9, labels = $$props.labels);
		if ('selected' in $$props) $$invalidate(10, selected = $$props.selected);
	};

	return [
		title,
		loading,
		progress,
		accuracy,
		$loading,
		$progress,
		$accuracy,
		setup,
		confusion,
		labels,
		selected
	];
}

class Confusion_matrix_view extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$E, create_fragment$E, safe_not_equal, {
			title: 0,
			loading: 1,
			progress: 2,
			accuracy: 3,
			confusion: 8,
			labels: 9,
			selected: 10
		});
	}
}

var _ConfusionMatrix_prediction;
class ConfusionMatrix extends Component {
    constructor(prediction) {
        super();
        this.title = 'confusion matrix';
        _ConfusionMatrix_prediction.set(this, void 0);
        this.$confusion = new Stream([], true);
        this.$accuracy = new Stream(undefined, true);
        this.$labels = new Stream([], true);
        this.$selected = new Stream(null, true);
        this.$progress = new Stream(false, true);
        __classPrivateFieldSet(this, _ConfusionMatrix_prediction, prediction, "f");
        this.start();
        this.setup();
    }
    setup() {
        let predictions = [];
        __classPrivateFieldGet(this, _ConfusionMatrix_prediction, "f").$status.subscribe(async ({ status, count, total, data }) => {
            if (status === 'start') {
                predictions = [];
                this.$progress.set(null);
            }
            else if (status === 'running') {
                predictions.push(data);
                this.$progress.set(count / total);
            }
            else if (status === 'loaded') {
                predictions = await __classPrivateFieldGet(this, _ConfusionMatrix_prediction, "f").predictionService
                    .items()
                    .query({
                    $select: ['id', 'label', 'yTrue'],
                })
                    .toArray();
                this.$progress.set(false);
            }
            else if (status === 'loading') {
                predictions = [];
                this.$progress.set(null);
            }
            else {
                this.$progress.set(false);
            }
            this.updateConfusionMatrix(predictions);
            this.updateAccuracy(predictions);
        });
    }
    updateConfusionMatrix(predictions) {
        const labels = predictions.map((x) => x.label);
        const trueLabels = predictions.map((x) => x.yTrue);
        const uniqueLabels = Array.from(new Set(labels.concat(trueLabels)));
        if (!dequal(uniqueLabels, this.$labels.value)) {
            this.$labels.set(uniqueLabels);
        }
        const nLabels = uniqueLabels.length;
        const labIndices = uniqueLabels.reduce((x, l, i) => ({ ...x, [l]: i }), {});
        const confusion = Array.from(Array(nLabels ** 2), () => 0);
        for (let i = 0; i < labels.length; i += 1) {
            confusion[labIndices[labels[i]] * nLabels + labIndices[trueLabels[i]]] += 1;
        }
        const conf = confusion.map((v, i) => ({
            x: uniqueLabels[Math.floor(i / nLabels)],
            y: uniqueLabels[i % nLabels],
            v,
        }));
        this.$confusion.set(conf);
    }
    updateAccuracy(predictions) {
        if (predictions.length === 0) {
            this.$accuracy.set(undefined);
        }
        else {
            this.$accuracy.set(predictions.reduce((correct, { label, yTrue }) => correct + (label === yTrue ? 1 : 0), 0) /
                predictions.length);
        }
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Confusion_matrix_view({
            target: t,
            props: {
                title: this.title,
                loading: __classPrivateFieldGet(this, _ConfusionMatrix_prediction, "f").$status.map(({ status }) => status === 'loading'),
                progress: this.$progress,
                confusion: this.$confusion,
                accuracy: this.$accuracy,
                labels: this.$labels,
                selected: this.$selected,
            },
        });
    }
}
_ConfusionMatrix_prediction = new WeakMap();

function confusionMatrix(...args) {
    return new ConfusionMatrix(...args);
}

/* src/components/dataset-browser/dataset-browser.view.svelte generated by Svelte v3.52.0 */

const { window: window_1 } = globals;

function get_each_context$b(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[26] = list[i][0];
	child_ctx[27] = list[i][1].loaded;
	child_ctx[28] = list[i][1].total;
	child_ctx[29] = list[i][1].instances;
	return child_ctx;
}

function get_each_context_1$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[32] = list[i].id;
	child_ctx[33] = list[i].thumbnail;
	return child_ctx;
}

// (234:2) {#if classes && !dataStoreError}
function create_if_block_1$c(ctx) {
	let t;
	let div;
	let current;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*$count*/ ctx[6] > 0) return create_if_block_3$4;
		return create_else_block$f;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);
	let each_value = Object.entries(/*classes*/ ctx[5]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			if_block.c();
			t = space();
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "flex flex-wrap");
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, t, anchor);
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(div, "click", /*click_handler_2*/ ctx[18]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(t.parentNode, t);
				}
			}

			if (dirty[0] & /*loadMore, classes, $selected, selectInstance, onClassAction*/ 6560) {
				each_value = Object.entries(/*classes*/ ctx[5]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$b(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$b(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(t);
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};
}

// (237:4) {:else}
function create_else_block$f(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "This dataset is empty.";
			attr(p, "class", "ml-3 mt-2");
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (235:4) {#if $count > 0}
function create_if_block_3$4(ctx) {
	let p;
	let t0;
	let t1;
	let t2;
	let t3_value = (/*$count*/ ctx[6] > 1 ? 's' : '') + "";
	let t3;
	let t4;

	return {
		c() {
			p = element("p");
			t0 = text$1("This dataset contains ");
			t1 = text$1(/*$count*/ ctx[6]);
			t2 = text$1(" instance");
			t3 = text$1(t3_value);
			t4 = text$1(".");
			attr(p, "class", "ml-3 mt-2");
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t0);
			append(p, t1);
			append(p, t2);
			append(p, t3);
			append(p, t4);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$count*/ 64) set_data(t1, /*$count*/ ctx[6]);
			if (dirty[0] & /*$count*/ 64 && t3_value !== (t3_value = (/*$count*/ ctx[6] > 1 ? 's' : '') + "")) set_data(t3, t3_value);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (270:14) {#each instances as { id, thumbnail }
function create_each_block_1$3(key_1, ctx) {
	let img;
	let img_src_value;
	let img_intro;
	let img_outro;
	let current;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[16](/*id*/ ctx[32]);
	}

	return {
		key: key_1,
		first: null,
		c() {
			img = element("img");
			if (!src_url_equal(img.src, img_src_value = /*thumbnail*/ ctx[33])) attr(img, "src", img_src_value);
			attr(img, "alt", "thumbnail");
			attr(img, "class", "m-1 svelte-14ms951");
			toggle_class(img, "selected", /*$selected*/ ctx[7].includes(/*id*/ ctx[32]));
			this.first = img;
		},
		m(target, anchor) {
			insert(target, img, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(img, "click", stop_propagation(click_handler));
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (!current || dirty[0] & /*classes*/ 32 && !src_url_equal(img.src, img_src_value = /*thumbnail*/ ctx[33])) {
				attr(img, "src", img_src_value);
			}

			if (!current || dirty[0] & /*$selected, classes*/ 160) {
				toggle_class(img, "selected", /*$selected*/ ctx[7].includes(/*id*/ ctx[32]));
			}
		},
		i(local) {
			if (current) return;

			add_render_callback(() => {
				if (img_outro) img_outro.end(1);
				img_intro = create_in_transition(img, scale, {});
				img_intro.start();
			});

			current = true;
		},
		o(local) {
			if (img_intro) img_intro.invalidate();
			img_outro = create_out_transition(img, scale, {});
			current = false;
		},
		d(detaching) {
			if (detaching) detach(img);
			if (detaching && img_outro) img_outro.end();
			mounted = false;
			dispose();
		}
	};
}

// (284:12) {#if loaded < total}
function create_if_block_2$7(ctx) {
	let button;
	let current;

	function click_handler_1() {
		return /*click_handler_1*/ ctx[17](/*label*/ ctx[26]);
	}

	button = new Button$1({
			props: {
				size: "small",
				variant: "light",
				$$slots: { default: [create_default_slot_1$b] },
				$$scope: { ctx }
			}
		});

	button.$on("click", click_handler_1);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const button_changes = {};

			if (dirty[1] & /*$$scope*/ 32) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (285:14) <Button size="small" variant="light" on:click={() => loadMore(label)}>
function create_default_slot_1$b(ctx) {
	let t;

	return {
		c() {
			t = text$1("View More");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (242:6) {#each Object.entries(classes) as [label, { loaded, total, instances }
function create_each_block$b(ctx) {
	let div4;
	let div2;
	let div0;
	let span;
	let t0_value = /*label*/ ctx[26] + "";
	let t0;
	let t1;
	let popmenu;
	let t2;
	let div1;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t3;
	let div3;
	let t4;
	let current;

	function select_handler(...args) {
		return /*select_handler*/ ctx[15](/*label*/ ctx[26], ...args);
	}

	popmenu = new PopMenu({
			props: {
				actions: [
					{ code: 'edit', text: 'Edit class label' },
					{ code: 'delete', text: 'Delete class' }
				].concat(/*$selected*/ ctx[7].length > 0
				? [
						{
							code: 'deleteInstances',
							text: `Delete selected instance${/*$selected*/ ctx[7].length > 1 ? 's' : ''}`
						},
						{
							code: 'relabelInstances',
							text: `Relabel selected instance${/*$selected*/ ctx[7].length > 1 ? 's' : ''}`
						}
					]
				: [])
			}
		});

	popmenu.$on("select", select_handler);
	let each_value_1 = /*instances*/ ctx[29];
	const get_key = ctx => /*id*/ ctx[32];

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1$3(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$3(key, child_ctx));
	}

	let if_block = /*loaded*/ ctx[27] < /*total*/ ctx[28] && create_if_block_2$7(ctx);

	return {
		c() {
			div4 = element("div");
			div2 = element("div");
			div0 = element("div");
			span = element("span");
			t0 = text$1(t0_value);
			t1 = space();
			create_component(popmenu.$$.fragment);
			t2 = space();
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t3 = space();
			div3 = element("div");
			if (if_block) if_block.c();
			t4 = space();
			attr(span, "class", "browser-class-title svelte-14ms951");
			attr(div0, "class", "browser-class-header svelte-14ms951");
			attr(div1, "class", "browser-class-body svelte-14ms951");
			attr(div2, "class", "w-full");
			attr(div3, "class", "pb-1");
			attr(div4, "class", "browser-class svelte-14ms951");
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			append(div4, div2);
			append(div2, div0);
			append(div0, span);
			append(span, t0);
			append(div0, t1);
			mount_component(popmenu, div0, null);
			append(div2, t2);
			append(div2, div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			append(div4, t3);
			append(div4, div3);
			if (if_block) if_block.m(div3, null);
			append(div4, t4);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty[0] & /*classes*/ 32) && t0_value !== (t0_value = /*label*/ ctx[26] + "")) set_data(t0, t0_value);
			const popmenu_changes = {};

			if (dirty[0] & /*$selected*/ 128) popmenu_changes.actions = [
				{ code: 'edit', text: 'Edit class label' },
				{ code: 'delete', text: 'Delete class' }
			].concat(/*$selected*/ ctx[7].length > 0
			? [
					{
						code: 'deleteInstances',
						text: `Delete selected instance${/*$selected*/ ctx[7].length > 1 ? 's' : ''}`
					},
					{
						code: 'relabelInstances',
						text: `Relabel selected instance${/*$selected*/ ctx[7].length > 1 ? 's' : ''}`
					}
				]
			: []);

			popmenu.$set(popmenu_changes);

			if (dirty[0] & /*classes, $selected, selectInstance*/ 2208) {
				each_value_1 = /*instances*/ ctx[29];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, div1, outro_and_destroy_block, create_each_block_1$3, null, get_each_context_1$3);
				check_outros();
			}

			if (/*loaded*/ ctx[27] < /*total*/ ctx[28]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*classes*/ 32) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2$7(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div3, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(popmenu.$$.fragment, local);

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(popmenu.$$.fragment, local);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div4);
			destroy_component(popmenu);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (if_block) if_block.d();
		}
	};
}

// (294:2) {#if dataStoreError}
function create_if_block$o(ctx) {
	let div1;

	return {
		c() {
			div1 = element("div");

			div1.innerHTML = `<svg class="inline flex-shrink-0 mr-3 w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg> 
      <div><span class="font-medium">Data Store connection Error!</span> This data store probably requires
        authentication</div>`;

			attr(div1, "class", "flex p-4 mb-4 text-sm text-red-700 bg-red-100 rounded-lg dark:bg-red-200 dark:text-red-800");
			attr(div1, "role", "alert");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
		},
		d(detaching) {
			if (detaching) detach(div1);
		}
	};
}

// (233:0) <ViewContainer {title} {loading}>
function create_default_slot$s(ctx) {
	let t;
	let if_block1_anchor;
	let current;
	let if_block0 = /*classes*/ ctx[5] && !/*dataStoreError*/ ctx[4] && create_if_block_1$c(ctx);
	let if_block1 = /*dataStoreError*/ ctx[4] && create_if_block$o();

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*classes*/ ctx[5] && !/*dataStoreError*/ ctx[4]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*classes, dataStoreError*/ 48) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$c(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*dataStoreError*/ ctx[4]) {
				if (if_block1) ; else {
					if_block1 = create_if_block$o();
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

function create_fragment$D(ctx) {
	let viewcontainer;
	let current;
	let mounted;
	let dispose;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				loading: /*loading*/ ctx[3],
				$$slots: { default: [create_default_slot$s] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen(window_1, "keydown", /*handleKeydown*/ ctx[9]),
					listen(window_1, "keyup", /*handleKeyup*/ ctx[10])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			const viewcontainer_changes = {};
			if (dirty[0] & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];
			if (dirty[0] & /*loading*/ 8) viewcontainer_changes.loading = /*loading*/ ctx[3];

			if (dirty[0] & /*dataStoreError, classes, $selected, $count*/ 240 | dirty[1] & /*$$scope*/ 32) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$D($$self, $$props, $$invalidate) {
	let $count,
		$$unsubscribe_count = noop$1,
		$$subscribe_count = () => ($$unsubscribe_count(), $$unsubscribe_count = subscribe(count, $$value => $$invalidate(6, $count = $$value)), count);

	let $selected,
		$$unsubscribe_selected = noop$1,
		$$subscribe_selected = () => ($$unsubscribe_selected(), $$unsubscribe_selected = subscribe(selected, $$value => $$invalidate(7, $selected = $$value)), selected);

	$$self.$$.on_destroy.push(() => $$unsubscribe_count());
	$$self.$$.on_destroy.push(() => $$unsubscribe_selected());
	let { title } = $$props;
	let { batchSize } = $$props;
	let { count } = $$props;
	$$subscribe_count();
	let { dataset } = $$props;
	let { selected } = $$props;
	$$subscribe_selected();
	let loading = false;
	let dataStoreError = false;
	let classes = {};

	async function loadMore(label) {
		await dataset.ready;

		for await (const instance of dataset.items().query({ y: label, $sort: { updatedAt: -1 } }).skip(classes[label].loaded).take(batchSize).select(['id', 'y', 'thumbnail'])) {
			$$invalidate(5, classes[label].instances = [...classes[label].instances, instance], classes);
			$$invalidate(5, classes[label].loaded += 1, classes);
		}
	}

	async function updateClassesFromDataset() {
		if (loading) return;
		$$invalidate(3, loading = true);

		try {
			$$invalidate(4, dataStoreError = false);
			await dataset.ready;
		} catch(e) {
			$$invalidate(3, loading = false);
			$$invalidate(4, dataStoreError = true);
			return;
		}

		const labels = await dataset.distinct('y');

		$$invalidate(5, classes = labels.reduce(
			(x, lab) => ({
				...x,
				[lab]: { total: 0, loaded: 0, instances: [] }
			}),
			{}
		));

		for (const label of labels) {
			const { total } = await dataset.find({ query: { $limit: 0, y: label } });
			$$invalidate(5, classes[label].total = total, classes);

			if (batchSize > 0) {
				await loadMore(label);
			} else {
				while (classes[label].loaded < classes[label].total) {
					await loadMore(label);
				}
			}
		}

		$$invalidate(3, loading = false);
	}

	function getLabel(id) {
		for (const [label, { instances }] of Object.entries(classes)) {
			if (instances.map(x => x.id).includes(id)) {
				return label;
			}
		}

		return null;
	}

	async function deleteSelectedInstances() {
		let p = Promise.resolve();

		for (const id of selected.get()) {
			// eslint-disable-next-line no-loop-func
			p = p.then(() => dataset.remove(id));
		}

		await p;
		selected.set([]);
	}

	async function relabelSelectedInstances(newLabel) {
		let p = Promise.resolve();

		for (const id of selected.get()) {
			// eslint-disable-next-line no-loop-func
			p = p.then(() => dataset.patch(id, { y: newLabel }));
		}

		await p;
		selected.set([]);
	}

	let metaPressed = false;
	let shiftPressed = false;

	function handleKeydown(event) {
		if (['Meta', 'Control'].includes(event.key)) {
			metaPressed = true;
		} else if (event.key === 'Shift') {
			shiftPressed = true;
		} else if (event.key === 'Delete' || event.key === 'Backspace' && metaPressed) {
			deleteSelectedInstances();
		}
	}

	function handleKeyup(event) {
		if (['Meta', 'Control'].includes(event.key)) {
			metaPressed = false;
		} else if (event.key === 'Shift') {
			shiftPressed = false;
		}
	}

	let initialId = null;

	function selectInstance(id) {
		if (metaPressed) {
			if (!id) return;

			if (selected.get().includes(id)) {
				selected.set(selected.get().filter(x => x !== id));
			} else {
				selected.set(selected.get().concat([id]));
			}
		} else if (shiftPressed) {
			if (!initialId || !id) return;
			const srcLabel = getLabel(initialId);
			const dstLabel = getLabel(id);
			if (srcLabel !== dstLabel) return;
			const instances = classes[srcLabel].instances.map(x => x.id);
			const srcIndex = instances.indexOf(initialId);
			const dstIndex = instances.indexOf(id);

			selected.set(srcIndex < dstIndex
			? instances.slice(srcIndex, dstIndex + 1)
			: instances.slice(dstIndex, srcIndex + 1));
		} else {
			selected.set(id ? [id] : []);
			initialId = id;
		}
	}

	function onClassAction(label, code) {
		let result;

		switch (code) {
			case 'edit':
				// eslint-disable-next-line no-alert
				result = window.prompt('Enter the new label', label);
				if (result) {
					dataset.patch(null, { y: result }, { query: { y: label } });
				}
				break;
			case 'delete':
				dataset.remove(null, { query: { y: label } });
				break;
			case 'deleteInstances':
				deleteSelectedInstances();
				break;
			case 'relabelInstances':
				// eslint-disable-next-line no-alert
				result = window.prompt('Enter the new label', label);
				if (result) {
					relabelSelectedInstances(result);
				}
				break;
			default:
				// eslint-disable-next-line no-alert
				alert(`Class ${label}: ${code}`);
				break;
		}
	}

	onMount(() => {
		updateClassesFromDataset();

		dataset.$changes.subscribe(async changes => {
			for (const { level, type, data } of changes) {
				if (level === 'dataset') {
					if (type === 'created') {
						selectInstance();
						updateClassesFromDataset();
					}
				} else if (level === 'instance') {
					if (type === 'created') {
						if (!classes[data.y]) {
							$$invalidate(5, classes[data.y] = { total: 0, loaded: 0, instances: [] }, classes);
						}

						$$invalidate(5, classes[data.y].total += 1, classes);
						$$invalidate(5, classes[data.y].loaded += 1, classes);

						$$invalidate(
							5,
							classes[data.y].instances = [
								{
									id: data.id,
									y: data.y,
									thumbnail: data.thumbnail
								},
								...classes[data.y].instances
							],
							classes
						);
					} else if (type === 'updated') {
						// TODO: what if the image is not displayed?
						const originalLabel = getLabel(data.id);

						$$invalidate(5, classes[originalLabel].total -= 1, classes);
						$$invalidate(5, classes[originalLabel].loaded -= 1, classes);
						$$invalidate(5, classes[originalLabel].instances = classes[originalLabel].instances.filter(({ id }) => id !== data.id), classes);

						if (classes[originalLabel].total === 0) {
							delete classes[originalLabel];
							$$invalidate(5, classes);
						}

						if (!classes[data.y]) {
							$$invalidate(5, classes[data.y] = { total: 0, loaded: 0, instances: [] }, classes);
						}

						$$invalidate(
							5,
							classes[data.y].instances = [
								{
									id: data.id,
									y: data.y,
									thumbnail: data.thumbnail
								},
								...classes[data.y].instances
							],
							classes
						);
					} else if (type === 'removed') {
						$$invalidate(5, classes[data.y].total -= 1, classes);
						$$invalidate(5, classes[data.y].loaded -= 1, classes);
						$$invalidate(5, classes[data.y].instances = classes[data.y].instances.filter(({ id }) => id !== data.id), classes);

						if (classes[data.y].total === 0) {
							delete classes[data.y];
							$$invalidate(5, classes);
						}
					}
				}
			}
		});
	});

	const select_handler = (label, e) => onClassAction(label, e.detail);
	const click_handler = id => selectInstance(id);
	const click_handler_1 = label => loadMore(label);
	const click_handler_2 = () => selectInstance();

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('batchSize' in $$props) $$invalidate(13, batchSize = $$props.batchSize);
		if ('count' in $$props) $$subscribe_count($$invalidate(1, count = $$props.count));
		if ('dataset' in $$props) $$invalidate(14, dataset = $$props.dataset);
		if ('selected' in $$props) $$subscribe_selected($$invalidate(2, selected = $$props.selected));
	};

	return [
		title,
		count,
		selected,
		loading,
		dataStoreError,
		classes,
		$count,
		$selected,
		loadMore,
		handleKeydown,
		handleKeyup,
		selectInstance,
		onClassAction,
		batchSize,
		dataset,
		select_handler,
		click_handler,
		click_handler_1,
		click_handler_2
	];
}

class Dataset_browser_view extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$D,
			create_fragment$D,
			safe_not_equal,
			{
				title: 0,
				batchSize: 13,
				count: 1,
				dataset: 14,
				selected: 2
			},
			null,
			[-1, -1]
		);
	}
}

var _DatasetBrowser_dataset;
class DatasetBrowser extends Component {
    constructor(dataset, { batchSize = 6 } = {}) {
        super();
        this.title = 'dataset browser';
        _DatasetBrowser_dataset.set(this, void 0);
        this.$selected = new Stream([], true);
        __classPrivateFieldSet(this, _DatasetBrowser_dataset, dataset, "f");
        this.batchSize = batchSize;
        this.start();
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Dataset_browser_view({
            target: t,
            props: {
                title: this.title,
                batchSize: this.batchSize,
                count: __classPrivateFieldGet(this, _DatasetBrowser_dataset, "f").$count,
                dataset: __classPrivateFieldGet(this, _DatasetBrowser_dataset, "f"),
                selected: this.$selected,
            },
        });
    }
}
_DatasetBrowser_dataset = new WeakMap();

function datasetBrowser(...args) {
    return new DatasetBrowser(...args);
}

/* src/components/dataset-scatter/dataset-scatter.view.svelte generated by Svelte v3.52.0 */

function create_default_slot_1$a(ctx) {
	let t;

	return {
		c() {
			t = text$1("Reset Zoom");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (138:0) <ViewContainer {title}>
function create_default_slot$r(ctx) {
	let div0;
	let canvas;
	let t;
	let div1;
	let button;
	let current;

	button = new Button$1({
			props: {
				size: "small",
				$$slots: { default: [create_default_slot_1$a] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*click_handler*/ ctx[8]);

	return {
		c() {
			div0 = element("div");
			canvas = element("canvas");
			t = space();
			div1 = element("div");
			create_component(button.$$.fragment);
			attr(div0, "id", "scatter-container");
			attr(div0, "class", "svelte-ei9k3k");
			attr(div1, "class", "flex justify-end");
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			append(div0, canvas);
			/*canvas_binding*/ ctx[7](canvas);
			insert(target, t, anchor);
			insert(target, div1, anchor);
			mount_component(button, div1, null);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 8192) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div0);
			/*canvas_binding*/ ctx[7](null);
			if (detaching) detach(t);
			if (detaching) detach(div1);
			destroy_component(button);
		}
	};
}

function create_fragment$C(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				$$slots: { default: [create_default_slot$r] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];

			if (dirty & /*$$scope, chart, canvasElement*/ 8198) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$C($$self, $$props, $$invalidate) {
	Chart.register(Filler, Legend, LineElement, LinearScale, PointElement, ScatterController, Title, Tooltip);
	Chart.register(zoomPlugin);
	let { title } = $$props;
	let { data } = $$props;
	let { hovered } = $$props;
	let { clicked } = $$props;

	const getOrCreateTooltip = chart => {
		let tooltipEl = chart.canvas.parentNode.querySelector('div');

		if (!tooltipEl) {
			tooltipEl = document.createElement('div');
			tooltipEl.style.background = 'transparent';
			tooltipEl.style.borderRadius = '3px';
			tooltipEl.style.color = 'white';
			tooltipEl.style.opacity = 1;
			tooltipEl.style.pointerEvents = 'none';
			tooltipEl.style.position = 'absolute';
			tooltipEl.style.transform = 'translate(-50%, 0)';
			tooltipEl.style.transition = 'all .1s ease';
			const img = document.createElement('img');
			img.style.borderRadius = '4px';
			img.style.margin = '0px';
			img.width = 100;
			img.height = 100;
			tooltipEl.appendChild(img);
			chart.canvas.parentNode.appendChild(tooltipEl);
		}

		return tooltipEl;
	};

	function externalTooltipHandler(context) {
		// Tooltip Element
		const { chart, tooltip } = context;

		const tooltipEl = getOrCreateTooltip(chart);

		// Hide if no tooltip
		if (tooltip.opacity === 0) {
			tooltipEl.style.opacity = 0;
			return;
		}

		const img = tooltipEl.querySelector('img');
		img.src = tooltip.dataPoints[0].raw.thumbnail;
		const { offsetLeft: positionX, offsetTop: positionY } = chart.canvas;

		// Display, position, and set styles for font
		tooltipEl.style.opacity = 1;

		tooltipEl.style.left = positionX + tooltip.caretX + 70 + 'px';
		tooltipEl.style.top = positionY + tooltip.caretY + 20 + 'px';
		tooltipEl.style.font = tooltip.options.bodyFont.string;
		tooltipEl.style.padding = tooltip.options.padding + 'px ' + tooltip.options.padding + 'px';
	}

	const defaultOptions = {
		type: 'scatter',
		data: { labels: [], datasets: [] },
		options: {
			responsive: true,
			maintainAspectRatio: false,
			animation: { duration: 200 },
			scales: {
				y: {
					position: 'center',
					ticks: { display: false }
				},
				x: {
					position: 'center',
					ticks: { display: false }
				}
			},
			elements: {
				point: {
					radius: 8,
					hoverRadius: 10,
					borderWidth: 0,
					hoverBorderWidth: 3
				}
			},
			plugins: {
				legend: { position: 'top' },
				tooltip: {
					enabled: false,
					position: 'nearest',
					external: externalTooltipHandler
				},
				zoom: {
					zoom: {
						wheel: { enabled: true }, // modifierKey: 'ctrl',
						pinch: { enabled: true },
						mode: 'xy'
					},
					pan: {
						enabled: true,
						// modifierKey: 'ctrl',
						mode: 'xy'
					}
				}
			},
			onClick(e, elts) {
				clicked.set(elts.map(({ element }) => element)); // clicked.set(elts.map(({ element }) => element?.$context?.raw?.id));
			}, // clicked.set(elts.map(({ element }) => element?.$context?.raw?.id));
			onHover(e, elts) {
				const ids = elts.map(({ element }) => {
					var _a, _b;

					return (_b = (_a = element === null || element === void 0
					? void 0
					: element.$context) === null || _a === void 0
					? void 0
					: _a.raw) === null || _b === void 0
					? void 0
					: _b.id;
				});

				if (!dequal(ids, hovered.get())) hovered.set(ids);
			}
		}
	};

	let chart;

	// eslint-disable-next-line @typescript-eslint/no-empty-function
	let unSub = () => {
		
	};

	let canvasElement;

	async function setup() {
		unSub();
		const chartOptions = { ...defaultOptions, data: data.get() };

		unSub = data.filter(x => !!x).subscribe(d => {
			chartOptions.data = d;
			chart.update();
			chart.resetZoom();
		});

		const ctx = canvasElement.getContext('2d');
		$$invalidate(1, chart = new Chart(ctx, chartOptions));
	}

	onMount(async () => {
		await tick();
		await tick();
		setup();
	});

	onDestroy(() => {
		unSub();

		chart === null || chart === void 0
		? void 0
		: chart.destroy();
	});

	function canvas_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			canvasElement = $$value;
			$$invalidate(2, canvasElement);
		});
	}

	const click_handler = () => chart.resetZoom();

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('data' in $$props) $$invalidate(3, data = $$props.data);
		if ('hovered' in $$props) $$invalidate(4, hovered = $$props.hovered);
		if ('clicked' in $$props) $$invalidate(5, clicked = $$props.clicked);
	};

	return [
		title,
		chart,
		canvasElement,
		data,
		hovered,
		clicked,
		externalTooltipHandler,
		canvas_binding,
		click_handler
	];
}

class Dataset_scatter_view extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$C, create_fragment$C, safe_not_equal, {
			title: 0,
			data: 3,
			hovered: 4,
			clicked: 5,
			externalTooltipHandler: 6
		});
	}

	get externalTooltipHandler() {
		return this.$$.ctx[6];
	}
}

const defaultColors = [
    'rgb(54, 162, 235)',
    'rgb(255, 99, 132)',
    'rgb(255, 206, 86)',
    'rgb(75, 192, 192)',
    'rgb(153, 102, 255)',
    'rgb(255, 159, 64)',
];
class DatasetScatter extends Component {
    constructor(dataset) {
        super();
        this.dataset = dataset;
        this.title = 'Dataset ScatterPlot';
        this.transforms = {
            xy: (value) => [value.x[0], value.x[1]],
            label: (value) => value.y,
        };
        this.$data = new Stream(undefined, true);
        this.$hovered = new Stream([], true);
        this.$clicked = new Stream([], true);
        this.dataset.ready.then(() => {
            this.updateData();
        });
    }
    setTransforms(t) {
        this.transforms = { ...this.transforms, ...t };
        this.updateData();
    }
    async updateData() {
        await this.dataset.ready;
        const values = await Promise.all(await this.dataset
            .items()
            .map(async (instance) => {
            const [x, y] = await this.transforms.xy(instance);
            const label = await this.transforms.label(instance);
            return {
                x,
                y,
                label,
                id: instance.id,
                thumbnail: instance.thumbnail,
            };
        })
            .toArray());
        const labels = values.map((x) => x.label);
        const uniqueLabels = Array.from(new Set(labels));
        uniqueLabels.sort();
        const data = {
            labels,
            datasets: uniqueLabels.map((label, i) => ({
                label: label,
                data: values.filter((v) => v.label === label),
                borderColor: colorLib(defaultColors[i]).darken(0.5).rgbString(),
                backgroundColor: defaultColors[i],
            })),
        };
        this.$data.set(data);
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Dataset_scatter_view({
            target: t,
            props: {
                title: this.title,
                data: this.$data,
                hovered: this.$hovered,
                clicked: this.$clicked,
            },
        });
    }
}

function datasetScatter(...args) {
    return new DatasetScatter(...args);
}

/* src/components/dataset-table/dataset-table.view.svelte generated by Svelte v3.52.0 */

function create_catch_block$1(ctx) {
	return {
		c: noop$1,
		m: noop$1,
		p: noop$1,
		i: noop$1,
		o: noop$1,
		d: noop$1
	};
}

// (71:2) {:then _}
function create_then_block$1(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*provider*/ ctx[5] && create_if_block$n(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*provider*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*provider*/ 32) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$n(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (72:4) {#if provider}
function create_if_block$n(ctx) {
	let table;
	let current;

	table = new Table({
			props: {
				provider: /*provider*/ ctx[5],
				columns: /*columns*/ ctx[4],
				singleSelection: /*singleSelection*/ ctx[2],
				actions: [{ name: 'delete' }]
			}
		});

	table.$on("selection", /*selection_handler*/ ctx[7]);

	return {
		c() {
			create_component(table.$$.fragment);
		},
		m(target, anchor) {
			mount_component(table, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const table_changes = {};
			if (dirty & /*provider*/ 32) table_changes.provider = /*provider*/ ctx[5];
			if (dirty & /*columns*/ 16) table_changes.columns = /*columns*/ ctx[4];
			if (dirty & /*singleSelection*/ 4) table_changes.singleSelection = /*singleSelection*/ ctx[2];
			table.$set(table_changes);
		},
		i(local) {
			if (current) return;
			transition_in(table.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(table.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(table, detaching);
		}
	};
}

// (69:24)      <Spinner />   {:then _}
function create_pending_block$1(ctx) {
	let spinner;
	let current;
	spinner = new Spinner({});

	return {
		c() {
			create_component(spinner.$$.fragment);
		},
		m(target, anchor) {
			mount_component(spinner, target, anchor);
			current = true;
		},
		p: noop$1,
		i(local) {
			if (current) return;
			transition_in(spinner.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(spinner.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(spinner, detaching);
		}
	};
}

// (68:0) <ViewContainer {title}>
function create_default_slot$q(ctx) {
	let await_block_anchor;
	let promise;
	let current;

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: false,
		pending: create_pending_block$1,
		then: create_then_block$1,
		catch: create_catch_block$1,
		value: 8,
		blocks: [,,,]
	};

	handle_promise(promise = /*dataset*/ ctx[1].ready, info);

	return {
		c() {
			await_block_anchor = empty();
			info.block.c();
		},
		m(target, anchor) {
			insert(target, await_block_anchor, anchor);
			info.block.m(target, info.anchor = anchor);
			info.mount = () => await_block_anchor.parentNode;
			info.anchor = await_block_anchor;
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			info.ctx = ctx;

			if (dirty & /*dataset*/ 2 && promise !== (promise = /*dataset*/ ctx[1].ready) && handle_promise(promise, info)) ; else {
				update_await_block_branch(info, ctx, dirty);
			}
		},
		i(local) {
			if (current) return;
			transition_in(info.block);
			current = true;
		},
		o(local) {
			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				transition_out(block);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(await_block_anchor);
			info.block.d(detaching);
			info.token = null;
			info = null;
		}
	};
}

function create_fragment$B(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				$$slots: { default: [create_default_slot$q] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];

			if (dirty & /*$$scope, dataset, provider, columns, singleSelection, selection*/ 574) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function getType(x) {
	if (typeof x === 'string' && x.includes('data:image/')) {
		return 'image';
	}

	if (typeof x === 'string' && !isNaN(Date.parse(x))) {
		return 'date';
	}

	if (Array.isArray(x)) {
		if (x.length > 1 && Array.isArray(x[0]) || x.length > 3) {
			return 'array';
		}
	}

	return 'generic';
}

function isSortable(x) {
	if (getType(x) !== 'image') {
		return true;
	}

	return false;
}

function instance$B($$self, $$props, $$invalidate) {
	let { title } = $$props;
	let { dataset } = $$props;
	let { colNames } = $$props;
	let { singleSelection = false } = $$props;
	let { selection } = $$props;

	let columns = [
		{ name: 'x' },
		{ name: 'y', sortable: true },
		{ name: 'thumbnail', type: 'image' },
		{ name: 'updatedAt', sortable: true }
	];

	let provider;

	onMount(async () => {
		await tick();
		await dataset.ready;

		$$invalidate(5, provider = new TableServiceProvider({
				service: dataset.instanceService,
				columns
			}));

		colNames.subscribe(async cols => {
			$$invalidate(4, columns = cols.map(name => ({ name })));

			if (dataset.$count.get() > 0) {
				const [firstInstance] = await dataset.items().take(1).toArray();

				$$invalidate(4, columns = columns.map(({ name }) => ({
					name,
					type: getType(firstInstance[name]),
					sortable: isSortable(firstInstance[name])
				})));
			}

			$$invalidate(5, provider.query.$select = columns.map(x => x.name).concat(['id']), provider);
			provider.update();
		});

		const unSub = dataset.$count.subscribe(async c => {
			if (c > 0) {
				const [firstInstance] = await dataset.items().take(1).toArray();

				$$invalidate(4, columns = columns.map(({ name }) => ({
					name,
					type: getType(firstInstance[name]),
					sortable: isSortable(firstInstance[name])
				})));

				unSub();
			}
		});
	});

	const selection_handler = ({ detail }) => {
		selection.set(detail);
	};

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('dataset' in $$props) $$invalidate(1, dataset = $$props.dataset);
		if ('colNames' in $$props) $$invalidate(6, colNames = $$props.colNames);
		if ('singleSelection' in $$props) $$invalidate(2, singleSelection = $$props.singleSelection);
		if ('selection' in $$props) $$invalidate(3, selection = $$props.selection);
	};

	return [
		title,
		dataset,
		singleSelection,
		selection,
		columns,
		provider,
		colNames,
		selection_handler
	];
}

class Dataset_table_view extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$B, create_fragment$B, safe_not_equal, {
			title: 0,
			dataset: 1,
			colNames: 6,
			singleSelection: 2,
			selection: 3
		});
	}
}

var _DatasetTable_dataset;
class DatasetTable extends Component {
    constructor(dataset, columns, singleSelection = false) {
        super();
        this.title = 'dataset table';
        _DatasetTable_dataset.set(this, void 0);
        this.$selection = new Stream([], true);
        this.singleSelection = false;
        __classPrivateFieldSet(this, _DatasetTable_dataset, dataset, "f");
        this.singleSelection = singleSelection;
        this.$columns = new Stream(columns || ['x', 'y', 'thumbnail', 'updatedAt'], true);
        if (!columns) {
            __classPrivateFieldGet(this, _DatasetTable_dataset, "f").ready
                .then(() => __classPrivateFieldGet(this, _DatasetTable_dataset, "f").items().take(1).toArray())
                .then((res) => {
                if (res.length > 0) {
                    const cols = Object.keys(res[0]);
                    this.$columns.set(cols);
                }
            })
                .catch((error) => {
                // eslint-disable-next-line no-console
                console.log('An error occured while fetching the first instance.', error);
            });
        }
        this.start();
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Dataset_table_view({
            target: t,
            props: {
                title: this.title,
                dataset: __classPrivateFieldGet(this, _DatasetTable_dataset, "f"),
                colNames: this.$columns,
                singleSelection: this.singleSelection,
                selection: this.$selection,
            },
        });
    }
}
_DatasetTable_dataset = new WeakMap();

function datasetTable(dataset, columns) {
    return new DatasetTable(dataset, columns);
}

/* src/components/detection-boxes/detection-boxes.view.svelte generated by Svelte v3.52.0 */

function create_default_slot$p(ctx) {
	let canvas;

	return {
		c() {
			canvas = element("canvas");
			attr(canvas, "id", "can");
			attr(canvas, "class", "w-full max-w-full");
		},
		m(target, anchor) {
			insert(target, canvas, anchor);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(canvas);
		}
	};
}

function create_fragment$A(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				$$slots: { default: [create_default_slot$p] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];

			if (dirty & /*$$scope*/ 8) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$A($$self, $$props, $$invalidate) {
	let { title } = $$props;
	let { imageStream } = $$props;
	let { objectDetectionResults } = $$props;

	onMount(() => {
		const mycan = document.getElementById('can');
		const ctx = mycan.getContext('2d');

		imageStream.subscribe(img => {
			mycan.height = img.height;
			mycan.width = img.width;
			ctx.putImageData(img, 0, 0);
		});

		objectDetectionResults.subscribe(({ outputs }) => {
			for (let i = 0; i < outputs.length; i++) {
				ctx.font = `${Math.floor(mycan.width / 60)}px sans-serif`;
				const msg = `${outputs[i].confidence.toFixed(3)} ${outputs[i].class}`;
				const textSize = ctx.measureText(msg);
				ctx.beginPath();
				ctx.rect(...outputs[i].bbox);
				ctx.lineWidth = mycan.width / 300;
				ctx.strokeStyle = 'green';
				ctx.fillStyle = 'green';
				ctx.stroke();

				ctx.fillRect(
					outputs[i].bbox[0] - ctx.lineWidth / 2,
					outputs[i].bbox[1] > textSize.actualBoundingBoxAscent
					? outputs[i].bbox[1] - textSize.actualBoundingBoxAscent - 1.5 * ctx.lineWidth
					: 0,
					textSize.width + ctx.lineWidth,
					textSize.actualBoundingBoxAscent + ctx.lineWidth
				);

				ctx.fillStyle = 'white';

				ctx.fillText(msg, outputs[i].bbox[0], outputs[i].bbox[1] > textSize.actualBoundingBoxAscent
				? outputs[i].bbox[1] - ctx.lineWidth
				: textSize.actualBoundingBoxAscent);
			}
		});
	});

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('imageStream' in $$props) $$invalidate(1, imageStream = $$props.imageStream);
		if ('objectDetectionResults' in $$props) $$invalidate(2, objectDetectionResults = $$props.objectDetectionResults);
	};

	return [title, imageStream, objectDetectionResults];
}

class Detection_boxes_view extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$A, create_fragment$A, safe_not_equal, {
			title: 0,
			imageStream: 1,
			objectDetectionResults: 2
		});
	}
}

class DetectionBoxes extends Component {
    constructor(imgStream, objDectectionRes) {
        super();
        this.title = 'Visualize Object Detections';
        this.$imgStream = imgStream;
        this.$objectDetectionResults = objDectectionRes;
        this.start();
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Detection_boxes_view({
            target: t,
            props: {
                title: this.title,
                imageStream: this.$imgStream,
                objectDetectionResults: this.$objectDetectionResults,
            },
        });
    }
}

function detectionBoxes(...args) {
    return new DetectionBoxes(...args);
}

/* src/components/file-upload/file-upload.view.svelte generated by Svelte v3.52.0 */

function create_if_block$m(ctx) {
	let div;

	return {
		c() {
			div = element("div");

			div.innerHTML = `<i><svg class="fill-current w-12 h-12 mb-3 text-blue-700" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M19.479 10.092c-.212-3.951-3.473-7.092-7.479-7.092-4.005 0-7.267 3.141-7.479 7.092-2.57.463-4.521 2.706-4.521 5.408 0 3.037 2.463 5.5 5.5 5.5h13c3.037 0 5.5-2.463 5.5-5.5 0-2.702-1.951-4.945-4.521-5.408zm-7.479-1.092l4 4h-3v4h-2v-4h-3l4-4z"></path></svg></i> 
      <p class="text-lg text-blue-700">Drop files to upload</p>`;

			attr(div, "class", "overlay svelte-10fctvd");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (90:6) <Button on:click={clickUpload}>
function create_default_slot_1$9(ctx) {
	let t;

	return {
		c() {
			t = text$1("Upload a file");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (56:0) <ViewContainer {title}>
function create_default_slot$o(ctx) {
	let t0;
	let div1;
	let div0;
	let p;
	let t2;
	let input;
	let t3;
	let button;
	let current;
	let mounted;
	let dispose;
	let if_block = /*draggedOver*/ ctx[2] && create_if_block$m();

	button = new Button$1({
			props: {
				$$slots: { default: [create_default_slot_1$9] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*clickUpload*/ ctx[7]);

	return {
		c() {
			if (if_block) if_block.c();
			t0 = space();
			div1 = element("div");
			div0 = element("div");
			p = element("p");
			p.innerHTML = `<span>Drop Files here or:</span>`;
			t2 = space();
			input = element("input");
			t3 = space();
			create_component(button.$$.fragment);
			attr(p, "class", "mb-3 font-semibold text-gray-900 flex flex-wrap justify-center");
			attr(input, "type", "file");
			input.multiple = true;
			attr(input, "class", "hidden");
			attr(div0, "class", "border-dashed border-2 border-gray-300 py-8 flex flex-col justify-center items-center");
			attr(div1, "class", "file-upload svelte-10fctvd");
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, p);
			append(div0, t2);
			append(div0, input);
			/*input_binding*/ ctx[9](input);
			append(div0, t3);
			mount_component(button, div0, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div1, "dragenter", /*handleDragEnter*/ ctx[3]),
					listen(div1, "dragleave", /*handleDragLeave*/ ctx[4]),
					listen(div1, "dragover", /*handleDragOver*/ ctx[5]),
					listen(div1, "drop", /*handleDragDrop*/ ctx[6])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*draggedOver*/ ctx[2]) {
				if (if_block) ; else {
					if_block = create_if_block$m();
					if_block.c();
					if_block.m(t0.parentNode, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			const button_changes = {};

			if (dirty & /*$$scope*/ 8192) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(div1);
			/*input_binding*/ ctx[9](null);
			destroy_component(button);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$z(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				$$slots: { default: [create_default_slot$o] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];

			if (dirty & /*$$scope, uploadInput, draggedOver*/ 8198) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$z($$self, $$props, $$invalidate) {
	let { title } = $$props;
	let { fileStream } = $$props;
	let uploadInput;
	let counter = 0;
	let draggedOver = false;

	// use to check if a file is being dragged
	const hasFiles = ({ dataTransfer: { types = [] } }) => types.indexOf('Files') > -1;

	function handleDragEnter(e) {
		e.preventDefault();

		if (!hasFiles(e)) {
			return;
		}

		counter += 1;
		$$invalidate(2, draggedOver = true);
	}

	function handleDragLeave() {
		counter -= 1;

		if (counter < 1) {
			$$invalidate(2, draggedOver = false);
		}
	}

	function handleDragOver(e) {
		if (hasFiles(e)) {
			e.preventDefault();
		}
	}

	function processFiles(f) {
		const files = [];

		for (let i = 0; i < f.length; i++) {
			files.push(f[i]);
		}

		fileStream.set(files);
	}

	function handleDragDrop(e) {
		e.preventDefault();
		$$invalidate(2, draggedOver = false);
		processFiles(e.dataTransfer.files);
	}

	onMount(async () => {
		await tick();
		await tick();

		uploadInput.addEventListener('change', e => {
			processFiles(e.target.files);
		});
	});

	function clickUpload() {
		if (uploadInput) {
			uploadInput.click();
		}
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			uploadInput = $$value;
			$$invalidate(1, uploadInput);
		});
	}

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('fileStream' in $$props) $$invalidate(8, fileStream = $$props.fileStream);
	};

	return [
		title,
		uploadInput,
		draggedOver,
		handleDragEnter,
		handleDragLeave,
		handleDragOver,
		handleDragDrop,
		clickUpload,
		fileStream,
		input_binding
	];
}

class File_upload_view extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$z, create_fragment$z, safe_not_equal, { title: 0, fileStream: 8 });
	}
}

class FileUpload extends Component {
    constructor() {
        super();
        this.title = 'file upload';
        this.$files = new Stream(never());
        this.start();
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new File_upload_view({
            target: t,
            props: {
                title: this.title,
                fileStream: this.$files,
            },
        });
    }
}

function fileUpload(...args) {
    return new FileUpload(...args);
}

/* src/components/image-display/image-display.view.svelte generated by Svelte v3.52.0 */

function create_default_slot$n(ctx) {
	let canvas_1;

	return {
		c() {
			canvas_1 = element("canvas");
			attr(canvas_1, "class", "w-full max-w-full");
		},
		m(target, anchor) {
			insert(target, canvas_1, anchor);
			/*canvas_1_binding*/ ctx[3](canvas_1);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(canvas_1);
			/*canvas_1_binding*/ ctx[3](null);
		}
	};
}

function create_fragment$y(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				$$slots: { default: [create_default_slot$n] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];

			if (dirty & /*$$scope, canvas*/ 34) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$y($$self, $$props, $$invalidate) {
	let { title } = $$props;
	let { imageStream } = $$props;
	let canvas;
	let unSub = noop;

	onMount(async () => {
		await tick();
		await tick();
		const ctx = canvas.getContext('2d');

		unSub = imageStream.subscribe(img => {
			if (Array.isArray(img) && img.length === 0) return;

			if (img instanceof ImageData) {
				$$invalidate(1, canvas.width = img.width, canvas);
				$$invalidate(1, canvas.height = img.height, canvas);
				ctx.putImageData(img, 0, 0);
			} else if (Array.isArray(img)) {
				throw new Error('This component does not yet support multiple images');
			}
		});
	});

	onDestroy(() => {
		unSub();
	});

	function canvas_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			canvas = $$value;
			$$invalidate(1, canvas);
		});
	}

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('imageStream' in $$props) $$invalidate(2, imageStream = $$props.imageStream);
	};

	return [title, canvas, imageStream, canvas_1_binding];
}

class Image_display_view extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$y, create_fragment$y, safe_not_equal, { title: 0, imageStream: 2 });
	}

	get title() {
		return this.$$.ctx[0];
	}

	set title(title) {
		this.$$set({ title });
		flush();
	}

	get imageStream() {
		return this.$$.ctx[2];
	}

	set imageStream(imageStream) {
		this.$$set({ imageStream });
		flush();
	}
}

var _ImageDisplay_imageStream;
class ImageDisplay extends Component {
    constructor(imageStream) {
        super();
        this.title = 'image display';
        _ImageDisplay_imageStream.set(this, void 0);
        __classPrivateFieldSet(this, _ImageDisplay_imageStream, imageStream, "f");
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Image_display_view({
            target: t,
            props: {
                title: this.title,
                imageStream: __classPrivateFieldGet(this, _ImageDisplay_imageStream, "f"),
            },
        });
    }
}
_ImageDisplay_imageStream = new WeakMap();

function imageDisplay(...args) {
    return new ImageDisplay(...args);
}

/* src/components/image-upload/image-upload.view.svelte generated by Svelte v3.52.0 */

function get_each_context$a(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[18] = list[i];
	return child_ctx;
}

// (97:2) {#if draggedOver}
function create_if_block$l(ctx) {
	let div;

	return {
		c() {
			div = element("div");

			div.innerHTML = `<i><svg class="fill-current w-12 h-12 mb-3 text-blue-700" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M19.479 10.092c-.212-3.951-3.473-7.092-7.479-7.092-4.005 0-7.267 3.141-7.479 7.092-2.57.463-4.521 2.706-4.521 5.408 0 3.037 2.463 5.5 5.5 5.5h13c3.037 0 5.5-2.463 5.5-5.5 0-2.702-1.951-4.945-4.521-5.408zm-7.479-1.092l4 4h-3v4h-2v-4h-3l4-4z"></path></svg></i> 
      <p class="text-lg text-blue-700">Drop files to upload</p>`;

			attr(div, "class", "overlay svelte-u8vb5e");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (130:6) <Button on:click={clickUpload}>
function create_default_slot_1$8(ctx) {
	let t;

	return {
		c() {
			t = text$1("Upload a file");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (134:6) {#each objectURLs as src}
function create_each_block$a(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", "mx-auto my-2 w-32");
			if (!src_url_equal(img.src, img_src_value = /*src*/ ctx[18] || 'https://user-images.githubusercontent.com/507615/54591670-ac0a0180-4a65-11e9-846c-e55ffce0fe7b.png')) attr(img, "src", img_src_value);
			attr(img, "alt", "no data");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*objectURLs*/ 8 && !src_url_equal(img.src, img_src_value = /*src*/ ctx[18] || 'https://user-images.githubusercontent.com/507615/54591670-ac0a0180-4a65-11e9-846c-e55ffce0fe7b.png')) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (96:0) <ViewContainer {title}>
function create_default_slot$m(ctx) {
	let t0;
	let div2;
	let div0;
	let p;
	let t2;
	let input;
	let t3;
	let button;
	let t4;
	let div1;
	let current;
	let mounted;
	let dispose;
	let if_block = /*draggedOver*/ ctx[2] && create_if_block$l();

	button = new Button$1({
			props: {
				$$slots: { default: [create_default_slot_1$8] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*clickUpload*/ ctx[8]);
	let each_value = /*objectURLs*/ ctx[3];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
	}

	return {
		c() {
			if (if_block) if_block.c();
			t0 = space();
			div2 = element("div");
			div0 = element("div");
			p = element("p");
			p.innerHTML = `<span>Drag and drop an image or</span>`;
			t2 = space();
			input = element("input");
			t3 = space();
			create_component(button.$$.fragment);
			t4 = space();
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(p, "class", "mb-3 font-semibold text-gray-900 flex flex-wrap justify-center");
			attr(input, "type", "file");
			input.multiple = true;
			attr(input, "class", "hidden");
			attr(div0, "class", "border-dashed border-2 border-gray-300 py-8 flex flex-col justify-center items-center");
			attr(div1, "class", "flex flex-wrap");
			attr(div2, "class", "image-upload svelte-u8vb5e");
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, div2, anchor);
			append(div2, div0);
			append(div0, p);
			append(div0, t2);
			append(div0, input);
			/*input_binding*/ ctx[13](input);
			append(div0, t3);
			mount_component(button, div0, null);
			append(div2, t4);
			append(div2, div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(div2, "dragenter", /*handleDragEnter*/ ctx[4]),
					listen(div2, "dragleave", /*handleDragLeave*/ ctx[5]),
					listen(div2, "dragover", /*handleDragOver*/ ctx[6]),
					listen(div2, "drop", /*handleDragDrop*/ ctx[7])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*draggedOver*/ ctx[2]) {
				if (if_block) ; else {
					if_block = create_if_block$l();
					if_block.c();
					if_block.m(t0.parentNode, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			const button_changes = {};

			if (dirty & /*$$scope*/ 2097152) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);

			if (dirty & /*objectURLs*/ 8) {
				each_value = /*objectURLs*/ ctx[3];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$a(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$a(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(div2);
			/*input_binding*/ ctx[13](null);
			destroy_component(button);
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$x(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				$$slots: { default: [create_default_slot$m] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];

			if (dirty & /*$$scope, objectURLs, uploadInput, draggedOver*/ 2097166) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$x($$self, $$props, $$invalidate) {
	let { title } = $$props;
	let { images } = $$props;
	let { thumbnails } = $$props;
	let { width } = $$props;
	let { height } = $$props;
	let uploadInput;
	let counter = 0;
	let draggedOver = false;
	let objectURLs = [];

	// use to check if a file is being dragged
	const hasFiles = ({ dataTransfer: { types = [] } }) => types.indexOf('Files') > -1;

	function handleDragEnter(e) {
		e.preventDefault();

		if (!hasFiles(e)) {
			return;
		}

		counter += 1;
		$$invalidate(2, draggedOver = true);
	}

	function handleDragLeave() {
		counter -= 1;

		if (counter < 1) {
			$$invalidate(2, draggedOver = false);
		}
	}

	function handleDragOver(e) {
		if (hasFiles(e)) {
			e.preventDefault();
		}
	}

	async function processImageFile(file) {
		const { image } = await loadImage(file, {
			...width > 0 && { maxWidth: width },
			...height > 0 && { maxHeight: height },
			cover: true,
			crop: true,
			canvas: true,
			crossOrigin: 'Anonymous'
		});

		const { image: thumbnail } = await loadImage(file, {
			maxWidth: 60,
			maxHeight: 60,
			cover: true,
			crop: true,
			canvas: true,
			crossOrigin: 'Anonymous'
		});

		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		const img = image;

		const imgData = img.getContext('2d').getImageData(0, 0, width || img.width, height || img.height);

		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		const thumb = thumbnail;

		const thumbData = thumb.toDataURL('image/jpeg');
		thumbnails.set(thumbData);
		images.set(imgData);
	}

	async function processFiles(f) {
		$$invalidate(3, objectURLs = []);

		// const imgPromises = [];
		let p = Promise.resolve();

		for (let i = 0; i < f.length; i++) {
			const file = f[i];
			const isImage = file.type.match('image.*');

			if (isImage) {
				p = p.then(() => processImageFile(file));
			}

			$$invalidate(2, draggedOver = false);
			counter = 0;
		}

		await p;
	}

	function handleDragDrop(e) {
		e.preventDefault();
		processFiles(e.dataTransfer.files);
	}

	onMount(async () => {
		await tick();
		await tick();

		uploadInput.addEventListener('change', e => {
			processFiles(e.target.files);
		});
	});

	function clickUpload() {
		if (uploadInput) {
			uploadInput.click();
		}
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			uploadInput = $$value;
			$$invalidate(1, uploadInput);
		});
	}

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('images' in $$props) $$invalidate(9, images = $$props.images);
		if ('thumbnails' in $$props) $$invalidate(10, thumbnails = $$props.thumbnails);
		if ('width' in $$props) $$invalidate(11, width = $$props.width);
		if ('height' in $$props) $$invalidate(12, height = $$props.height);
	};

	return [
		title,
		uploadInput,
		draggedOver,
		objectURLs,
		handleDragEnter,
		handleDragLeave,
		handleDragOver,
		handleDragDrop,
		clickUpload,
		images,
		thumbnails,
		width,
		height,
		input_binding
	];
}

class Image_upload_view extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$x, create_fragment$x, safe_not_equal, {
			title: 0,
			images: 9,
			thumbnails: 10,
			width: 11,
			height: 12
		});
	}
}

var _ImageUpload_width, _ImageUpload_height;
class ImageUpload extends Component {
    constructor({ width = 0, height = 0 } = {}) {
        super();
        this.title = 'image upload';
        this.$images = new Stream(never());
        this.$thumbnails = new Stream(never());
        _ImageUpload_width.set(this, void 0);
        _ImageUpload_height.set(this, void 0);
        __classPrivateFieldSet(this, _ImageUpload_width, width, "f");
        __classPrivateFieldSet(this, _ImageUpload_height, height, "f");
        this.start();
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Image_upload_view({
            target: t,
            props: {
                title: this.title,
                images: this.$images,
                thumbnails: this.$thumbnails,
                width: __classPrivateFieldGet(this, _ImageUpload_width, "f"),
                height: __classPrivateFieldGet(this, _ImageUpload_height, "f"),
            },
        });
    }
}
_ImageUpload_width = new WeakMap(), _ImageUpload_height = new WeakMap();

function imageUpload(...args) {
    return new ImageUpload(...args);
}

function euclideanDistance(a, b) {
    return (a
        .map((x, i) => Math.abs(x - b[i]) ** 2) // square the difference
        .reduce((sum, now) => sum + now) ** // sum
        (1 / 2));
}
class KMeansClustering extends Model {
    constructor({ k = 3 } = {}) {
        super();
        this.title = 'k-means clustering';
        this.serviceName = 'kmeans-models';
        this.parameters = {
            k: new Stream(k, true),
        };
        this.$centers = new Stream([], false);
        this.$clusters = new Stream([], false);
        this.dataset = [];
        this.start();
    }
    async train(dataset) {
        this.$training.set({ status: 'start', epochs: 1 });
        const ds = isDataset(dataset) ? dataset.items() : dataset;
        for await (const { x } of ds) {
            this.dataset.push(x);
        }
        const ans = kmeans(this.dataset, this.parameters.k.get());
        this.$centers.set(ans.centroids.map((x) => x.centroid));
        this.$clusters.set(ans.clusters);
        this.$training.set({ status: 'success' });
    }
    async predict(x) {
        let cluster = 0;
        let minDistance = 1000;
        const confidences = {};
        let distSum = 0;
        for (let i = 0; i < this.$centers.get().length; i++) {
            const dist = euclideanDistance(this.$centers.get()[i], x);
            if (dist < minDistance) {
                minDistance = dist;
                cluster = i;
            }
            confidences[`${i}`] = Math.exp(dist);
            distSum += Math.exp(dist);
        }
        Object.entries(confidences).forEach(([key]) => {
            confidences[key] /= distSum;
        });
        if (this.$centers.get().length === 0) {
            const e = new Error('KMeans is not trained');
            e.name = '[KMeans] Prediction Error';
            throwError(e);
        }
        return { cluster, confidences };
    }
    async batchPredict(dataset) {
        // const allInstances = await dataset.getAllInstances(['features']);
        const data = []; //allInstances.map((x) => x.features[0]);
        const ds = isDataset(dataset) ? dataset.items() : dataset;
        for await (const { x } of ds) {
            data.push(x);
        }
        const resPromises = [];
        for (let i = 0; i < data.length; i++) {
            this.predict(data[i]).then((result) => resPromises.push(result));
        }
        if (this.$centers.get().length === 0) {
            const e = new Error('KMeans is not trained');
            e.name = '[KMeans] Prediction Error';
            throwError(e);
        }
        return resPromises;
    }
    async save(store, name, metadata, id = null) {
        const storedModel = await this.write(metadata);
        storedModel.name = name;
        return this.saveToDatastore(store, storedModel, id);
    }
    async load(store, id) {
        const storedModel = await this.loadFromDatastore(store, id);
        await this.read(storedModel);
        return storedModel;
    }
    async download(metadata) {
        const model = await this.write(metadata);
        saveBlob(JSON.stringify(model), `${model.name}.json`, 'text/plain');
    }
    async upload(...files) {
        const jsonFiles = files.filter((x) => x.name.includes('.json'));
        const model = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
                const obj = JSON.parse(reader.result);
                resolve(obj);
            };
            reader.onerror = reject;
            reader.readAsText(jsonFiles[0]);
        });
        await this.read(model);
        return model;
    }
    async write(metadata = {}) {
        const name = toKebabCase(this.title);
        return {
            name,
            files: [],
            format: 'ml-kmeans',
            metadata: {
                clusters: this.$clusters.get(),
                centers: this.$centers.get(),
                ...metadata,
            },
        };
    }
    async read(s) {
        const dataset = s.metadata.data;
        if (!dataset)
            return;
        Object.entries(dataset).forEach(([key, d]) => {
        });
        this.$clusters.set(s.metadata.labels);
        this.$training.set({
            status: 'loaded',
        });
    }
}
__decorate([
    Catch
], KMeansClustering.prototype, "train", null);
__decorate([
    Catch
], KMeansClustering.prototype, "predict", null);
__decorate([
    Catch
], KMeansClustering.prototype, "batchPredict", null);

function kmeansClustering(...args) {
    return new KMeansClustering(...args);
}

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Flatten a Tensor to a 1D array.
 * @doc {heading: 'Tensors', subheading: 'Classes'}
 */
getGlobalTensorClass().prototype.flatten = function () {
    this.throwIfDisposed();
    return reshape(this, [this.size]);
};

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes absolute value element-wise: `abs(x)`
 *
 * ```js
 * const x = tf.tensor1d([-1, 2, -3, 4]);
 *
 * x.abs().print();  // or tf.abs(x)
 * ```
 * @param x The input `tf.Tensor`.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function abs_(x) {
    const $x = convertToTensor(x, 'x', 'abs');
    if ($x.dtype === 'complex64') {
        const inputs = { x: $x };
        return ENGINE.runKernel(ComplexAbs, inputs);
    }
    else {
        const inputs = { x: $x };
        return ENGINE.runKernel(Abs, inputs);
    }
}
const abs = op({ abs_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes acos of the input `tf.Tensor` element-wise: `acos(x)`
 *
 * ```js
 * const x = tf.tensor1d([0, 1, -1, .7]);
 *
 * x.acos().print();  // or tf.acos(x)
 * ```
 * @param x The input tensor.
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function acos_(x) {
    const $x = convertToTensor(x, 'x', 'acos');
    const inputs = { x: $x };
    return ENGINE.runKernel(Acos, inputs);
}
op({ acos_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the inverse hyperbolic cos of the input `tf.Tensor` element-wise:
 * `acosh(x)`
 *
 * ```js
 * const x = tf.tensor1d([10, 1, 3, 5.7]);
 *
 * x.acosh().print();  // or tf.acosh(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function acosh_(x) {
    const $x = convertToTensor(x, 'x', 'acosh');
    const inputs = { x: $x };
    return ENGINE.runKernel(Acosh, inputs);
}
op({ acosh_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Adds two `tf.Tensor`s element-wise, A + B. Supports broadcasting.
 *
 *
 * ```js
 * const a = tf.tensor1d([1, 2, 3, 4]);
 * const b = tf.tensor1d([10, 20, 30, 40]);
 *
 * a.add(b).print();  // or tf.add(a, b)
 * ```
 *
 * ```js
 * // Broadcast add a with b.
 * const a = tf.scalar(5);
 * const b = tf.tensor1d([10, 20, 30, 40]);
 *
 * a.add(b).print();  // or tf.add(a, b)
 * ```
 * @param a The first `tf.Tensor` to add.
 * @param b The second `tf.Tensor` to add. Must have the same type as `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Arithmetic'}
 */
function add_(a, b) {
    let $a = convertToTensor(a, 'a', 'add');
    let $b = convertToTensor(b, 'b', 'add');
    [$a, $b] = makeTypesMatch($a, $b);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Add, inputs);
}
const add = op({ add_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Adds a list of `tf.Tensor`s element-wise, each with the same shape and dtype.
 *
 * ```js
 * const a = tf.tensor1d([1, 2]);
 * const b = tf.tensor1d([3, 4]);
 * const c = tf.tensor1d([5, 6]);
 *
 * tf.addN([a, b, c]).print();
 * ```
 * @param tensors A list of tensors with the same shape and dtype.
 * @doc {heading: 'Operations', subheading: 'Arithmetic'}
 */
function addN_(tensors) {
    assert(Array.isArray(tensors), () => 'The argument passed to tf.addN() must be a list of tensors');
    assert(tensors.length >= 1, () => `Must pass at least one tensor to tf.addN(), but got ` +
        `${tensors.length}`);
    const $tensors = tensors.map((t, i) => convertToTensor(t, `tensors${i}`, 'addN'));
    const firstTensor = $tensors[0];
    $tensors.forEach(t => {
        if (t.dtype !== firstTensor.dtype) {
            throw new Error('All tensors passed to tf.addN() must have the same dtype');
        }
    });
    $tensors.forEach(t => {
        if (!arraysEqual(t.shape, firstTensor.shape)) {
            throw new Error('All tensors passed to tf.addN() must have the same shape');
        }
    });
    const inputs = $tensors;
    return ENGINE.runKernel(AddN, inputs);
}
op({ addN_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the logical and of elements across dimensions of a `tf.Tensor`.
 *
 * Reduces the input along the dimensions given in `axes`. Unless `keepDims`
 * is true, the rank of the `tf.Tensor` is reduced by 1 for each entry in
 * `axes`. If `keepDims` is true, the reduced dimensions are retained with
 * length 1. If `axes` has no entries, all dimensions are reduced, and a
 * `tf.Tensor` with a single element is returned.
 *
 * ```js
 * const x = tf.tensor1d([1, 1, 1], 'bool');
 *
 * x.all().print();  // or tf.all(x)
 * ```
 *
 * ```js
 * const x = tf.tensor2d([1, 1, 0, 0], [2, 2], 'bool');
 *
 * const axis = 1;
 * x.all(axis).print();  // or tf.all(x, axis)
 * ```
 *
 * @param x The input tensor. Must be of dtype bool.
 * @param axis The dimension(s) to reduce. By default it reduces
 *     all dimensions.
 * @param keepDims If true, retains reduced dimensions with size 1.
 *
 * @doc {heading: 'Operations', subheading: 'Reduction'}
 */
function all_(x, axis = null, keepDims = false) {
    const $x = convertToTensor(x, 'x', 'all', 'bool');
    const inputs = { x: $x };
    const attrs = { axis, keepDims };
    return ENGINE.runKernel(All, inputs, attrs);
}
op({ all_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the logical or of elements across dimensions of a `tf.Tensor`.
 *
 * Reduces the input along the dimensions given in `axes`. Unless `keepDims`
 * is true, the rank of the `tf.Tensor` is reduced by 1 for each entry in
 * `axes`. If `keepDims` is true, the reduced dimensions are retained with
 * length 1. If `axes` has no entries, all dimensions are reduced, and a
 * `tf.Tensor` with a single element is returned.
 *
 * ```js
 * const x = tf.tensor1d([1, 1, 1], 'bool');
 *
 * x.any().print();  // or tf.any(x)
 * ```
 *
 * ```js
 * const x = tf.tensor2d([1, 1, 0, 0], [2, 2], 'bool');
 *
 * const axis = 1;
 * x.any(axis).print();  // or tf.any(x, axis)
 * ```
 *
 * @param x The input tensor. Must be of dtype bool.
 * @param axis The dimension(s) to reduce. By default it reduces
 *     all dimensions.
 * @param keepDims If true, retains reduced dimensions with size 1.
 *
 * @doc {heading: 'Operations', subheading: 'Reduction'}
 */
function any_(x, axis = null, keepDims = false) {
    const $x = convertToTensor(x, 'x', 'any', 'bool');
    const inputs = { x: $x };
    const attrs = { axis, keepDims };
    return ENGINE.runKernel(Any, inputs, attrs);
}
// tslint:disable-next-line:variable-name
op({ any_ });

/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns the indices of the minimum values along an `axis`.
 *
 * The result has the same shape as `input` with the dimension along `axis`
 * removed.
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3]);
 *
 * x.argMin().print();  // or tf.argMin(x)
 * ```
 *
 * ```js
 * const x = tf.tensor2d([1, 2, 4, 3], [2, 2]);
 *
 * const axis = 1;
 * x.argMin(axis).print();  // or tf.argMin(x, axis)
 * ```
 *
 * @param x The input tensor.
 * @param axis The dimension to reduce. Defaults to 0 (outer-most dimension).
 *
 * @doc {heading: 'Operations', subheading: 'Reduction'}
 */
function argMin_(x, axis = 0) {
    const $x = convertToTensor(x, 'x', 'argMin');
    const inputs = { x: $x };
    const attrs = { axis };
    return ENGINE.runKernel(ArgMin, inputs, attrs);
}
op({ argMin_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes asin of the input `tf.Tensor` element-wise: `asin(x)`
 *
 * ```js
 * const x = tf.tensor1d([0, 1, -1, .7]);
 *
 * x.asin().print();  // or tf.asin(x)
 * ```
 * @param x The input tensor.
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function asin_(x) {
    const $x = convertToTensor(x, 'x', 'asin');
    const inputs = { x: $x };
    return ENGINE.runKernel(Asin, inputs);
}
op({ asin_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes inverse hyperbolic sin of the input `tf.Tensor` element-wise:
 * `asinh(x)`
 *
 * ```js
 * const x = tf.tensor1d([0, 1, -1, .7]);
 *
 * x.asinh().print();  // or tf.asinh(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function asinh_(x) {
    const $x = convertToTensor(x, 'x', 'asinh');
    const inputs = { x: $x };
    return ENGINE.runKernel(Asinh, inputs);
}
op({ asinh_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes atan of the input `tf.Tensor` element-wise: `atan(x)`
 *
 * ```js
 * const x = tf.tensor1d([0, 1, -1, .7]);
 *
 * x.atan().print();  // or tf.atan(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function atan_(x) {
    const $x = convertToTensor(x, 'x', 'atan');
    const inputs = { x: $x };
    return ENGINE.runKernel(Atan, inputs);
}
op({ atan_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes arctangent of `tf.Tensor`s a / b element-wise: `atan2(a, b)`.
 * Supports broadcasting.
 *
 * ```js
 * const a = tf.tensor1d([1.0, 1.0, -1.0, .7]);
 * const b = tf.tensor1d([2.0, 13.0, 3.5, .21]);
 *
 * tf.atan2(a, b).print()
 * ```
 *
 * @param a The first tensor.
 * @param b The second tensor. Must have the same dtype as `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function atan2_(a, b) {
    let $a = convertToTensor(a, 'a', 'atan2');
    let $b = convertToTensor(b, 'b', 'atan2');
    [$a, $b] = makeTypesMatch($a, $b);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Atan2, inputs);
}
op({ atan2_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes inverse hyperbolic tan of the input `tf.Tensor` element-wise:
 * `atanh(x)`
 *
 * ```js
 * const x = tf.tensor1d([0, .1, -.1, .7]);
 *
 * x.atanh().print();  // or tf.atanh(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function atanh_(x) {
    const $x = convertToTensor(x, 'x', 'atanh');
    const inputs = { x: $x };
    return ENGINE.runKernel(Atanh, inputs);
}
op({ atanh_ });

/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Casts a `tf.Tensor` to a new dtype.
 *
 * ```js
 * const x = tf.tensor1d([1.5, 2.5, 3]);
 * tf.cast(x, 'int32').print();
 * ```
 * @param x The input tensor to be casted.
 * @param dtype The dtype to cast the input tensor to.
 *
 * @doc {heading: 'Tensors', subheading: 'Transformations'}
 */
function cast_(x, dtype) {
    const $x = convertToTensor(x, 'x', 'cast');
    // Sanity checks.
    if (!isValidDtype(dtype)) {
        throw new Error(`Failed to cast to unknown dtype ${dtype}`);
    }
    if (dtype === 'string' && $x.dtype !== 'string' ||
        dtype !== 'string' && $x.dtype === 'string') {
        throw new Error('Only strings can be casted to strings');
    }
    const inputs = { x: $x };
    const attrs = { dtype };
    return ENGINE.runKernel(Cast, inputs, attrs);
}
const cast = op({ cast_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function computePool2DInfo(inShape, filterSize, strides, dilations, pad, roundingMode, dataFormat = 'channelsLast') {
    const [filterHeight, filterWidth] = parseTupleParam(filterSize);
    let filterShape;
    if (dataFormat === 'channelsLast') {
        filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];
    }
    else if (dataFormat === 'channelsFirst') {
        filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];
    }
    else {
        throw new Error(`Unknown dataFormat ${dataFormat}`);
    }
    return computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, false, dataFormat);
}
/**
 * Computes the information for a forward pass of a convolution/pooling
 * operation.
 */
function computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, depthwise = false, dataFormat = 'channelsLast') {
    let [batchSize, inHeight, inWidth, inChannels] = [-1, -1, -1, -1];
    if (dataFormat === 'channelsLast') {
        [batchSize, inHeight, inWidth, inChannels] = inShape;
    }
    else if (dataFormat === 'channelsFirst') {
        [batchSize, inChannels, inHeight, inWidth] = inShape;
    }
    else {
        throw new Error(`Unknown dataFormat ${dataFormat}`);
    }
    const [filterHeight, filterWidth, , filterChannels] = filterShape;
    const [strideHeight, strideWidth] = parseTupleParam(strides);
    const [dilationHeight, dilationWidth] = parseTupleParam(dilations);
    const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
    const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
    const { padInfo, outHeight, outWidth } = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode, dataFormat);
    const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
    let outShape;
    if (dataFormat === 'channelsFirst') {
        outShape = [batchSize, outChannels, outHeight, outWidth];
    }
    else if (dataFormat === 'channelsLast') {
        outShape = [batchSize, outHeight, outWidth, outChannels];
    }
    return {
        batchSize,
        dataFormat,
        inHeight,
        inWidth,
        inChannels,
        outHeight,
        outWidth,
        outChannels,
        padInfo,
        strideHeight,
        strideWidth,
        filterHeight,
        filterWidth,
        effectiveFilterHeight,
        effectiveFilterWidth,
        dilationHeight,
        dilationWidth,
        inShape,
        outShape,
        filterShape
    };
}
function computeOutputShape2D(inShape, fieldSize, stride, zeroPad, roundingMode) {
    if (zeroPad == null) {
        zeroPad = computeDefaultPad(inShape, fieldSize, stride);
    }
    const inputRows = inShape[0];
    const inputCols = inShape[1];
    const outputRows = round$2((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    const outputCols = round$2((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    return [outputRows, outputCols];
}
function computeDefaultPad(inputShape, fieldSize, stride, dilation = 1) {
    const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);
    return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);
}
function parseTupleParam(param) {
    if (typeof param === 'number') {
        return [param, param, param];
    }
    if (param.length === 2) {
        return [param[0], param[1], 1];
    }
    return param;
}
/* See https://www.tensorflow.org/api_docs/python/tf/nn/atrous_conv2d
 * Atrous convolution is equivalent to standard convolution with upsampled
 * filters with effective_filter_height =
 * filter_height + (filter_height - 1) * (dilation - 1)
 * and effective_filter_width =
 * filter_width + (filter_width - 1) * (dilation - 1),
 * produced by inserting dilation - 1 zeros along consecutive elements across
 * the filters' spatial dimensions.
 * When there is a dilation, this converts a filter dimension to the
 * effective filter dimension, so it can be used in a standard convolution.
 */
function getEffectiveFilterSize(filterSize, dilation) {
    if (dilation <= 1) {
        return filterSize;
    }
    return filterSize + (filterSize - 1) * (dilation - 1);
}
function getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode, dataFormat) {
    let padInfo;
    let outHeight;
    let outWidth;
    if (typeof pad === 'number') {
        const padType = (pad === 0) ? 'VALID' : 'NUMBER';
        padInfo = { top: pad, bottom: pad, left: pad, right: pad, type: padType };
        const outShape = computeOutputShape2D([inHeight, inWidth], filterHeight, strideHeight, pad, roundingMode);
        outHeight = outShape[0];
        outWidth = outShape[1];
    }
    else if (pad === 'same') {
        outHeight = Math.ceil(inHeight / strideHeight);
        outWidth = Math.ceil(inWidth / strideWidth);
        const padAlongHeight = Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);
        const padAlongWidth = Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);
        const top = Math.floor(padAlongHeight / 2);
        const bottom = padAlongHeight - top;
        const left = Math.floor(padAlongWidth / 2);
        const right = padAlongWidth - left;
        padInfo = { top, bottom, left, right, type: 'SAME' };
    }
    else if (pad === 'valid') {
        padInfo = { top: 0, bottom: 0, left: 0, right: 0, type: 'VALID' };
        outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
        outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
    }
    else if (typeof pad === 'object') {
        const top = dataFormat === 'channelsLast' ? pad[1][0] : pad[2][0];
        const bottom = dataFormat === 'channelsLast' ? pad[1][1] : pad[2][1];
        const left = dataFormat === 'channelsLast' ? pad[2][0] : pad[3][0];
        const right = dataFormat === 'channelsLast' ? pad[2][1] : pad[3][1];
        const padType = (top === 0 && bottom === 0 && left === 0 && right === 0) ?
            'VALID' :
            'EXPLICIT';
        padInfo = { top, bottom, left, right, type: padType };
        outHeight = round$2((inHeight - filterHeight + top + bottom) / strideHeight + 1, roundingMode);
        outWidth = round$2((inWidth - filterWidth + left + right) / strideWidth + 1, roundingMode);
    }
    else {
        throw Error(`Unknown padding parameter: ${pad}`);
    }
    return { padInfo, outHeight, outWidth };
}
/**
 * Rounds a value depending on the rounding mode
 * @param value
 * @param roundingMode A string from: 'ceil', 'round', 'floor'. If none is
 *     provided, it will default to truncate.
 */
function round$2(value, roundingMode) {
    if (!roundingMode) {
        return Math.trunc(value);
    }
    switch (roundingMode) {
        case 'round':
            // used for Caffe Conv
            return Math.round(value);
        case 'ceil':
            // used for Caffe Pool
            return Math.ceil(value);
        case 'floor':
            return Math.floor(value);
        default:
            throw new Error(`Unknown roundingMode ${roundingMode}`);
    }
}
function tupleValuesAreOne(param) {
    const [dimA, dimB, dimC] = parseTupleParam(param);
    return dimA === 1 && dimB === 1 && dimC === 1;
}
function eitherStridesOrDilationsAreOne(strides, dilations) {
    return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);
}
/**
 * Check validity of pad when using dimRoundingMode.
 * @param opDesc A string of op description
 * @param pad The type of padding algorithm.
 *   - `same` and stride 1: output will be of same size as input,
 *       regardless of filter size.
 *   - `valid` output will be smaller than input if filter is larger
 *       than 1x1.
 *   - For more info, see this guide:
 *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](
 *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)
 * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is
 *     provided, it will default to truncate.
 * @throws unknown padding parameter
 */
function checkPadOnDimRoundingMode(opDesc, pad, dimRoundingMode) {
    if (dimRoundingMode != null) {
        if (typeof pad === 'string') {
            throw Error(`Error in ${opDesc}: pad must be an integer when using ` +
                `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);
        }
        else if (typeof pad === 'number') {
            assert(isInt(pad), () => `Error in ${opDesc}: pad must be an integer when using ` +
                `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);
        }
        else if (typeof pad === 'object') {
            pad.forEach(p => {
                p.forEach(v => {
                    assert(isInt(v), () => `Error in ${opDesc}: pad must be an integer when using ` +
                        `dimRoundingMode ${dimRoundingMode} but got pad ${v}.`);
                });
            });
        }
        else {
            throw Error(`Error in ${opDesc}: Unknown padding parameter: ${pad}`);
        }
    }
}

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the 2D average pooling of an image.
 *
 * @param x The input tensor, of rank 4 or rank 3 of shape
 *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.
 * @param filterSize The filter size: `[filterHeight, filterWidth]`. If
 *     `filterSize` is a single number, then `filterHeight == filterWidth`.
 * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If
 *     `strides` is a single number, then `strideHeight == strideWidth`.
 * @param pad The type of padding algorithm:
 *    - `same` and stride 1: output will be of same size as input,
 *       regardless of filter size.
 *    - `valid`: output will be smaller than input if filter is larger
 *       than 1x1.
 *    - For more info, see this guide:
 *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](
 *         https://www.tensorflow.org/api_docs/python/tf/nn/convolution)
 * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is
 *     provided, it will default to truncate.
 */
function avgPool_(x, filterSize, strides, pad, dimRoundingMode) {
    const $x = convertToTensor(x, 'x', 'avgPool', 'float32');
    const dilations = 1;
    assert(eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in avgPool: Either strides or dilations must be 1. ' +
        `Got strides ${strides} and dilations '${dilations}'`);
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert(x4D.rank === 4, () => `Error in avgPool: x must be rank 4 but got rank ${x4D.rank}.`);
    checkPadOnDimRoundingMode('avgPool', pad, dimRoundingMode);
    const inputs = { x: x4D };
    const attrs = { filterSize, strides, pad, dimRoundingMode };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    let res = ENGINE.runKernel(AvgPool, inputs, attrs);
    res = cast(res, $x.dtype);
    if (reshapedTo4D) {
        return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
}
const avgPool = op({ avgPool_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the 3D average pooling.
 *
 * ```js
 * const x = tf.tensor5d([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 2, 2, 1]);
 * const result = tf.avgPool3d(x, 2, 1, 'valid');
 * result.print();
 * ```
 *
 * @param x The input tensor, of rank 5 or rank 4 of shape
 *     `[batch, depth, height, width, inChannels]`.
 * @param filterSize The filter size:
 *     `[filterDepth, filterHeight, filterWidth]`.
 *     If `filterSize` is a single number,
 *     then `filterDepth == filterHeight == filterWidth`.
 * @param strides The strides of the pooling:
 *     `[strideDepth, strideHeight, strideWidth]`.
 *     If `strides` is a single number,
 *     then `strideDepth == strideHeight == strideWidth`.
 * @param pad The type of padding algorithm.
 *    - `same` and stride 1: output will be of same size as input,
 *       regardless of filter size.
 *    - `valid`: output will be smaller than input if filter is larger
 *       than 1*1x1.
 *    - For more info, see this guide:
 *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](
 *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)
 * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is
 *     provided, it will default to truncate.
 * @param dataFormat An optional string from: "NDHWC", "NCDHW". Defaults to
 *     "NDHWC". Specify the data format of the input and output data. With the
 *     default format "NDHWC", the data is stored in the order of: [batch,
 *     depth, height, width, channels]. Only "NDHWC" is currently supported.
 *
 * @doc {heading: 'Operations', subheading: 'Convolution'}
 */
function avgPool3d_(x, filterSize, strides, pad, dimRoundingMode, dataFormat = 'NDHWC') {
    const $x = convertToTensor(x, 'x', 'avgPool3d', 'float32');
    let x5D = $x;
    let reshapedTo5D = false;
    if ($x.rank === 4) {
        reshapedTo5D = true;
        x5D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
    }
    assert(x5D.rank === 5, () => `Error in avgPool3d: x must be rank 5 but got rank ${x5D.rank}.`);
    assert(dataFormat === 'NDHWC', () => `Error in avgPool3d: Only NDHWC is currently supported, ` +
        `but got dataFormat of ${dataFormat}`);
    checkPadOnDimRoundingMode('avgPool3d', pad, dimRoundingMode);
    const inputs = { x: x5D };
    const attrs = { filterSize, strides, pad, dimRoundingMode, dataFormat };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    let res = ENGINE.runKernel(AvgPool3D, inputs, attrs);
    res = cast(res, x5D.dtype);
    if (reshapedTo5D) {
        return reshape(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
    }
    return res;
}
op({ avgPool3d_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Creates a new tensor with the same values and shape as the specified
 * tensor.
 *
 * ```js
 * const x = tf.tensor([1, 2]);
 *
 * x.clone().print();
 * ```
 *
 * @param x The tensor to clone.
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */
function clone_(x) {
    const $x = convertToTensor(x, 'x', 'clone', 'string_or_numeric');
    const inputs = { x: $x };
    // Note this op is called tf.identity in python. Hence the kernel name used
    // here.
    return ENGINE.runKernel(Identity, inputs);
}
const clone = op({ clone_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Concatenates a list of `tf.Tensor`s along a given axis.
 *
 * The tensors ranks and types must match, and their sizes must match in all
 * dimensions except `axis`.
 *
 * Also available are stricter rank-specific methods that assert that
 * `tensors` are of the given rank:
 *   - `tf.concat1d`
 *   - `tf.concat2d`
 *   - `tf.concat3d`
 *   - `tf.concat4d`
 *
 * Except `tf.concat1d` (which does not have axis param), all methods have
 * same signature as this method.
 *
 * ```js
 * const a = tf.tensor1d([1, 2]);
 * const b = tf.tensor1d([3, 4]);
 * a.concat(b).print();  // or a.concat(b)
 * ```
 *
 * ```js
 * const a = tf.tensor1d([1, 2]);
 * const b = tf.tensor1d([3, 4]);
 * const c = tf.tensor1d([5, 6]);
 * tf.concat([a, b, c]).print();
 * ```
 *
 * ```js
 * const a = tf.tensor2d([[1, 2], [10, 20]]);
 * const b = tf.tensor2d([[3, 4], [30, 40]]);
 * const axis = 1;
 * tf.concat([a, b], axis).print();
 * ```
 * @param tensors A list of tensors to concatenate.
 * @param axis The axis to concatenate along. Defaults to 0 (the first dim).
 *
 * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}
 */
function concat_(tensors, axis = 0) {
    assert(tensors.length >= 1, () => 'Pass at least one tensor to concat');
    const $tensors = convertToTensorArray(tensors, 'tensors', 'concat', 'string_or_numeric');
    if ($tensors[0].dtype === 'complex64') {
        $tensors.forEach(tensor => {
            if (tensor.dtype !== 'complex64') {
                throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${tensor.dtype}. `);
            }
        });
    }
    if ($tensors.length === 1) {
        return clone($tensors[0]);
    }
    const inputs = $tensors;
    const attr = { axis };
    return ENGINE.runKernel(Concat, inputs, attr);
}
const concat = op({ concat_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the dot product of two matrices, A * B. These must be matrices.
 *
 * ```js
 * const a = tf.tensor2d([1, 2], [1, 2]);
 * const b = tf.tensor2d([1, 2, 3, 4], [2, 2]);
 *
 * a.matMul(b).print();  // or tf.matMul(a, b)
 * ```
 * @param a First matrix in dot product operation.
 * @param b Second matrix in dot product operation.
 * @param transposeA If true, `a` is transposed before multiplication.
 * @param transposeB If true, `b` is transposed before multiplication.
 *
 * @doc {heading: 'Operations', subheading: 'Matrices'}
 */
function matMul_(a, b, transposeA = false, transposeB = false) {
    let $a = convertToTensor(a, 'a', 'matMul');
    let $b = convertToTensor(b, 'b', 'matMul');
    [$a, $b] = makeTypesMatch($a, $b);
    const inputs = { a: $a, b: $b };
    const attrs = { transposeA, transposeB };
    return ENGINE.runKernel(BatchMatMul, inputs, attrs);
}
const matMul = op({ matMul_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Multiplies two `tf.Tensor`s element-wise, A * B. Supports broadcasting.
 *
 * We also expose `tf.mulStrict` which has the same signature as this op and
 * asserts that `a` and `b` are the same shape (does not broadcast).
 *
 * ```js
 * const a = tf.tensor1d([1, 2, 3, 4]);
 * const b = tf.tensor1d([2, 3, 4, 5]);
 *
 * a.mul(b).print();  // or tf.mul(a, b)
 * ```
 *
 * ```js
 * // Broadcast mul a with b.
 * const a = tf.tensor1d([1, 2, 3, 4]);
 * const b = tf.scalar(5);
 *
 * a.mul(b).print();  // or tf.mul(a, b)
 * ```
 * @param a The first tensor to multiply.
 * @param b The second tensor to multiply. Must have the same dtype as `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Arithmetic'}
 */
function mul_(a, b) {
    let $a = convertToTensor(a, 'a', 'mul');
    let $b = convertToTensor(b, 'b', 'mul');
    [$a, $b] = makeTypesMatch($a, $b);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Multiply, inputs);
}
const mul = op({ mul_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes sigmoid element-wise, `1 / (1 + exp(-x))`
 *
 * ```js
 * const x = tf.tensor1d([0, -1, 2, -3]);
 *
 * x.sigmoid().print();  // or tf.sigmoid(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function sigmoid_(x) {
    const $x = convertToTensor(x, 'x', 'sigmoid', 'float32');
    const inputs = { x: $x };
    return ENGINE.runKernel(Sigmoid, inputs);
}
const sigmoid = op({ sigmoid_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Extracts a slice from a `tf.Tensor` starting at coordinates `begin`
 * and is of size `size`.
 *
 * Also available are stricter rank-specific methods with the same signature
 * as this method that assert that `x` is of the given rank:
 *   - `tf.slice1d`
 *   - `tf.slice2d`
 *   - `tf.slice3d`
 *   - `tf.slice4d`
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3, 4]);
 *
 * x.slice([1], [2]).print();
 * ```
 *
 * ```js
 * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);
 *
 * x.slice([1, 0], [1, 2]).print();
 * ```
 * @param x The input `tf.Tensor` to slice from.
 * @param begin The coordinates to start the slice from. The length can be
 *     less than the rank of x - the rest of the axes will have implicit 0 as
 *     start. Can also be a single number, in which case it specifies the
 *     first axis.
 * @param size The size of the slice. The length can be less than the rank of
 *     x - the rest of the axes will have implicit -1. A value of -1 requests
 *     the rest of the dimensions in the axis. Can also be a single number,
 *     in which case it specifies the size of the first axis.
 *
 * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}
 */
function slice_(x, begin, size) {
    const $x = convertToTensor(x, 'x', 'slice', 'string_or_numeric');
    if ($x.rank === 0) {
        throw new Error('Slicing scalar is not possible');
    }
    const inputs = { x: $x };
    const attrs = { begin, size };
    return ENGINE.runKernel(Slice, inputs, attrs);
}
const slice = op({ slice_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes hyperbolic tangent of the input `tf.Tensor` element-wise: `tanh(x)`
 *
 * ```js
 * const x = tf.tensor1d([0, 1, -1, 70]);
 *
 * x.tanh().print();  // or tf.tanh(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function tanh_(x) {
    const $x = convertToTensor(x, 'x', 'tanh', 'float32');
    const inputs = { x: $x };
    return ENGINE.runKernel(Tanh, inputs);
}
const tanh = op({ tanh_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the next state and output of a BasicLSTMCell.
 *
 * Returns `[newC, newH]`.
 *
 * Derived from tf.contrib.rnn.BasicLSTMCell.
 *
 * @param forgetBias Forget bias for the cell.
 * @param lstmKernel The weights for the cell.
 * @param lstmBias The bias for the cell.
 * @param data The input to the cell.
 * @param c Previous cell state.
 * @param h Previous cell output.
 *
 * @doc {heading: 'Operations', subheading: 'RNN'}
 */
function basicLSTMCell_(forgetBias, lstmKernel, lstmBias, data, c, h) {
    const $forgetBias = convertToTensor(forgetBias, 'forgetBias', 'basicLSTMCell');
    const $lstmKernel = convertToTensor(lstmKernel, 'lstmKernel', 'basicLSTMCell');
    const $lstmBias = convertToTensor(lstmBias, 'lstmBias', 'basicLSTMCell');
    const $data = convertToTensor(data, 'data', 'basicLSTMCell');
    const $c = convertToTensor(c, 'c', 'basicLSTMCell');
    const $h = convertToTensor(h, 'h', 'basicLSTMCell');
    const combined = concat([$data, $h], 1);
    const weighted = matMul(combined, $lstmKernel);
    const res = add(weighted, $lstmBias);
    // i = input_gate, j = new_input, f = forget_gate, o = output_gate
    const batchSize = res.shape[0];
    const sliceCols = res.shape[1] / 4;
    const sliceSize = [batchSize, sliceCols];
    const i = slice(res, [0, 0], sliceSize);
    const j = slice(res, [0, sliceCols], sliceSize);
    const f = slice(res, [0, sliceCols * 2], sliceSize);
    const o = slice(res, [0, sliceCols * 3], sliceSize);
    const newC = add(mul(sigmoid(i), tanh(j)), mul($c, sigmoid(add($forgetBias, f))));
    const newH = mul(tanh(newC), sigmoid(o));
    return [newC, newH];
}
op({ basicLSTMCell_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * This operation reshapes the "batch" dimension 0 into `M + 1` dimensions of
 * shape `blockShape + [batch]`, interleaves these blocks back into the grid
 * defined by the spatial dimensions `[1, ..., M]`, to obtain a result with
 * the same rank as the input. The spatial dimensions of this intermediate
 * result are then optionally cropped according to `crops` to produce the
 * output. This is the reverse of `tf.spaceToBatchND`. See below for a precise
 * description.
 *
 * ```js
 * const x = tf.tensor4d([1, 2, 3, 4], [4, 1, 1, 1]);
 * const blockShape = [2, 2];
 * const crops = [[0, 0], [0, 0]];
 *
 * x.batchToSpaceND(blockShape, crops).print();
 * ```
 *
 * @param x A `tf.Tensor`. N-D with `x.shape` = `[batch] + spatialShape +
 * remainingShape`, where spatialShape has `M` dimensions.
 * @param blockShape A 1-D array. Must have shape `[M]`, all values must
 * be >= 1.
 * @param crops A 2-D array.  Must have shape `[M, 2]`, all values must be >= 0.
 * `crops[i] = [cropStart, cropEnd]` specifies the amount to crop from input
 * dimension `i + 1`, which corresponds to spatial dimension `i`. It is required
 * that `cropStart[i] + cropEnd[i] <= blockShape[i] * inputShape[i + 1]`
 *
 * This operation is equivalent to the following steps:
 *
 * 1. Reshape `x` to `reshaped` of shape: `[blockShape[0], ...,
 * blockShape[M-1], batch / prod(blockShape), x.shape[1], ...,
 * x.shape[N-1]]`
 *
 * 2. Permute dimensions of `reshaped` to produce `permuted` of shape `[batch /
 * prod(blockShape),x.shape[1], blockShape[0], ..., x.shape[M],
 * blockShape[M-1],x.shape[M+1], ..., x.shape[N-1]]`
 *
 * 3. Reshape `permuted` to produce `reshapedPermuted` of shape `[batch /
 * prod(blockShape),x.shape[1] * blockShape[0], ..., x.shape[M] *
 * blockShape[M-1],x.shape[M+1], ..., x.shape[N-1]]`
 *
 * 4. Crop the start and end of dimensions `[1, ..., M]` of `reshapedPermuted`
 * according to `crops` to produce the output of shape: `[batch /
 * prod(blockShape),x.shape[1] * blockShape[0] - crops[0,0] - crops[0,1],
 * ..., x.shape[M] * blockShape[M-1] - crops[M-1,0] -
 * crops[M-1,1],x.shape[M+1], ..., x.shape[N-1]]`
 *
 * @doc {heading: 'Tensors', subheading: 'Transformations'}
 */
function batchToSpaceND_(x, blockShape, crops) {
    const $x = convertToTensor(x, 'x', 'batchToSpaceND');
    const prod = blockShape.reduce((a, b) => a * b);
    assert($x.rank >= 1 + blockShape.length, () => `input rank is ${$x.rank} but should be > than blockShape.length ${blockShape.length}`);
    assert(crops.length === blockShape.length, () => `crops.length is ${crops.length} but should be equal to blockShape.length  ${blockShape.length}`);
    assert($x.shape[0] % prod === 0, () => `input tensor batch is ${$x.shape[0]} but is not divisible by the product of ` +
        `the elements of blockShape ${blockShape.join(' * ')} === ${prod}`);
    const inputs = { x: $x };
    const attrs = { blockShape, crops };
    return ENGINE.runKernel(BatchToSpaceND, inputs, attrs);
}
const batchToSpaceND = op({ batchToSpaceND_ });

function xAs4D(x) {
    let x4D;
    if (x.rank === 0 || x.rank === 1) {
        x4D = reshape(x, [1, 1, 1, x.size]);
    }
    else if (x.rank === 2) {
        x4D = reshape(x, [1, 1, x.shape[0], x.shape[1]]);
    }
    else if (x.rank === 3) {
        x4D = reshape(x, [1, x.shape[0], x.shape[1], x.shape[2]]);
    }
    else {
        x4D = x;
    }
    return x4D;
}

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Batch normalization.
 *
 * As described in
 * [http://arxiv.org/abs/1502.03167](http://arxiv.org/abs/1502.03167).
 *
 * Mean, variance, scale, and offset can be of two shapes:
 *   - The same shape as the input.
 *   - In the common case, the depth dimension is the last dimension of x, so
 *     the values would be a `tf.Tensor1D` of shape [depth].
 *
 * Also available are stricter rank-specific methods with the same signature
 * as this method that assert that parameters passed are of given rank
 *   - `tf.batchNorm2d`
 *   - `tf.batchNorm3d`
 *   - `tf.batchNorm4d`
 *
 * @param x The input Tensor.
 * @param mean A mean Tensor.
 * @param variance A variance Tensor.
 * @param offset An offset Tensor.
 * @param scale A scale Tensor.
 * @param varianceEpsilon A small float number to avoid dividing by 0.
 *
 * @doc {heading: 'Operations', subheading: 'Normalization'}
 */
function batchNorm_(x, mean, variance, offset, scale, varianceEpsilon) {
    if (varianceEpsilon == null) {
        varianceEpsilon = 0.001;
    }
    const $x = convertToTensor(x, 'x', 'batchNorm');
    const $mean = convertToTensor(mean, 'mean', 'batchNorm');
    const $variance = convertToTensor(variance, 'variance', 'batchNorm');
    let $scale;
    if (scale != null) {
        $scale = convertToTensor(scale, 'scale', 'batchNorm');
    }
    let $offset;
    if (offset != null) {
        $offset = convertToTensor(offset, 'offset', 'batchNorm');
    }
    assert($mean.rank === $variance.rank, () => 'Batch normalization gradient requires mean and variance to have ' +
        'equal ranks.');
    assert($offset == null || $mean.rank === $offset.rank, () => 'Batch normalization gradient requires mean and offset to have ' +
        'equal ranks.');
    assert($scale == null || $mean.rank === $scale.rank, () => 'Batch normalization gradient requires mean and scale to have ' +
        'equal ranks.');
    const x4D = xAs4D($x);
    const inputs = {
        x: x4D,
        scale: $scale,
        offset: $offset,
        mean: $mean,
        variance: $variance
    };
    const attrs = { varianceEpsilon };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    const res = ENGINE.runKernel(FusedBatchNorm, inputs, attrs);
    return reshape(res, $x.shape);
}
const batchNorm = op({ batchNorm_ });

/**
 * Batch normalization, strictly for 2D. For the more relaxed version, see
 * `tf.batchNorm`.
 *
 * @param x The input Tensor.
 * @param mean A mean Tensor.
 * @param variance A variance Tensor.
 * @param offset An offset Tensor.
 * @param scale A scale Tensor.
 * @param varianceEpsilon A small float number to avoid dividing by 0.
 */
function batchNorm2d_(x, mean, variance, offset, scale, varianceEpsilon) {
    const $x = convertToTensor(x, 'x', 'batchNorm');
    const $mean = convertToTensor(mean, 'mean', 'batchNorm');
    const $variance = convertToTensor(variance, 'variance', 'batchNorm');
    let $scale;
    if (scale != null) {
        $scale = convertToTensor(scale, 'scale', 'batchNorm');
    }
    let $offset;
    if (offset != null) {
        $offset = convertToTensor(offset, 'offset', 'batchNorm');
    }
    assert($x.rank === 2, () => `Error in batchNorm2D: x must be rank 2 but got rank ` +
        `${$x.rank}.`);
    assert($mean.rank === 2 || $mean.rank === 1, () => `Error in batchNorm2D: mean must be rank 2 or rank 1 but ` +
        `got rank ${$mean.rank}.`);
    assert($variance.rank === 2 || $variance.rank === 1, () => `Error in batchNorm2D: variance must be rank 2 or rank 1 ` +
        `but got rank ${$variance.rank}.`);
    if ($scale != null) {
        assert($scale.rank === 2 || $scale.rank === 1, () => `Error in batchNorm2D: scale must be rank 2 or rank 1 ` +
            `but got rank ${$scale.rank}.`);
    }
    if ($offset != null) {
        assert($offset.rank === 2 || $offset.rank === 1, () => `Error in batchNorm2D: offset must be rank 2 or rank 1 ` +
            `but got rank ${$offset.rank}.`);
    }
    return batchNorm($x, $mean, $variance, $offset, $scale, varianceEpsilon);
}
op({ batchNorm2d_ });

/**
 * Batch normalization, strictly for 3D. For the more relaxed version, see
 * `tf.batchNorm`.
 *
 * @param x The input Tensor.
 * @param mean A mean Tensor.
 * @param variance A variance Tensor.
 * @param offset An offset Tensor.
 * @param scale A scale Tensor.
 * @param varianceEpsilon A small float number to avoid dividing by 0.
 */
function batchNorm3d_(x, mean, variance, offset, scale, varianceEpsilon) {
    const $x = convertToTensor(x, 'x', 'batchNorm');
    const $mean = convertToTensor(mean, 'mean', 'batchNorm');
    const $variance = convertToTensor(variance, 'variance', 'batchNorm');
    let $scale;
    if (scale != null) {
        $scale = convertToTensor(scale, 'scale', 'batchNorm');
    }
    let $offset;
    if (offset != null) {
        $offset = convertToTensor(offset, 'offset', 'batchNorm');
    }
    assert($x.rank === 3, () => `Error in batchNorm3D: x must be rank 3 but got rank ` +
        `${$x.rank}.`);
    assert($mean.rank === 3 || $mean.rank === 1, () => `Error in batchNorm3D: mean must be rank 3 or rank 1 but ` +
        `got rank ${$mean.rank}.`);
    assert($variance.rank === 3 || $variance.rank === 1, () => `Error in batchNorm3D: variance must be rank 3 or rank 1 ` +
        `but got rank ${$variance.rank}.`);
    if ($scale != null) {
        assert($scale.rank === 3 || $scale.rank === 1, () => `Error in batchNorm3D: scale must be rank 3 or rank 1 ` +
            `but got rank ${$scale.rank}.`);
    }
    if ($offset != null) {
        assert($offset.rank === 3 || $offset.rank === 1, () => `Error in batchNorm3D: offset must be rank 3 or rank 1 ` +
            `but got rank ${$offset.rank}.`);
    }
    return batchNorm($x, $mean, $variance, $offset, $scale, varianceEpsilon);
}
op({ batchNorm3d_ });

/**
 * Batch normalization, strictly for 4D. For the more relaxed version, see
 * `tf.batchNorm`.
 *
 * @param x The input Tensor.
 * @param mean A mean Tensor.
 * @param variance A variance Tensor.
 * @param offset An offset Tensor.
 * @param scale A scale Tensor.
 * @param varianceEpsilon A small float number to avoid dividing by 0.
 */
function batchNorm4d_(x, mean, variance, offset, scale, varianceEpsilon) {
    const $x = convertToTensor(x, 'x', 'batchNorm');
    const $mean = convertToTensor(mean, 'mean', 'batchNorm');
    const $variance = convertToTensor(variance, 'variance', 'batchNorm');
    let $scale;
    if (scale != null) {
        $scale = convertToTensor(scale, 'scale', 'batchNorm');
    }
    let $offset;
    if (offset != null) {
        $offset = convertToTensor(offset, 'offset', 'batchNorm');
    }
    assert($x.rank === 4, () => `Error in batchNorm4D: x must be rank 4 but got rank ` +
        `${$x.rank}.`);
    assert($mean.rank === 4 || $mean.rank === 1, () => `Error in batchNorm4D: mean must be rank 4 or rank 1 but ` +
        `got rank ${$mean.rank}.`);
    assert($variance.rank === 4 || $variance.rank === 1, () => `Error in batchNorm4D: variance must be rank 4 or rank 1 ` +
        `but got rank ${$variance.rank}.`);
    if ($scale != null) {
        assert($scale.rank === 4 || $scale.rank === 1, () => `Error in batchNorm4D: scale must be rank 4 or rank 1 ` +
            `but got rank ${$scale.rank}.`);
    }
    if ($offset != null) {
        assert($offset.rank === 4 || $offset.rank === 1, () => `Error in batchNorm4D: offset must be rank 4 or rank 1 ` +
            `but got rank ${$offset.rank}.`);
    }
    return batchNorm($x, $mean, $variance, $offset, $scale, varianceEpsilon);
}
op({ batchNorm4d_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Outputs a vector with length `size` and the same dtype as `weights`.
 *
 * If `weights` are empty, then index `i` stores the number of times the value
 * `i` is counted in `x`. If `weights` are non-empty, then index `i` stores the
 * sum of the value in `weights` at each index where the corresponding value in
 * `x` is `i`.
 *
 * Values in `x` outside of the range [0, size) are ignored.
 *
 * @param x The input int tensor, rank 1.
 * @param weights The weights tensor, must have the same shape as x, or a
 *     length-0 Tensor, in which case it acts as all weights equal to 1.
 * @param size Non-negative integer.
 *
 * @doc {heading: 'Operations', subheading: 'Reduction'}
 */
function bincount_(x, weights, size) {
    const $x = convertToTensor(x, 'x', 'bincount');
    const $weights = convertToTensor(weights, 'weights', 'bincount');
    assert($x.dtype === 'int32', () => `Error in bincount: input ` +
        `dtype must be int32, but got ${$x.dtype}`);
    assert(size >= 0, () => `size must be non-negative, but got ${size}.`);
    assert($weights.size === $x.size || $weights.size === 0, () => `Error in bincount: weights must have the same size as input or` +
        `0-length, but got input shape: ${$x.shape}, weights shape: ` +
        `${$weights.shape}.`);
    const inputs = { x: $x, weights: $weights };
    const attrs = { size };
    return ENGINE.runKernel(Bincount, inputs, attrs);
}
const bincount = op({ bincount_ });

/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Return the shape of s0 op s1 with broadcast.
 *
 * compute r0, the broadcasted shape as a tensor.
 * s0, s1 and r0 are all integer vectors.
 *
 * This function returns the shape of the result of an operation between
 * two tensors of size s0 and s1 performed with broadcast.
 *
 * @param s0 A tensor representing a shape
 * @param s1 A tensor representing a shape
 *
 * @doc {heading: 'Tensors', subheading: 'Transformations'}
 */
function broadcastArgs_(s0, s1) {
    const shape1Input = convertToTensor(s0, 's0', 'broadcastArgs', 'int32');
    const shape2Input = convertToTensor(s1, 's1', 'broadcastArgs', 'int32');
    if (shape1Input.rank !== 1) {
        throw new Error('broadcastArgs(): first input must be a vector (rank=1). ' +
            `Has rank ${shape1Input.rank}`);
    }
    if (shape2Input.rank !== 1) {
        throw new Error('broadcastArgs(): second input must be a vector (rank=1). ' +
            `Has rank ${shape2Input.rank}`);
    }
    const inputs = { s0: shape1Input, s1: shape2Input };
    return ENGINE.runKernel(BroadcastArgs, inputs);
}
op({ broadcastArgs_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Broadcast an array to a compatible shape NumPy-style.
 *
 * The tensor's shape is compared to the broadcast shape from end to beginning.
 * Ones are prepended to the tensor's shape until it has the same length as
 * the broadcast shape. If input.shape[i]==shape[i], the (i+1)-th axis is
 * already broadcast-compatible. If input.shape[i]==1 and shape[i]==N, then
 * the input tensor is tiled N times along that axis (using tf.tile).
 *
 * @param input The tensor that is to be broadcasted.
 * @param shape The input is to be broadcast to this shape.
 *
 * @doc {heading: 'Tensors', subheading: 'Transformations'}
 */
function broadcastTo_(x, shape) {
    let input = convertToTensor(x, 'broadcastTo', 'x');
    const xShape = input.shape;
    if (shape.some(d => !(d > 0) || d % 1 !== 0)) {
        throw new Error(`broadcastTo(): Invalid broadcast shape [${shape}].`);
    }
    if (shape.length < input.rank) {
        throw new Error(`broadcastTo(): shape.length=${shape.length} < input.rank=${input.rank}.`);
    }
    if (shape.length > input.rank) {
        const newShape = input.shape.slice();
        while (newShape.length < shape.length) {
            newShape.unshift(1);
        }
        input = reshape(input, newShape);
    }
    const inputShape = input.shape;
    const reps = Array.from(shape);
    for (let i = shape.length - 1; i >= 0; i--) {
        if (inputShape[i] === shape[i]) {
            reps[i] = 1;
        }
        else if (input.shape[i] !== 1) {
            throw new Error(`broadcastTo(): [${xShape}] cannot be broadcast to [${shape}].`);
        }
    }
    const axes = reps.map((n, i) => n > 1 ? i : -1).filter(i => i >= 0);
    if (axes.length === 0) {
        return clone(input);
    }
    // TODO call broadcastTo kernel directly once backends implement broadcstTo
    const inputs = { x: input };
    const attrs = { reps };
    return ENGINE.runKernel(Tile, inputs, attrs);
}
const broadcastTo = op({ broadcastTo_ });

/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Creates an empty `tf.TensorBuffer` with the specified `shape` and `dtype`.
 *
 * The values are stored in CPU as `TypedArray`. Fill the buffer using
 * `buffer.set()`, or by modifying directly `buffer.values`.
 *
 * When done, call `buffer.toTensor()` to get an immutable `tf.Tensor` with
 * those values.
 *
 * ```js
 * // Create a buffer and set values at particular indices.
 * const buffer = tf.buffer([2, 2]);
 * buffer.set(3, 0, 0);
 * buffer.set(5, 1, 0);
 *
 * // Convert the buffer back to a tensor.
 * buffer.toTensor().print();
 * ```
 *
 * @param shape An array of integers defining the output tensor shape.
 * @param dtype The dtype of the buffer. Defaults to 'float32'.
 * @param values The values of the buffer as `TypedArray`. Defaults to
 * zeros.
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */
function buffer(shape, dtype = 'float32', values) {
    dtype = dtype || 'float32';
    assertNonNegativeIntegerDimensions(shape);
    return new TensorBuffer(shape, dtype, values);
}

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes ceiling of input `tf.Tensor` element-wise: `ceil(x)`
 *
 * ```js
 * const x = tf.tensor1d([.6, 1.1, -3.3]);
 *
 * x.ceil().print();  // or tf.ceil(x)
 * ```
 * @param x The input Tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function ceil_(x) {
    const $x = convertToTensor(x, 'x', 'ceil', 'float32');
    const inputs = { x: $x };
    return ENGINE.runKernel(Ceil, inputs);
}
op({ ceil_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Creates a `tf.Tensor` filled with a scalar value.
 *
 * ```js
 * tf.fill([2, 2], 4).print();
 * ```
 *
 * @param shape An array of integers defining the output tensor shape.
 * @param value The scalar value to fill the tensor with.
 * @param dtype The type of an element in the resulting tensor. Defaults to
 * 'float'.
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */
function fill(shape, value, dtype) {
    const attrs = { shape, value, dtype };
    return ENGINE.runKernel(Fill, {}, attrs);
}

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Clips values element-wise. `max(min(x, clipValueMax), clipValueMin)`
 *
 * ```js
 * const x = tf.tensor1d([-1, 2, -3, 4]);
 *
 * x.clipByValue(-2, 3).print();  // or tf.clipByValue(x, -2, 3)
 * ```
 * @param x The input tensor.
 * @param clipValueMin Lower bound of range to be clipped to.
 * @param clipValueMax Upper bound of range to be clipped to.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function clipByValue_(x, clipValueMin, clipValueMax) {
    const $x = convertToTensor(x, 'x', 'clipByValue');
    assert((clipValueMin <= clipValueMax), () => `Error in clip: min (${clipValueMin}) must be ` +
        `less than or equal to max (${clipValueMax}).`);
    if (clipValueMin === clipValueMax) {
        return fill($x.shape, clipValueMin, $x.dtype);
    }
    const inputs = { x: $x };
    const attrs = { clipValueMin, clipValueMax };
    return ENGINE.runKernel(ClipByValue, inputs, attrs);
}
op({ clipByValue_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Converts two real numbers to a complex number.
 *
 * Given a tensor `real` representing the real part of a complex number, and a
 * tensor `imag` representing the imaginary part of a complex number, this
 * operation returns complex numbers elementwise of the form [r0, i0, r1, i1],
 * where r represents the real part and i represents the imag part.
 *
 * The input tensors real and imag must have the same shape.
 *
 * ```js
 * const real = tf.tensor1d([2.25, 3.25]);
 * const imag = tf.tensor1d([4.75, 5.75]);
 * const complex = tf.complex(real, imag);
 *
 * complex.print();
 * ```
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */
function complex_(real, imag) {
    const $real = convertToTensor(real, 'real', 'complex');
    const $imag = convertToTensor(imag, 'imag', 'complex');
    assertShapesMatch($real.shape, $imag.shape, `real and imag shapes, ${$real.shape} and ${$imag.shape}, ` +
        `must match in call to tf.complex().`);
    const inputs = { real: $real, imag: $imag };
    return ENGINE.runKernel(Complex, inputs);
}
const complex = op({ complex_ });

/**
 * Concatenates a list of`tf.Tensor1D`s along an axis. See `concat` for details.
 *
 * For example, if:
 * A: shape(3) = |r1, g1, b1|
 * B: shape(2) = |r2, g2|
 * C = tf.concat1d([A, B]) == |r1, g1, b1, r2, g2|
 *
 * @param tensors A list of`tf.Tensor`s to concatenate.
 * @return The concatenated array.
 */
function concat1d_(tensors) {
    return concat(tensors, 0 /* axis */);
}
op({ concat1d_ });

/**
 * Concatenates a list of`tf.Tensor2D`s along an axis. See `concat` for details.
 *
 * For example, if:
 * A: shape(2, 3) = | r1, g1, b1 |
 *                  | r2, g2, b2 |
 *
 * B: shape(2, 3) = | r3, g3, b3 |
 *                  | r4, g4, b4 |
 *
 * C = tf.concat2d([A, B], axis)
 *
 * if axis = 0:
 * C: shape(4, 3) = | r1, g1, b1 |
 *                  | r2, g2, b2 |
 *                  | r3, g3, b3 |
 *                  | r4, g4, b4 |
 *
 * if axis = 1:
 * C = shape(2, 6) = | r1, g1, b1, r3, g3, b3 |
 *                   | r2, g2, b2, r4, g4, b4 |
 *
 *
 * @param tensors A list of `tf.Tensor`s to concatenate.
 * @param axis The axis to concatenate along.
 * @return The concatenated array.
 */
function concat2d_(tensors, axis) {
    return concat(tensors, axis);
}
op({ concat2d_ });

/**
 * Concatenates a list of `tf.Tensor3D`s along an axis.
 * See `concat` for details.
 *
 * For example, if:
 * A: shape(2, 1, 3) = | r1, g1, b1 |
 *                     | r2, g2, b2 |
 *
 * B: shape(2, 1, 3) = | r3, g3, b3 |
 *                     | r4, g4, b4 |
 *
 * C = tf.concat3d([A, B], axis)
 *
 * if axis = 0:
 * C: shape(4, 1, 3) = | r1, g1, b1 |
 *                     | r2, g2, b2 |
 *                     | r3, g3, b3 |
 *                     | r4, g4, b4 |
 *
 * if axis = 1:
 * C: shape(2, 2, 3) = | r1, g1, b1, r3, g3, b3 |
 *                     | r2, g2, b2, r4, g4, b4 |
 *
 * if axis = 2:
 * C = shape(2, 1, 6) = | r1, g1, b1, r3, g3, b3 |
 *                      | r2, g2, b2, r4, g4, b4 |
 *
 * @param tensors A list of`tf.Tensor`s to concatenate.
 * @param axis The axis to concate along.
 * @return The concatenated array.
 */
function concat3d_(tensors, axis) {
    return concat(tensors, axis);
}
op({ concat3d_ });

/**
 * Concatenates a list of `tf.Tensor4D`s along an axis.
 * See `concat` for details.
 *
 * @param tensors A list of `tf.Tensor`s to concatenate.
 * @param axis The axis to concate along.
 * @return The concatenated array.
 */
function concat4d_(tensors, axis) {
    return concat(tensors, axis);
}
op({ concat4d_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes a 2D convolution over the input x.
 *
 * @param x The input tensor, of rank 4 or rank 3, of shape
 *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is
 * assumed.
 * @param filter The filter, rank 4, of shape
 *     `[filterHeight, filterWidth, inDepth, outDepth]`.
 * @param strides The strides of the convolution: `[strideHeight,
 * strideWidth]`.
 * @param pad The type of padding algorithm.
 *    - `same` and stride 1: output will be of same size as input,
 *       regardless of filter size.
 *    - `valid`: output will be smaller than input if filter is larger
 *       than 1x1.
 *   - For more info, see this guide:
 *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](
 *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)
 * @param dataFormat: An optional string from: "NHWC", "NCHW". Defaults to
 *     "NHWC". Specify the data format of the input and output data. With the
 *     default format "NHWC", the data is stored in the order of: [batch,
 *     height, width, channels].
 * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`
 *     in which we sample input values across the height and width dimensions
 *     in atrous convolution. Defaults to `[1, 1]`. If `dilations` is a single
 *     number, then `dilationHeight == dilationWidth`. If it is greater than
 *     1, then all values of `strides` must be 1.
 * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is
 *     provided, it will default to truncate.
 *
 * @doc {heading: 'Operations', subheading: 'Convolution'}
 */
function conv2d_(x, filter, strides, pad, dataFormat = 'NHWC', dilations = [1, 1], dimRoundingMode) {
    const $x = convertToTensor(x, 'x', 'conv2d', 'float32');
    const $filter = convertToTensor(filter, 'filter', 'conv2d', 'float32');
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert(x4D.rank === 4, () => `Error in conv2d: input must be rank 4, but got rank ${x4D.rank}.`);
    assert($filter.rank === 4, () => `Error in conv2d: filter must be rank 4, but got rank ` +
        `${$filter.rank}.`);
    checkPadOnDimRoundingMode('conv2d', pad, dimRoundingMode);
    const inDepth = dataFormat === 'NHWC' ? x4D.shape[3] : x4D.shape[1];
    assert(inDepth === $filter.shape[2], () => `Error in conv2d: depth of input (${inDepth}) must match ` +
        `input depth for filter ${$filter.shape[2]}.`);
    assert(eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in conv2D: Either strides or dilations must be 1. ' +
        `Got strides ${strides} and dilations '${dilations}'`);
    const inputs = { x: x4D, filter: $filter };
    const attrs = { strides, pad, dataFormat, dilations, dimRoundingMode };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    const res = ENGINE.runKernel(Conv2D, inputs, attrs);
    if (reshapedTo4D) {
        return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
}
const conv2d = op({ conv2d_ });

/**
 * Computes a 1D convolution over the input x.
 *
 * @param x The input tensor, of rank 3 or rank 2, of shape
 *     `[batch, width, inChannels]`. If rank 2, batch of 1 is assumed.
 * @param filter The filter, rank 3, of shape
 *     `[filterWidth, inDepth, outDepth]`.
 * @param stride The number of entries by which the filter is moved right at
 *     each step.
 * @param pad The type of padding algorithm.
 *    - `same` and stride 1: output will be of same size as input,
 *       regardless of filter size.
 *    - `valid`: output will be smaller than input if filter is larger
 *       than 1x1.
 *   - For more info, see this guide:
 *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](
 *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)
 * @param dataFormat An optional string from "NWC", "NCW". Defaults to "NWC",
 *     the data is stored in the order of [batch, in_width, in_channels]. Only
 *     "NWC" is currently supported.
 * @param dilation The dilation rate in which we sample input values in
 *     atrous convolution. Defaults to `1`. If it is greater than 1, then
 *     stride must be `1`.
 * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is
 *     provided, it will default to truncate.
 *
 * @doc {heading: 'Operations', subheading: 'Convolution'}
 */
function conv1d_(x, filter, stride, pad, dataFormat = 'NWC', dilation = 1, dimRoundingMode) {
    const $x = convertToTensor(x, 'x', 'conv1d');
    const $filter = convertToTensor(filter, 'filter', 'conv1d');
    let x3D = $x;
    let reshapedTo3D = false;
    if ($x.rank === 2) {
        reshapedTo3D = true;
        x3D = reshape($x, [1, $x.shape[0], $x.shape[1]]);
    }
    assert(x3D.rank === 3, () => `Error in conv1d: input must be rank 3, but got rank ${x3D.rank}.`);
    assert($filter.rank === 3, () => `Error in conv1d: filter must be rank 3, but got rank ` +
        `${$filter.rank}.`);
    checkPadOnDimRoundingMode('conv1d', pad, dimRoundingMode);
    assert(x3D.shape[2] === $filter.shape[1], () => `Error in conv1d: depth of input (${x3D.shape[2]}) must match ` +
        `input depth for filter ${$filter.shape[1]}.`);
    assert(eitherStridesOrDilationsAreOne(stride, dilation), () => 'Error in conv1D: Either stride or dilation must be 1. ' +
        `Got stride ${stride} and dilation '${dilation}'`);
    assert(dataFormat === 'NWC', () => `Error in conv1d: got dataFormat of ${dataFormat} but only NWC is currently supported.`);
    const filter4D = reshape($filter, [1, $filter.shape[0], $filter.shape[1], $filter.shape[2]]);
    const input4D = reshape(x3D, [x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]]);
    const strides = [1, stride];
    const dilations = [1, dilation];
    const conv2dDataFormat = 'NHWC';
    const res = conv2d(input4D, filter4D, strides, pad, conv2dDataFormat, dilations, dimRoundingMode);
    if (reshapedTo3D) {
        return reshape(res, [res.shape[2], res.shape[3]]);
    }
    return reshape(res, [res.shape[0], res.shape[2], res.shape[3]]);
}
op({ conv1d_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the derivative of the input of a 2D convolution.
 *
 * @param xShape The shape of the input: [batch, height, width, inDepth].
 * If length of 3, batch of 1 is assumed.
 * @param dy The derivative of the output, of rank 4 or rank 3 of shape
 *   `[batch, outHeight, outWidth, outDepth]`. If rank 3, batch of 1 is
 * assumed.
 * @param filter The filter, rank 4, of shape
 *     `[filterHeight, filterWidth, inDepth, outDepth]`.
 * @param strides The strides of the convolution: `[strideHeight,
 * strideWidth]`.
 * @param pad The type of padding algorithm used:
 *    - `same` and stride 1: output will be of same size as input,
 *       regardless of filter size.
 *    - `valid`: output will be smaller than input if filter is larger
 *       than 1x1.
 * @param dataFormat: An optional string from: "NHWC", "NCHW". Defaults to
 *     "NHWC". Specify the data format of the input and output data. With the
 *     default format "NHWC", the data is stored in the order of: [batch,
 *     height, width, channels].
 * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is
 *     provided, it will default to truncate.
 */
function conv2DBackpropInput_(xShape, dy, filter, strides, pad, dataFormat = 'NHWC', dimRoundingMode) {
    assert(xShape.length === dy.rank, () => `Length of inShape ` +
        `(${xShape.length}) and rank of dy (${dy.rank}) must match`);
    let xShape4D = xShape;
    let dy4D = dy;
    let reshapedTo4D = false;
    if (dy.rank === 3) {
        reshapedTo4D = true;
        dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
        xShape4D = [1, xShape[0], xShape[1], xShape[2]];
    }
    assert(xShape4D.length === 4, () => `Error in conv2dDerInput: inShape must be length 4, but got length ` +
        `${xShape4D.length}.`);
    assert(dy4D.rank === 4, () => `Error in conv2dDerInput: dy must be rank 4, but got ` +
        `rank ${dy4D.rank}`);
    assert(filter.rank === 4, () => `Error in conv2dDerInput: filter must be rank 4, but got ` +
        `rank ${filter.rank}`);
    const inDepth = dataFormat === 'NHWC' ? xShape4D[3] : xShape4D[1];
    const outDepth = dataFormat === 'NHWC' ? dy4D.shape[3] : dy4D.shape[1];
    assert(inDepth === filter.shape[2], () => `Error in conv2dDerInput: depth of input (${inDepth}) must ` +
        `match input depth for filter ${filter.shape[2]}.`);
    assert(outDepth === filter.shape[3], () => `Error in conv2dDerInput: depth of output (${outDepth}) must ` +
        `match output depth for filter ${filter.shape[3]}.`);
    checkPadOnDimRoundingMode('conv2dDerInput', pad, dimRoundingMode);
    const inputs = { dy: dy4D, filter };
    const attrs = { strides, pad, dataFormat, dimRoundingMode, inputShape: xShape4D };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    const res = ENGINE.runKernel(Conv2DBackpropInput, inputs, attrs);
    if (reshapedTo4D) {
        return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
}
const conv2DBackpropInput = op({ conv2DBackpropInput_ });

/**
 * Computes the transposed 2D convolution of an image, also known as a
 * deconvolution.
 *
 * @param x The input image, of rank 4 or rank 3, of shape
 *   `[batch, height, width, inDepth]`. If rank 3, batch of 1 is assumed.
 * @param filter The filter, rank 4, of shape
 *     `[filterHeight, filterWidth, outDepth, inDepth]`.
 *     `inDepth` must match `inDepth` in `x`.
 * @param outputShape Output shape, of rank 4 or rank 3:
 *     `[batch, height, width, outDepth]`. If rank 3, batch of 1 is assumed.
 * @param strides The strides of the original convolution:
 *     `[strideHeight, strideWidth]`.
 * @param pad  The type of padding algorithm used in the non-transpose version
 *    of the op.
 * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is
 *     provided, it will default to truncate.
 *
 * @doc {heading: 'Operations', subheading: 'Convolution'}
 */
function conv2dTranspose_(x, filter, outputShape, strides, pad, dimRoundingMode) {
    const $x = convertToTensor(x, 'x', 'conv2dTranspose');
    const $filter = convertToTensor(filter, 'filter', 'conv2dTranspose');
    return conv2DBackpropInput(outputShape, $x, $filter, strides, pad, 'NHWC', dimRoundingMode);
}
op({ conv2dTranspose_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes a 3D convolution over the input x.
 *
 * @param x The input tensor, of rank 5 or rank 4, of shape
 *     `[batch, depth, height, width, channels]`. If rank 4,
 * batch of 1 is assumed.
 * @param filter The filter, rank 5, of shape
 *     `[filterDepth, filterHeight, filterWidth, inChannels, outChannels]`.
 *      inChannels must match between input and filter.
 * @param strides The strides of the convolution: `[strideDepth, strideHeight,
 * strideWidth]`.
 * @param pad The type of padding algorithm.
 *    - `same` and stride 1: output will be of same size as input,
 *       regardless of filter size.
 *    - `valid`: output will be smaller than input if filter is larger
 *       than 1x1.
 *   - For more info, see this guide:
 *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](
 *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)
 * @param dataFormat: An optional string from: "NDHWC", "NCDHW". Defaults to
 *     "NDHWC". Specify the data format of the input and output data. With the
 *     default format "NDHWC", the data is stored in the order of: [batch,
 *     depth, height, width, channels]. Only "NDHWC" is currently supported.
 * @param dilations The dilation rates: `[dilationDepth, dilationHeight,
 *     dilationWidth]` in which we sample input values across the height
 *     and width dimensions in atrous convolution. Defaults to `[1, 1, 1]`.
 *     If `dilations` is a single number, then
 *     `dilationDepth == dilationHeight == dilationWidth`. If it is greater
 *     than 1, then all values of `strides` must be 1.
 *
 * @doc {heading: 'Operations', subheading: 'Convolution'}
 */
function conv3d_(x, filter, strides, pad, dataFormat = 'NDHWC', dilations = [1, 1, 1]) {
    const $x = convertToTensor(x, 'x', 'conv3d');
    const $filter = convertToTensor(filter, 'filter', 'conv3d');
    let x5D = $x;
    let reshapedTo5D = false;
    if ($x.rank === 4) {
        reshapedTo5D = true;
        x5D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
    }
    assert(x5D.rank === 5, () => `Error in conv3d: input must be rank 5, but got rank ${x5D.rank}.`);
    assert($filter.rank === 5, () => `Error in conv3d: filter must be rank 5, but got rank ` +
        `${$filter.rank}.`);
    assert(x5D.shape[4] === $filter.shape[3], () => `Error in conv3d: depth of input (${x5D.shape[4]}) must match ` +
        `input depth for filter ${$filter.shape[3]}.`);
    assert(eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in conv3D: Either strides or dilations must be 1. ' +
        `Got strides ${strides} and dilations '${dilations}'`);
    assert(dataFormat === 'NDHWC', () => `Error in conv3d: got dataFormat of ${dataFormat} but only NDHWC is currently supported.`);
    const inputs = { x: x5D, filter: $filter };
    const attrs = { strides, pad, dataFormat, dilations };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    const res = ENGINE.runKernel(Conv3D, inputs, attrs);
    if (reshapedTo5D) {
        return reshape(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
    }
    return res;
}
op({ conv3d_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the derivative of the input of a 3D convolution.
 *
 * @param xShape The shape of the input: [batch, depth, height, width,
 * in_channels]. If length of 4, batch of 1 is assumed.
 * @param dy The derivative of the output, of rank 5 or rank 4 of shape
 *   `[batch, outDepth, outHeight, outWidth, in_channels]`.
 * If rank 4, batch of 1 is assumed.
 * @param filter The filter, rank 5, of shape
 *     `[filterDepth, filterHeight, filterWidth, inDepth, outDepth]`.
 * @param strides The strides of the convolution: `[strideDepth, strideHeight,
 * strideWidth]`.
 * @param pad The type of padding algorithm used:
 *    - `same` and stride 1: output will be of same size as input,
 *       regardless of filter size.
 *    - `valid`: output will be smaller than input if filter is larger
 *       than 1x1.
 */
function conv3DBackpropInput_(xShape, dy, filter, strides, pad) {
    assert(xShape.length === dy.rank, () => `Length of inShape ` +
        `(${xShape.length}) and rank of dy (${dy.rank}) must match`);
    let xShape5D = xShape;
    let dy5D = dy;
    let reshapedTo5D = false;
    if (dy.rank === 4) {
        reshapedTo5D = true;
        dy5D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2], dy.shape[3]]);
        xShape5D = [1, xShape[0], xShape[1], xShape[2], xShape[3]];
    }
    const inDepth = xShape5D[4];
    const outDepth = dy5D.shape[4];
    assert(xShape5D.length === 5, () => `Error in conv3dDerInput: inShape must be length 5, but got length ` +
        `${xShape5D.length}.`);
    assert(dy5D.rank === 5, () => `Error in conv3dDerInput: dy must be rank 5, but got ` +
        `rank ${dy5D.rank}`);
    assert(filter.rank === 5, () => `Error in conv3dDerInput: filter must be rank 5, but got ` +
        `rank ${filter.rank}`);
    assert(inDepth === filter.shape[3], () => `Error in conv3dDerInput: depth of input (${inDepth}) must ` +
        `match input depth for filter ${filter.shape[3]}.`);
    assert(outDepth === filter.shape[4], () => `Error in conv3dDerInput: depth of output (${outDepth}) must ` +
        `match output depth for filter ${filter.shape[4]}.`);
    const inputs = { dy: dy5D, filter };
    const attrs = { pad, strides, inputShape: xShape5D };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    const res = ENGINE.runKernel(Conv3DBackpropInputV2, inputs, attrs);
    if (reshapedTo5D) {
        return reshape(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
    }
    return res;
}
const conv3DBackpropInput = op({ conv3DBackpropInput_ });

/**
 * Computes the transposed 3D convolution of a volume, also known as a
 * deconvolution.
 *
 * @param x The input image, of rank 5 or rank 4, of shape
 *   `[batch, depth, height, width, inDepth]`. If rank 4, batch of 1 is assumed.
 * @param filter The filter, rank 4, of shape
 *     `[depth, filterHeight, filterWidth, outDepth, inDepth]`.
 *     `inDepth` must match `inDepth` in `x`.
 * @param outputShape Output shape, of rank 5 or rank 4:
 *     `[batch, depth, height, width, outDepth]`. If rank 3, batch of 1 is
 *    assumed.
 * @param strides The strides of the original convolution:
 *     `[strideDepth, strideHeight, strideWidth]`.
 * @param pad  The type of padding algorithm used in the non-transpose version
 *    of the op.
 *
 * @doc {heading: 'Operations', subheading: 'Convolution'}
 */
function conv3dTranspose_(x, filter, outputShape, strides, pad) {
    const $x = convertToTensor(x, 'x', 'conv3dTranspose');
    const $filter = convertToTensor(filter, 'filter', 'conv3dTranspose');
    return conv3DBackpropInput(outputShape, $x, $filter, strides, pad);
}
op({ conv3dTranspose_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes cos of the input `tf.Tensor` element-wise: `cos(x)`
 *
 * ```js
 * const x = tf.tensor1d([0, Math.PI / 2, Math.PI * 3 / 4]);
 *
 * x.cos().print();  // or tf.cos(x)
 * ```
 * @param x The input tensor. Must be float32 type.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function cos_(x) {
    const $x = convertToTensor(x, 'x', 'cos', 'float32');
    const inputs = { x: $x };
    return ENGINE.runKernel(Cos, inputs);
}
op({ cos_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes hyperbolic cos of the input `tf.Tensor` element-wise: `cosh(x)`
 *
 * ```js
 * const x = tf.tensor1d([0, 1, -1, .7]);
 *
 * x.cosh().print();  // or tf.cosh(x)
 * ```
 * @param x The input tensor. Must be float32 type.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function cosh_(x) {
    const $x = convertToTensor(x, 'x', 'cosh', 'float32');
    const inputs = { x: $x };
    return ENGINE.runKernel(Cosh, inputs);
}
op({ cosh_ });

/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the cumulative product of a `tf.Tensor` along `axis`.
 *
 * ```js
 * const x = tf.tensor([1, 2, 3, 4]);
 * x.cumprod().print();
 * ```
 * ```js
 * const x = tf.tensor([[1, 2], [3, 4]]);
 * x.cumprod().print();
 * ```
 *
 * @param x The input tensor to cumulatively multiply.
 * @param axis The axis along which to multiply. Optional. Defaults to 0.
 * @param exclusive Whether to perform exclusive cumulative product. Optional.
 *     Defaults to false. If set to true then the product of each tensor entry
 *     does not include its own value, but only the values previous to it
 *     along the specified axis.
 * @param reverse Whether to multiply in the opposite direction. Optional.
 *     Defaults to false.
 *
 * @doc {heading: 'Operations', subheading: 'Scan'}
 */
function cumprod_(x, axis = 0, exclusive = false, reverse = false) {
    const $x = convertToTensor(x, 'x', 'cumprod');
    const inputs = { x: $x };
    const attrs = { axis, exclusive, reverse };
    return ENGINE.runKernel(Cumprod, inputs, attrs);
}
op({ cumprod_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the cumulative sum of a `tf.Tensor` along `axis`.
 *
 * ```js
 * const x = tf.tensor([1, 2, 3, 4]);
 * x.cumsum().print();
 * ```
 * ```js
 * const x = tf.tensor([[1, 2], [3, 4]]);
 * x.cumsum().print();
 * ```
 *
 * @param x The input tensor to be summed.
 * @param axis The axis along which to sum. Optional. Defaults to 0.
 * @param exclusive Whether to perform exclusive cumulative sum. Optional.
 *     Defaults to false. If set to true then the sum of each tensor entry
 *     does not include its own value, but only the values previous to it
 *     along the specified axis.
 * @param reverse Whether to sum in the opposite direction. Optional.
 *     Defaults to false.
 *
 * @doc {heading: 'Operations', subheading: 'Scan'}
 */
function cumsum_(x, axis = 0, exclusive = false, reverse = false) {
    const $x = convertToTensor(x, 'x', 'cumsum');
    const inputs = { x: $x };
    const attrs = { axis, exclusive, reverse };
    return ENGINE.runKernel(Cumsum, inputs, attrs);
}
op({ cumsum_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Outputs a vector with length `size` and the same dtype as `weights`.
 *
 * If `weights` are empty, then index `i` stores the number of times the value
 * `i` is counted in `x`. If `weights` are non-empty, then index `i` stores the
 * sum of the value in `weights` at each index where the corresponding value in
 * `x` is `i`.
 *
 * Values in `x` outside of the range [0, size) are ignored.
 *
 * @param x The input int tensor, rank 1 or rank 2.
 * @param weights The weights tensor, must have the same shape as x, or a
 *     length-0 Tensor, in which case it acts as all weights equal to 1.
 * @param size Non-negative integer.
 * @param binaryOutput Optional. Whether the kernel should count the appearance
 *     or number of occurrences. Defaults to False.
 *
 * @doc {heading: 'Operations', subheading: 'Reduction'}
 */
function denseBincount_(x, weights, size, binaryOutput = false) {
    const $x = convertToTensor(x, 'x', 'denseBincount');
    const $weights = convertToTensor(weights, 'weights', 'denseBincount');
    assert($x.dtype === 'int32', () => `Error in denseBincount: input ` +
        `dtype must be int32, but got ${$x.dtype}`);
    assert($x.rank <= 2, () => `Error in denseBincount: input must be at most rank 2, but got ` +
        `rank ${$x.rank}.`);
    assert(size >= 0, () => `size must be non-negative, but got ${size}.`);
    assert($weights.size === $x.size || $weights.size === 0, () => `Error in denseBincount: weights must have the same shape as x or ` +
        `0-length, but got x shape: ${$x.shape}, weights shape: ` +
        `${$weights.shape}.`);
    const inputs = { x: $x, weights: $weights };
    const attrs = { size, binaryOutput };
    return ENGINE.runKernel(DenseBincount, inputs, attrs);
}
op({ denseBincount_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Rearranges data from depth into blocks of spatial data. More specifically,
 * this op outputs a copy of the input tensor where values from the `depth`
 * dimension are moved in spatial blocks to the `height` and `width` dimensions.
 * The attr `blockSize` indicates the input block size and how the data is
 * moved.
 *
 *  - Chunks of data of size `blockSize * blockSize` from depth are rearranged
 * into non-overlapping blocks of size `blockSize x blockSize`
 *
 *  - The width the output tensor is `inputWidth * blockSize`, whereas the
 * height is `inputHeight * blockSize`
 *
 *  - The Y, X coordinates within each block of the output image are determined
 * by the high order component of the input channel index
 *
 *  - The depth of the input tensor must be divisible by `blockSize *
 * blockSize`
 *
 * The `dataFormat` attr specifies the layout of the input and output tensors
 * with the following options: "NHWC": [ `batch, height, width, channels` ]
 * "NCHW": [ `batch, channels, height, width` ]
 *
 * ```js
 * const x = tf.tensor4d([1, 2, 3, 4], [1, 1, 1, 4]);
 * const blockSize = 2;
 * const dataFormat = "NHWC";
 *
 * tf.depthToSpace(x, blockSize, dataFormat).print();
 * ```
 *
 * @param x The input tensor of rank 4
 * @param blockSIze  An `int` that is `>= 2`. The size of the spatial block
 * @param dataFormat An optional string from: "NHWC", "NCHW". Defaults to "NHWC"
 *
 * @doc {heading: 'Tensors', subheading: 'Transformations'}
 */
function depthToSpace_(x, blockSize, dataFormat = 'NHWC') {
    const $x = convertToTensor(x, 'x', 'depthToSpace', 'float32');
    const inputHeight = (dataFormat === 'NHWC') ? $x.shape[1] : $x.shape[2];
    const inputWidth = (dataFormat === 'NHWC') ? $x.shape[2] : $x.shape[3];
    const inputDepth = (dataFormat === 'NHWC') ? $x.shape[3] : $x.shape[1];
    assert(blockSize > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);
    assert(inputHeight * blockSize >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${inputHeight} and ${blockSize}  for depthToSpace with input shape
    ${$x.shape}`);
    assert(inputWidth * blockSize >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${inputWidth} and ${blockSize} for depthToSpace with input shape
        ${$x.shape}`);
    assert((inputDepth % (blockSize * blockSize) === 0), () => `Dimension size must be evenly divisible by ${blockSize * blockSize} but is ${inputDepth} for depthToSpace with input shape ${$x.shape}`);
    const inputs = { x: $x };
    const attrs = { blockSize, dataFormat };
    return ENGINE.runKernel(DepthToSpace, inputs, attrs);
}
op({ depthToSpace_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Depthwise 2D convolution.
 *
 * Given a 4D `input` array and a `filter` array of shape
 * `[filterHeight, filterWidth, inChannels, channelMultiplier]` containing
 * `inChannels` convolutional filters of depth 1, this op applies a
 * different filter to each input channel (expanding from 1 channel to
 * `channelMultiplier` channels for each), then concatenates the results
 * together. The output has `inChannels * channelMultiplier` channels.
 *
 * See
 * [https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d](
 *     https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d)
 * for more details.
 *
 * @param x The input tensor, of rank 4 or rank 3, of shape
 *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is
 * assumed.
 * @param filter The filter tensor, rank 4, of shape
 *     `[filterHeight, filterWidth, inChannels, channelMultiplier]`.
 * @param strides The strides of the convolution: `[strideHeight,
 * strideWidth]`. If strides is a single number, then `strideHeight ==
 * strideWidth`.
 * @param pad The type of padding algorithm.
 *   - `same` and stride 1: output will be of same size as input,
 *       regardless of filter size.
 *   - `valid`: output will be smaller than input if filter is larger
 *       than 1x1.
 *   - For more info, see this guide:
 *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](
 *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)
 * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`
 *     in which we sample input values across the height and width dimensions
 *     in atrous convolution. Defaults to `[1, 1]`. If `rate` is a single
 *     number, then `dilationHeight == dilationWidth`. If it is greater than
 *     1, then all values of `strides` must be 1.
 * @param dataFormat: An optional string from: "NHWC", "NCHW". Defaults to
 *     "NHWC". Specify the data format of the input and output data. With the
 *     default format "NHWC", the data is stored in the order of: [batch,
 *     height, width, channels]. Only "NHWC" is currently supported.
 * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is
 *     provided, it will default to truncate.
 *
 * @doc {heading: 'Operations', subheading: 'Convolution'}
 */
function depthwiseConv2d_(x, filter, strides, pad, dataFormat = 'NHWC', dilations = [1, 1], dimRoundingMode) {
    const $x = convertToTensor(x, 'x', 'depthwiseConv2d', 'float32');
    const $filter = convertToTensor(filter, 'filter', 'depthwiseConv2d', 'float32');
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert(x4D.rank === 4, () => `Error in depthwiseConv2d: input must be rank 4, but got ` +
        `rank ${x4D.rank}.`);
    assert($filter.rank === 4, () => `Error in depthwiseConv2d: filter must be rank 4, but got rank ` +
        `${$filter.rank}.`);
    const inChannels = dataFormat === 'NHWC' ? x4D.shape[3] : x4D.shape[1];
    assert(inChannels === $filter.shape[2], () => `Error in depthwiseConv2d: number of input channels ` +
        `(${inChannels}) must match the inChannels dimension in ` +
        `filter ${$filter.shape[2]}.`);
    checkPadOnDimRoundingMode('depthwiseConv2d', pad, dimRoundingMode);
    const inputs = { x: x4D, filter: $filter };
    const attrs = { strides, pad, dataFormat, dilations, dimRoundingMode };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    const res = ENGINE.runKernel(DepthwiseConv2dNative, inputs, attrs);
    if (reshapedTo4D) {
        return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
}
const depthwiseConv2d = op({ depthwiseConv2d_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns a diagonal tensor with given diagonal values.
 *
 * Given a diagonal, this operation returns a tensor with the diagonal and
 * everything else padded with zeros.
 *
 * Assume the input has dimensions `[D1,..., Dk]`, then the output is a tensor
 * of rank 2k with dimensions `[D1,..., Dk, D1,..., Dk]`
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3, 4]);
 *
 * tf.diag(x).print()
 * ```
 * ```js
 * const x = tf.tensor2d([1, 2, 3, 4, 5, 6, 6, 8], [4, 2])
 *
 * tf.diag(x).print()
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */
function diag_(x) {
    const $x = convertToTensor(x, 'x', 'diag');
    const inputs = { x: $x };
    return ENGINE.runKernel(Diag, inputs);
}
op({ diag_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the grayscale dilation over the input `x`.
 *
 * @param x The input tensor, rank 3 or rank 4 of shape
 *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.
 * @param filter The filter tensor, rank 3, of shape
 *     `[filterHeight, filterWidth, depth]`.
 * @param strides The strides of the sliding window for each dimension of the
 *     input tensor: `[strideHeight, strideWidth]`.
 *     If `strides` is a single number,
 *     then `strideHeight == strideWidth`.
 * @param pad The type of padding algorithm.
 *    - `same` and stride 1: output will be of same size as input,
 *       regardless of filter size.
 *    - `valid`: output will be smaller than input if filter is larger
 *       than 1*1x1.
 *    - For more info, see this guide:
 *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](
 *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)
 * @param dataFormat Specify the data format of the input and output data.
 *      Defaults to 'NHWC'. Only 'NHWC' is currently supported. With the
 *      default format "NHWC", the data is stored in the order of: [batch,
 *      height, width, channels].
 * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`
 *     in which we sample input values across the height and width dimensions
 *     for atrous morphological dilation. Defaults to `[1, 1]`. If `dilations`
 *     is a single number, then `dilationHeight == dilationWidth`. If it is
 *     greater than 1, then all values of `strides` must be 1.
 *
 * @doc {heading: 'Operations', subheading: 'Convolution'}
 */
function dilation2d_(x, filter, strides, pad, dilations = [1, 1], dataFormat = 'NHWC') {
    const $x = convertToTensor(x, 'x', 'dilation2d');
    const $filter = convertToTensor(filter, 'filter', 'dilation2d');
    assert($x.rank === 3 || $x.rank === 4, () => `Error in dilation2d: input must be rank 3 or 4, but got rank ` +
        `${$x.rank}.`);
    assert($filter.rank === 3, () => `Error in dilation2d: filter must be rank 3, but got rank ` +
        `${$filter.rank}.`);
    assert(dataFormat === 'NHWC', () => `Error in dilation2d: Only NHWC is currently supported, ` +
        `but got dataFormat of ${dataFormat}`);
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
        x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
        reshapedTo4D = true;
    }
    const inputs = { x: x4D, filter: $filter };
    const attrs = { strides, pad, dilations };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    const res = ENGINE.runKernel(Dilation2D, inputs, attrs);
    if (reshapedTo4D) {
        return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
}
op({ dilation2d_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Divides two `tf.Tensor`s element-wise, A / B. Supports broadcasting.
 * The result is rounded with floor function.
 *
 *
 * ```js
 * const a = tf.tensor1d([1, 4, 9, 16]);
 * const b = tf.tensor1d([1, 2, 3, 4]);
 *
 * a.floorDiv(b).print();  // or tf.div(a, b)
 * ```
 *
 * ```js
 * // Broadcast div a with b.
 * const a = tf.tensor1d([2, 4, 6, 8]);
 * const b = tf.scalar(2);
 *
 * a.floorDiv(b).print();  // or tf.floorDiv(a, b)
 * ```
 *
 * @param a The first tensor as the numerator.
 * @param b The second tensor as the denominator. Must have the same dtype as
 * `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Arithmetic'}
 */
function floorDiv_(a, b) {
    let $a = convertToTensor(a, 'a', 'floorDiv');
    let $b = convertToTensor(b, 'b', 'floorDiv');
    [$a, $b] = makeTypesMatch($a, $b);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(FloorDiv, inputs);
}
const floorDiv = op({ floorDiv_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Divides two `tf.Tensor`s element-wise, A / B. Supports broadcasting.
 *
 * ```js
 * const a = tf.tensor1d([1, 4, 9, 16]);
 * const b = tf.tensor1d([1, 2, 3, 4]);
 *
 * a.div(b).print();  // or tf.div(a, b)
 * ```
 *
 * ```js
 * // Broadcast div a with b.
 * const a = tf.tensor1d([2, 4, 6, 8]);
 * const b = tf.scalar(2);
 *
 * a.div(b).print();  // or tf.div(a, b)
 * ```
 *
 * @param a The first tensor as the numerator.
 * @param b The second tensor as the denominator. Must have the same dtype as
 * `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Arithmetic'}
 */
function div_(a, b) {
    let $a = convertToTensor(a, 'a', 'div');
    let $b = convertToTensor(b, 'b', 'div');
    [$a, $b] = makeTypesMatch($a, $b);
    if ($a.dtype === 'int32' && $b.dtype === 'int32') {
        return floorDiv($a, $b);
    }
    const inputs = { a: $a, b: $b };
    const attrs = {};
    // tslint:disable-next-line: no-unnecessary-type-assertion
    return ENGINE.runKernel(RealDiv, inputs, attrs);
}
const div = op({ div_ });

/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns the axes in the output space that should be reduced to produce
 * the input space.
 */
function getReductionAxes(inShape, outShape) {
    const result = [];
    for (let i = 0; i < outShape.length; i++) {
        const inDim = inShape[inShape.length - i - 1];
        const outAxis = outShape.length - i - 1;
        const outDim = outShape[outAxis];
        if (inDim == null || (inDim === 1 && outDim > 1)) {
            result.unshift(outAxis);
        }
    }
    return result;
}
function assertAndGetBroadcastShape(shapeA, shapeB) {
    const result = [];
    const l = Math.max(shapeA.length, shapeB.length);
    for (let i = 0; i < l; i++) {
        let a = shapeA[shapeA.length - i - 1];
        if (a == null) {
            a = 1;
        }
        let b = shapeB[shapeB.length - i - 1];
        if (b == null) {
            b = 1;
        }
        if (a === 1) {
            result.unshift(b);
        }
        else if (b === 1) {
            result.unshift(a);
        }
        else if (a !== b) {
            const errMsg = `Operands could not be broadcast together with shapes ` +
                `${shapeA} and ${shapeB}.`;
            throw Error(errMsg);
        }
        else {
            result.unshift(a);
        }
    }
    return result;
}

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns the truth value of (a == b) element-wise. Supports broadcasting.
 *
 * ```js
 * const a = tf.tensor1d([1, 2, 3]);
 * const b = tf.tensor1d([2, 2, 2]);
 *
 * a.equal(b).print();
 * ```
 *
 * @param a The first input tensor.
 * @param b The second input tensor. Must have the same dtype as `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Logical'}
 */
function equal_(a, b) {
    let $a = convertToTensor(a, 'a', 'equal', 'string_or_numeric');
    let $b = convertToTensor(b, 'b', 'equal', 'string_or_numeric');
    [$a, $b] = makeTypesMatch($a, $b);
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Equal, inputs);
}
const equal = op({ equal_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns the elements, either `a` or `b` depending on the `condition`.
 *
 * If the condition is true, select from `a`, otherwise select from `b`.
 *
 * ```js
 * const cond = tf.tensor1d([false, false, true], 'bool');
 * const a = tf.tensor1d([1 , 2, 3]);
 * const b = tf.tensor1d([-1, -2, -3]);
 *
 * a.where(cond, b).print();
 * ```
 *
 * @param condition The input condition. Must be of dtype bool.
 * @param a If `condition` is rank 1, `a` may have a higher rank but
 *     its first dimension must match the size of `condition`.
 * @param b A tensor with the same dtype as `a` and with shape that is
 *     compatible with `a`.
 * @return A tensor with same dtype as `a` and `b`, and shape that is
 *     broadcastable from `a` and `b`.
 *
 * @doc {heading: 'Operations', subheading: 'Logical'}
 */
function where_(condition, a, b) {
    const $a = convertToTensor(a, 'a', 'where');
    const $b = convertToTensor(b, 'b', 'where');
    const $condition = convertToTensor(condition, 'condition', 'where', 'bool');
    // TODO: move this logic to forward function when the broadcastTo op is
    // implemented in WASM.
    // Find the broadcastable shape for $condition, $a, and $b.
    const broadcastShape = assertAndGetBroadcastShape(assertAndGetBroadcastShape($condition.shape, $a.shape), $b.shape);
    const $broadcastedCondition = broadcastTo($condition, broadcastShape);
    const $broadcastedA = broadcastTo($a, broadcastShape);
    const $broadcastedB = broadcastTo($b, broadcastShape);
    const inputs = {
        condition: $broadcastedCondition,
        t: $broadcastedA,
        e: $broadcastedB
    };
    return ENGINE.runKernel(Select$1, inputs);
}
const where = op({ where_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Creates a `tf.Tensor` with all elements set to 0 with the same shape as the
 * given tensor.
 *
 * ```js
 * const x = tf.tensor([1, 2]);
 * tf.zerosLike(x).print();
 * ```
 *
 * @param x The tensor of required shape.
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */
function zerosLike_(x) {
    const $x = convertToTensor(x, 'x', 'zerosLike');
    const inputs = { x: $x };
    return ENGINE.runKernel(ZerosLike, inputs);
}
const zerosLike = op({ zerosLike_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Divides two `tf.Tensor`s element-wise, A / B. Supports broadcasting. Return 0
 * if denominator is 0.
 *
 *
 * ```js
 * const a = tf.tensor1d([1, 4, 9, 16]);
 * const b = tf.tensor1d([1, 2, 3, 4]);
 * const c = tf.tensor1d([0, 0, 0, 0]);
 *
 * a.divNoNan(b).print();  // or tf.divNoNan(a, b)
 * a.divNoNan(c).print();  // or tf.divNoNan(a, c)
 * ```
 *
 * ```js
 * // Broadcast div a with b.
 * const a = tf.tensor1d([2, 4, 6, 8]);
 * const b = tf.scalar(2);
 * const c = tf.scalar(0);
 *
 * a.divNoNan(b).print();  // or tf.divNoNan(a, b)
 * a.divNoNan(c).print();  // or tf.divNoNan(a, c)
 * ```
 *
 * @param a The first tensor as the numerator.
 * @param b The second tensor as the denominator. Must have the same dtype as
 * `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Arithmetic'}
 */
function divNoNan_(a, b) {
    // TODO: Make this into its own kernel.
    let $a = convertToTensor(a, 'a', 'div');
    let $b = convertToTensor(b, 'b', 'div');
    [$a, $b] = makeTypesMatch($a, $b);
    const divResult = div($a, $b);
    const zeros = zerosLike(divResult);
    const bEqualsZero = equal($b, zeros);
    return where(bEqualsZero, zeros, divResult);
}
op({ divNoNan_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the dot product of two matrices and/or vectors, `t1` and `t2`.
 *
 * ```js
 * const a = tf.tensor1d([1, 2]);
 * const b = tf.tensor2d([[1, 2], [3, 4]]);
 * const c = tf.tensor2d([[1, 2, 3], [4, 5, 6]]);
 *
 * a.dot(b).print();  // or tf.dot(a, b)
 * b.dot(a).print();
 * b.dot(c).print();
 * ```
 * @param t1 The first tensor in the dot operation.
 * @param t2 The second tensor in the dot operation.
 *
 * @doc {heading: 'Operations', subheading: 'Matrices'}
 */
function dot_(t1, t2) {
    const $t1 = convertToTensor(t1, 't1', 'dot');
    const $t2 = convertToTensor(t2, 't2', 'dot');
    assert(($t1.rank === 1 || $t1.rank === 2) && ($t2.rank === 1 || $t2.rank === 2), () => `Error in dot: inputs must all be rank 1 or 2, but got ranks ` +
        `${$t1.rank} and ${$t2.rank}.`);
    const t1Inner = ($t1.rank === 1 ? $t1.size : $t1.shape[1]);
    const t2Inner = ($t2.rank === 1 ? $t2.size : $t2.shape[0]);
    assert(t1Inner === t2Inner, () => `Error in dot: inner dimensions of inputs must match, but got ` +
        `${t1Inner} and ${t2Inner}.`);
    if ($t1.rank === 1 && $t2.rank === 1) {
        const t12D = reshape($t1, [1, -1]);
        const t22D = reshape($t2, [-1, 1]);
        const t1t2 = matMul(t12D, t22D);
        return reshape(t1t2, []);
    }
    else if ($t1.rank === 1 && $t2.rank === 2) {
        const t12D = reshape($t1, [1, -1]);
        const t22D = reshape($t2, [$t2.shape[0], $t2.shape[1]]);
        const t1t2 = matMul(t12D, t22D);
        return reshape(t1t2, [t1t2.size]);
    }
    else if ($t1.rank === 2 && $t2.rank === 1) {
        const t22D = reshape($t2, [-1, 1]);
        const t1t2 = matMul($t1, t22D);
        return reshape(t1t2, [t1t2.size]);
    }
    else {
        const t22D = reshape($t2, [$t2.shape[0], $t2.shape[1]]);
        const t1t2 = matMul($t1, t22D);
        return t1t2;
    }
}
op({ dot_ });

/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Tensor contraction over specified indices and outer product.
 *
 * `einsum` allows defining Tensors by defining their element-wise computation.
 * This computation is based on
 * [Einstein summation](https://en.wikipedia.org/wiki/Einstein_notation).
 *
 * Some special cases include:
 *
 * Matrix multiplication:
 * ```js
 * const x = tf.tensor2d([[1, 2, 3], [4, 5, 6]]);
 * const y = tf.tensor2d([[0, 1], [2, 3], [4, 5]]);
 * x.print();
 * y.print();
 * tf.einsum('ij,jk->ik', x, y).print();
 * ```
 *
 * Dot product:
 * ```js
 * const x = tf.tensor1d([1, 2, 3]);
 * const y = tf.tensor1d([0, 1, 2]);
 * x.print();
 * y.print();
 * tf.einsum('i,i->', x, y).print();
 * ```
 *
 * Batch dot product:
 * ```js
 * const x = tf.tensor2d([[1, 2, 3], [4, 5, 6]]);
 * const y = tf.tensor2d([[0, 1, 2], [3, 4, 5]]);
 * x.print();
 * y.print();
 * tf.einsum('bi,bi->b', x, y).print();
 * ```
 *
 * Outer prouduct:
 * ```js
 * const x = tf.tensor1d([1, 3, 5]);
 * const y = tf.tensor1d([2, 4, 6]);
 * x.print();
 * y.print();
 * tf.einsum('i,j->ij', x, y).print();
 * ```
 *
 * Matrix transpose:
 * ```js
 * const x = tf.tensor2d([[1, 2], [3, 4]]);
 * x.print();
 * tf.einsum('ij->ji', x).print();
 * ```
 *
 * Batch matrix transpose:
 * ```js
 * const x = tf.tensor3d([[[1, 2], [3, 4]], [[-1, -2], [-3, -4]]]);
 * x.print();
 * tf.einsum('bij->bji', x).print();
 * ```
 *
 * Limitations:
 *
 * This implementation of einsum has the following limitations:
 *
 * - Does not support >2 input tensors.
 * - Does not support duplicate axes for any given input tensor. E.g., equation
 *   'ii->' is not supported.
 * - The `...` notation is not supported.
 *
 * @param equation a string describing the contraction, in the same format as
 * [numpy.einsum](https://numpy.org/doc/stable/reference/generated/numpy.einsum.html).
 * @param tensors the input(s) to contract (each one a Tensor), whose shapes
 *     should be consistent with equation.
 * @returns The output tensor.
 *
 * @doc {heading: 'Tensors', subheading: 'Matrices'}
 */
function einsum_(equation, ...tensors) {
    const $tensors = tensors.map((t, i) => convertToTensor(t, `tensors${i}`, 'einsum'));
    const attrs = { equation };
    return ENGINE.runKernel(Einsum, $tensors, attrs);
}
op({ einsum_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes exponential linear element-wise: `x > 0 ? x : (e ^ x) - 1`.
 *
 * ```js
 * const x = tf.tensor1d([-1, 1, -3, 2]);
 *
 * x.elu().print();  // or tf.elu(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function elu_(x) {
    const $x = convertToTensor(x, 'x', 'elu', 'float32');
    const inputs = { x: $x };
    return ENGINE.runKernel(Elu, inputs);
}
const elu = op({ elu_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes Gauss error function of the input `tf.Tensor` element-wise:
 * `erf(x)`
 *
 * ```js
 * const x = tf.tensor1d([0, .1, -.1, .7]);
 *
 * x.erf().print(); // or tf.erf(x);
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function erf_(x) {
    let $x = convertToTensor(x, 'x', 'erf');
    assert($x.dtype === 'int32' || $x.dtype === 'float32', () => 'Input dtype must be `int32` or `float32`.');
    if ($x.dtype === 'int32') {
        $x = cast($x, 'float32');
    }
    const inputs = { x: $x };
    return ENGINE.runKernel(Erf, inputs);
}
op({ erf_ });

/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function combineLocations(outputLoc, reduceLoc, axes) {
    const rank = outputLoc.length + reduceLoc.length;
    const loc = [];
    let outIdx = 0;
    let reduceIdx = 0;
    for (let dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
            loc.push(outputLoc[outIdx++]);
        }
        else {
            loc.push(reduceLoc[reduceIdx++]);
        }
    }
    return loc;
}
function expandShapeToKeepDim(shape, axes) {
    const reduceSubShape = axes.map(x => 1);
    return combineLocations(shape, reduceSubShape, axes);
}

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the maximum of elements across dimensions of a `tf.Tensor`.
 *
 * Reduces the input along the dimensions given in `axes`. Unless `keepDims`
 * is true, the rank of the `tf.Tensor` is reduced by 1 for each entry in
 * `axes`. If `keepDims` is true, the reduced dimensions are retained with
 * length 1. If `axes` has no entries, all dimensions are reduced, and a
 * `tf.Tensor` with a single element is returned.
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3]);
 *
 * x.max().print();  // or tf.max(x)
 * ```
 *
 * ```js
 * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);
 *
 * const axis = 1;
 * x.max(axis).print();  // or tf.max(x, axis)
 * ```
 *
 * @param x The input tensor.
 * @param axis The dimension(s) to reduce. By default it reduces
 *     all dimensions.
 * @param keepDims If true, retains reduced dimensions with size 1.
 *
 * @doc {heading: 'Operations', subheading: 'Reduction'}
 */
function max_(x, axis = null, keepDims = false) {
    const $x = convertToTensor(x, 'x', 'max');
    const inputs = { x: $x };
    const attrs = { reductionIndices: axis, keepDims };
    return ENGINE.runKernel(Max, inputs, attrs);
}
const max = op({ max_ });

/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the minimum value from the input.
 *
 * Reduces the input along the dimensions given in `axes`. Unless `keepDims`
 * is true, the rank of the array is reduced by 1 for each entry in `axes`.
 * If `keepDims` is true, the reduced dimensions are retained with length 1.
 * If `axes` has no entries, all dimensions are reduced, and an array with a
 * single element is returned.
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3]);
 *
 * x.min().print();  // or tf.min(x)
 * ```
 *
 * ```js
 * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);
 *
 * const axis = 1;
 * x.min(axis).print();  // or tf.min(x, axis)
 * ```
 *
 * @param x The input Tensor.
 * @param axis The dimension(s) to reduce. By default it reduces
 *     all dimensions.
 * @param keepDims If true, retains reduced dimensions with size 1.
 *
 * @doc {heading: 'Operations', subheading: 'Reduction'}
 */
function min_(x, axis = null, keepDims = false) {
    const $x = convertToTensor(x, 'x', 'min');
    const inputs = { x: $x };
    const attrs = { axis, keepDims };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    return ENGINE.runKernel(Min, inputs, attrs);
}
const min = op({ min_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the power of one `tf.Tensor` to another. Supports broadcasting.
 *
 * Given a `tf.Tensor` x and a `tf.Tensor` y, this operation computes x^y for
 * corresponding elements in x and y. The result's dtype will be the upcasted
 * type of the `base` and `exp` dtypes.
 *
 * ```js
 * const a = tf.tensor([[2, 3], [4, 5]])
 * const b = tf.tensor([[1, 2], [3, 0]]).toInt();
 *
 * a.pow(b).print();  // or tf.pow(a, b)
 * ```
 *
 * ```js
 * const a = tf.tensor([[1, 2], [3, 4]])
 * const b = tf.tensor(2).toInt();
 *
 * a.pow(b).print();  // or tf.pow(a, b)
 * ```
 * We also expose `powStrict` which has the same signature as this op and
 * asserts that `base` and `exp` are the same shape (does not broadcast).
 *
 * @param base The base `tf.Tensor` to pow element-wise.
 * @param exp The exponent `tf.Tensor` to pow element-wise.
 *
 * @doc {heading: 'Operations', subheading: 'Arithmetic'}
 */
function pow_(base, exp) {
    let $base = convertToTensor(base, 'base', 'pow');
    let $exp = convertToTensor(exp, 'exp', 'pow');
    [$base, $exp] = makeTypesMatch($base, $exp);
    const inputs = { a: $base, b: $exp };
    return ENGINE.runKernel(Pow, inputs);
}
const pow = op({ pow_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/** This is shared code across all tensor creation methods. */
function makeTensor(values, shape, inferredShape, dtype) {
    if (dtype == null) {
        dtype = inferDtype(values);
    }
    if (dtype === 'complex64') {
        throw new Error(`Cannot construct a complex64 tensor directly. ` +
            `Please use tf.complex(real, imag).`);
    }
    if (!isTypedArray(values) && !Array.isArray(values) &&
        typeof values !== 'number' && typeof values !== 'boolean' &&
        typeof values !== 'string') {
        throw new Error('values passed to tensor(values) must be a number/boolean/string or ' +
            'an array of numbers/booleans/strings, or a TypedArray');
    }
    if (shape != null) {
        assertNonNegativeIntegerDimensions(shape);
        const providedSize = sizeFromShape(shape);
        const inferredSize = sizeFromShape(inferredShape);
        assert(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ` +
            `${providedSize} values but has ${inferredSize}`);
        for (let i = 0; i < inferredShape.length; ++i) {
            const inferred = inferredShape[i];
            const flatDimsDontMatch = i === inferredShape.length - 1 ?
                inferred !== sizeFromShape(shape.slice(i)) :
                true;
            assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape ` +
                `(${inferredShape}) does not match the provided ` +
                `shape (${shape}). `);
        }
    }
    if (!isTypedArray(values) && !Array.isArray(values)) {
        values = [values];
    }
    shape = shape || inferredShape;
    values = dtype !== 'string' ?
        toTypedArray(values, dtype) :
        flatten(values, [], true);
    return ENGINE.makeTensor(values, shape, dtype);
}

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Creates rank-0 `tf.Tensor` (scalar) with the provided value and dtype.
 *
 * The same functionality can be achieved with `tf.tensor`, but in general
 * we recommend using `tf.scalar` as it makes the code more readable.
 *
 * ```js
 * tf.scalar(3.14).print();
 * ```
 *
 * @param value The value of the scalar.
 * @param dtype The data type.
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */
function scalar(value, dtype) {
    if (((isTypedArray(value) && dtype !== 'string') || Array.isArray(value)) &&
        dtype !== 'complex64') {
        throw new Error('Error creating a new Scalar: value must be a primitive ' +
            '(number|boolean|string)');
    }
    if (dtype === 'string' && isTypedArray(value) &&
        !(value instanceof Uint8Array)) {
        throw new Error('When making a scalar from encoded string, ' +
            'the value must be `Uint8Array`.');
    }
    const shape = [];
    const inferredShape = [];
    return makeTensor(value, shape, inferredShape, dtype);
}

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes square root of the input `tf.Tensor` element-wise: `y = sqrt(x)`
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 4, -1]);
 *
 * x.sqrt().print();  // or tf.sqrt(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function sqrt_(x) {
    const $x = convertToTensor(x, 'x', 'sqrt', 'float32');
    const inputs = { x: $x };
    return ENGINE.runKernel(Sqrt, inputs);
}
const sqrt = op({ sqrt_ });

/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes square of `x` element-wise: `x ^ 2`
 *
 * ```js
 * const x = tf.tensor1d([1, 2, Math.sqrt(2), -1]);
 *
 * x.square().print();  // or tf.square(x)
 * ```
 * @param x The input Tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function square_(x) {
    const $x = convertToTensor(x, 'x', 'square');
    const attrs = {};
    return ENGINE.runKernel('Square', { x: $x }, attrs);
}
const square = op({ square_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the sum of elements across dimensions of a `tf.Tensor`.
 *
 * Reduces the input along the dimensions given in `axes`. Unless `keepDims`
 * is true, the rank of the `tf.Tensor` is reduced by 1 for each entry in
 * `axes`. If `keepDims` is true, the reduced dimensions are retained with
 * length 1. If axes has no entries, all dimensions are reduced, and a
 * `tf.Tensor` with a single element is returned.
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3]);
 *
 * x.sum().print();  // or tf.sum(x)
 * ```
 *
 * ```js
 * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);
 *
 * const axis = 1;
 * x.sum(axis).print();  // or tf.sum(x, axis)
 * ```
 *
 * @param x The input tensor to compute the sum over. If the dtype is `bool`
 *   it will be converted to `int32` and the output dtype will be `int32`.
 * @param axis The dimension(s) to reduce. By default it reduces
 *     all dimensions.
 * @param keepDims If true, retains reduced dimensions with size 1.
 *
 * @doc {heading: 'Operations', subheading: 'Reduction'}
 */
function sum_(x, axis = null, keepDims = false) {
    let $x = convertToTensor(x, 'x', 'sum');
    if ($x.dtype === 'bool') {
        $x = cast($x, 'int32');
    }
    const inputs = { x: $x };
    const attrs = { axis, keepDims };
    return ENGINE.runKernel(Sum, inputs, attrs);
}
const sum = op({ sum_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the norm of scalar, vectors, and matrices.
 * This function can compute several different vector norms (the 1-norm, the
 * Euclidean or 2-norm, the inf-norm, and in general the p-norm for p > 0)
 * and matrix norms (Frobenius, 1-norm, and inf-norm).
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3, 4]);
 *
 * x.norm().print();  // or tf.norm(x)
 * ```
 *
 * @param x The input array.
 * @param ord Optional. Order of the norm. Supported norm types are
 * following:
 *
 *  | ord        | norm for matrices         | norm for vectors
 *  |------------|---------------------------|---------------------
 *  |'euclidean' |Frobenius norm             |2-norm
 *  |'fro'       |Frobenius norm	           |
 *  |Infinity    |max(sum(abs(x), axis=1))   |max(abs(x))
 *  |-Infinity   |min(sum(abs(x), axis=1))   |min(abs(x))
 *  |1           |max(sum(abs(x), axis=0))   |sum(abs(x))
 *  |2           |                           |sum(abs(x)^2)^(1/2)
 *
 * @param axis Optional. If axis is null (the default), the input is
 * considered a vector and a single vector norm is computed over the entire
 * set of values in the Tensor, i.e. norm(x, ord) is equivalent
 * to norm(x.reshape([-1]), ord). If axis is an integer, the input
 * is considered a batch of vectors, and axis determines the axis in x
 * over which to compute vector norms. If axis is a 2-tuple of integer it is
 * considered a batch of matrices and axis determines the axes in NDArray
 * over which to compute a matrix norm.
 * @param keepDims Optional. If true, the norm has the same dimensionality
 * as the input.
 *
 * @doc {heading: 'Operations', subheading: 'Matrices'}
 */
function norm_(x, ord = 'euclidean', axis = null, keepDims = false) {
    x = convertToTensor(x, 'x', 'norm');
    const norm = normImpl(x, ord, axis);
    let keepDimsShape = norm.shape;
    if (keepDims) {
        const axes = parseAxisParam(axis, x.shape);
        keepDimsShape = expandShapeToKeepDim(norm.shape, axes);
    }
    return reshape(norm, keepDimsShape);
}
function normImpl(x, p, axis = null) {
    if (x.rank === 0) {
        return abs(x);
    }
    // consider vector when no axis is specified
    if (x.rank !== 1 && axis === null) {
        return normImpl(reshape(x, [-1]), p, axis);
    }
    // vector
    if (x.rank === 1 || typeof axis === 'number' ||
        Array.isArray(axis) && axis.length === 1) {
        if (p === 1) {
            return sum(abs(x), axis);
        }
        if (p === Infinity) {
            return max(abs(x), axis);
        }
        if (p === -Infinity) {
            return min(abs(x), axis);
        }
        if (p === 'euclidean' || p === 2) {
            // norm(x, 2) = sum(abs(xi) ^ 2) ^ 1/2
            return sqrt(sum(pow(abs(x), scalar(2, 'int32')), axis));
        }
        throw new Error(`Error in norm: invalid ord value: ${p}`);
    }
    // matrix (assumption axis[0] < axis[1])
    if (Array.isArray(axis) && axis.length === 2) {
        if (p === 1) {
            return max(sum(abs(x), axis[0]), axis[1] - 1);
        }
        if (p === Infinity) {
            return max(sum(abs(x), axis[1]), axis[0]);
        }
        if (p === -Infinity) {
            return min(sum(abs(x), axis[1]), axis[0]);
        }
        if (p === 'fro' || p === 'euclidean') {
            // norm(x) = sqrt(sum(pow(x, 2)))
            return sqrt(sum(square(x), axis));
        }
        throw new Error(`Error in norm: invalid ord value: ${p}`);
    }
    throw new Error(`Error in norm: invalid axis: ${axis}`);
}
const norm = op({ norm_ });

/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the Euclidean norm of scalar, vectors, and matrices.
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3, 4]);
 *
 * x.euclideanNorm().print();  // or tf.euclideanNorm(x)
 * ```
 *
 * @param x The input array.
 * @param axis Optional. If axis is null (the default), the input is
 * considered a vector and a single vector norm is computed over the entire
 * set of values in the Tensor, i.e. euclideanNorm(x) is equivalent
 * to euclideanNorm(x.reshape([-1])). If axis is an integer, the input
 * is considered a batch of vectors, and axis determines the axis in x
 * over which to compute vector norms. If axis is a 2-tuple of integer it is
 * considered a batch of matrices and axis determines the axes in NDArray
 * over which to compute a matrix norm.
 * @param keepDims Optional. If true, the norm has the same dimensionality
 * as the input.
 *
 * @doc {heading: 'Operations', subheading: 'Matrices'}
 */
function euclideanNorm_(x, axis = null, keepDims = false) {
    return norm(x, 'euclidean', axis, keepDims);
}
op({ euclideanNorm_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes exponential of the input `tf.Tensor` element-wise. `e ^ x`
 *
 * ```js
 * const x = tf.tensor1d([1, 2, -3]);
 *
 * x.exp().print();  // or tf.exp(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function exp_(x) {
    const $x = convertToTensor(x, 'x', 'exp');
    const inputs = { x: $x };
    return ENGINE.runKernel(Exp, inputs);
}
const exp = op({ exp_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes exponential of the input `tf.Tensor` minus one element-wise.
 * `e ^ x - 1`
 *
 * ```js
 * const x = tf.tensor1d([1, 2, -3]);
 *
 * x.expm1().print();  // or tf.expm1(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function expm1_(x) {
    const $x = convertToTensor(x, 'x', 'expm1');
    const inputs = { x: $x };
    return ENGINE.runKernel(Expm1, inputs);
}
op({ expm1_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Construct a tensor by repeating it the number of times given by reps.
 *
 * This operation creates a new tensor by replicating `input` `reps`
 * times. The output tensor's `i`th dimension has `input.shape[i] *
 * reps[i]` elements, and the values of `input` are replicated
 * `reps[i]` times along the `i`th dimension. For example, tiling
 * `[a, b, c, d]` by `[2]` produces `[a, b, c, d, a, b, c, d]`.
 *
 * ```js
 * const a = tf.tensor1d([1, 2]);
 *
 * a.tile([2]).print();    // or a.tile([2])
 * ```
 *
 * ```js
 * const a = tf.tensor2d([1, 2, 3, 4], [2, 2]);
 *
 * a.tile([1, 2]).print();  // or a.tile([1, 2])
 * ```
 * @param x The tensor to tile.
 * @param reps Determines the number of replications per dimension.
 *
 * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}
 */
function tile_(x, reps) {
    const $x = convertToTensor(x, 'x', 'tile', 'string_or_numeric');
    assert($x.rank === reps.length, () => `Error in transpose: rank of input ${$x.rank} ` +
        `must match length of reps ${reps}.`);
    const inputs = { x: $x };
    const attrs = { reps };
    return ENGINE.runKernel(Tile, inputs, attrs);
}
const tile = op({ tile_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Create an identity matrix.
 *
 * @param numRows Number of rows.
 * @param numColumns Number of columns. Defaults to `numRows`.
 * @param batchShape If provided, will add the batch shape to the beginning
 *   of the shape of the returned `tf.Tensor` by repeating the identity
 *   matrix.
 * @param dtype Data type.
 * @returns Identity matrix of the specified size and data type, possibly
 *   with batch repetition if `batchShape` is specified.
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */
function eye_(numRows, numColumns, batchShape, dtype = 'float32') {
    if (numColumns == null) {
        numColumns = numRows;
    }
    const buff = buffer([numRows, numColumns], dtype);
    const n = numRows <= numColumns ? numRows : numColumns;
    for (let i = 0; i < n; ++i) {
        buff.set(1, i, i);
    }
    const out = reshape(buff.toTensor(), [numRows, numColumns]);
    if (batchShape == null) {
        return out;
    }
    else {
        if (batchShape.length === 1) {
            return tile(expandDims(out, 0), [batchShape[0], 1, 1]);
        }
        else if (batchShape.length === 2) {
            // tslint:disable-next-line:no-unnecessary-type-assertion
            return tile(expandDims(expandDims(out, 0), 0), [batchShape[0], batchShape[1], 1, 1]);
        }
        else if (batchShape.length === 3) {
            // tslint:disable-next-line:no-unnecessary-type-assertion
            return tile(expandDims(expandDims(expandDims(out, 0), 0), 0), [
                batchShape[0], batchShape[1], batchShape[2], 1, 1
            ]);
        }
        else {
            throw new Error(`eye() currently supports only 1D and 2D ` +
                // tslint:disable-next-line:no-any
                `batchShapes, but received ${batchShape.length}D.`);
        }
    }
}
const eye = op({ eye_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes floor of input `tf.Tensor` element-wise: `floor(x)`.
 *
 * ```js
 * const x = tf.tensor1d([.6, 1.1, -3.3]);
 *
 * x.floor().print();  // or tf.floor(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function floor_(x) {
    const $x = convertToTensor(x, 'x', 'floor', 'float32');
    const inputs = { x: $x };
    return ENGINE.runKernel(Floor, inputs);
}
const floor = op({ floor_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns the truth value of (a > b) element-wise. Supports broadcasting.
 *
 * ```js
 * const a = tf.tensor1d([1, 2, 3]);
 * const b = tf.tensor1d([2, 2, 2]);
 *
 * a.greater(b).print();
 * ```
 *
 * @param a The first input tensor.
 * @param b The second input tensor. Must have the same dtype as `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Logical'}
 */
function greater_(a, b) {
    let $a = convertToTensor(a, 'a', 'greater', 'string_or_numeric');
    let $b = convertToTensor(b, 'b', 'greater', 'string_or_numeric');
    [$a, $b] = makeTypesMatch($a, $b);
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Greater, inputs);
}
const greater = op({ greater_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns the truth value of (a >= b) element-wise. Supports broadcasting.
 *
 * ```js
 * const a = tf.tensor1d([1, 2, 3]);
 * const b = tf.tensor1d([2, 2, 2]);
 *
 * a.greaterEqual(b).print();
 * ```
 *
 * @param a The first input tensor.
 * @param b The second input tensor. Must have the same dtype as `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Logical'}
 */
function greaterEqual_(a, b) {
    let $a = convertToTensor(a, 'a', 'greaterEqual', 'string_or_numeric');
    let $b = convertToTensor(b, 'b', 'greaterEqual', 'string_or_numeric');
    [$a, $b] = makeTypesMatch($a, $b);
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(GreaterEqual, inputs);
}
const greaterEqual = op({ greaterEqual_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns the imaginary part of a complex (or real) tensor.
 *
 * Given a tensor input, this operation returns a tensor of type float that is
 * the imaginary part of each element in input considered as a complex number.
 * If input is real, a tensor of all zeros is returned.
 *
 * ```js
 * const x = tf.complex([-2.25, 3.25], [4.75, 5.75]);
 * tf.imag(x).print();
 * ```
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */
function imag_(input) {
    const $input = convertToTensor(input, 'input', 'imag');
    const inputs = { input: $input };
    return ENGINE.runKernel(Imag, inputs);
}
const imag = op({ imag_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns which elements of x are finite.
 *
 * ```js
 * const x = tf.tensor1d([NaN, Infinity, -Infinity, 0, 1]);
 *
 * x.isFinite().print();  // or tf.isNaN(x)
 * ```
 * @param x The input Tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function isFinite_(x) {
    const $x = convertToTensor(x, 'x', 'isFinite');
    const inputs = { x: $x };
    return ENGINE.runKernel(IsFinite, inputs);
}
op({ isFinite_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns which elements of x are Infinity or -Infinity.
 *
 * ```js
 * const x = tf.tensor1d([NaN, Infinity, -Infinity, 0, 1]);
 *
 * x.isInf().print();  // or tf.isNaN(x)
 * ```
 * @param x The input Tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function isInf_(x) {
    const $x = convertToTensor(x, 'x', 'isInf');
    const inputs = { x: $x };
    return ENGINE.runKernel(IsInf, inputs);
}
op({ isInf_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns which elements of x are NaN.
 *
 * ```js
 * const x = tf.tensor1d([NaN, Infinity, -Infinity, 0, 1]);
 *
 * x.isNaN().print();  // or tf.isNaN(x)
 * ```
 * @param x The input Tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function isNaN_(x) {
    const $x = convertToTensor(x, 'x', 'isNaN');
    const inputs = { x: $x };
    return ENGINE.runKernel(IsNan, inputs);
}
op({ isNaN_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes leaky rectified linear element-wise.
 *
 * See
 * [http://web.stanford.edu/~awni/papers/relu_hybrid_icml2013_final.pdf](
 *     http://web.stanford.edu/~awni/papers/relu_hybrid_icml2013_final.pdf)
 *
 * ```js
 * const x = tf.tensor1d([-1, 2, -3, 4]);
 *
 * x.leakyRelu(0.1).print();  // or tf.leakyRelu(x, 0.1)
 * ```
 * @param x The input tensor.
 * @param alpha The scaling factor for negative values, defaults to 0.2.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function leakyRelu_(x, alpha = 0.2) {
    const $x = convertToTensor(x, 'x', 'leakyRelu');
    const inputs = { x: $x };
    const attrs = { alpha };
    return ENGINE.runKernel(LeakyRelu, inputs, attrs);
}
const leakyRelu = op({ leakyRelu_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns the truth value of (a < b) element-wise. Supports broadcasting.
 *
 * ```js
 * const a = tf.tensor1d([1, 2, 3]);
 * const b = tf.tensor1d([2, 2, 2]);
 *
 * a.less(b).print();
 * ```
 * @param a The first input tensor.
 * @param b The second input tensor. Must have the same dtype as `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Logical'}
 */
function less_(a, b) {
    let $a = convertToTensor(a, 'a', 'less', 'string_or_numeric');
    let $b = convertToTensor(b, 'b', 'less', 'string_or_numeric');
    [$a, $b] = makeTypesMatch($a, $b);
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Less, inputs);
}
op({ less_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns the truth value of (a <= b) element-wise. Supports broadcasting.
 *
 * ```js
 * const a = tf.tensor1d([1, 2, 3]);
 * const b = tf.tensor1d([2, 2, 2]);
 *
 * a.lessEqual(b).print();
 * ```
 *
 * @param a The first input tensor.
 * @param b The second input tensor. Must have the same dtype as `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Logical'}
 */
function lessEqual_(a, b) {
    let $a = convertToTensor(a, 'a', 'lessEqual', 'string_or_numeric');
    let $b = convertToTensor(b, 'b', 'lessEqual', 'string_or_numeric');
    [$a, $b] = makeTypesMatch($a, $b);
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(LessEqual, inputs);
}
const lessEqual = op({ lessEqual_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Normalizes the activation of a local neighborhood across or within
 * channels.
 *
 * @param x The input tensor. The 4-D input tensor is treated as a 3-D array
 *     of 1D vectors (along the last dimension), and each vector is
 *     normalized independently.
 * @param depthRadius The number of adjacent channels in the 1D normalization
 *     window.
 * @param bias A constant bias term for the basis.
 * @param alpha A scale factor, usually positive.
 * @param beta An exponent.
 *
 * @doc {heading: 'Operations', subheading: 'Normalization'}
 */
function localResponseNormalization_(x, depthRadius = 5, bias = 1, alpha = 1, beta = 0.5) {
    const $x = convertToTensor(x, 'x', 'localResponseNormalization');
    assert($x.rank === 4 || $x.rank === 3, () => `Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${$x.rank}.`);
    assert(isInt(depthRadius), () => `Error in localResponseNormalization: depthRadius must be an ` +
        `integer but got depthRadius ${depthRadius}.`);
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    const inputs = { x: x4D };
    const attrs = { depthRadius, bias, alpha, beta };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    const res = ENGINE.runKernel(LRN, inputs, attrs);
    if (reshapedTo4D) {
        return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    else {
        return res;
    }
}
op({ localResponseNormalization_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes natural logarithm of the input `tf.Tensor` element-wise: `ln(x)`
 *
 * ```js
 * const x = tf.tensor1d([1, 2, Math.E]);
 *
 * x.log().print();  // or tf.log(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function log_(x) {
    const $x = convertToTensor(x, 'x', 'log', 'float32');
    const inputs = { x: $x };
    return ENGINE.runKernel(Log, inputs);
}
const log = op({ log_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes natural logarithm of the input `tf.Tensor` plus one
 * element-wise: `ln(1 + x)`
 *
 * ```js
 * const x = tf.tensor1d([1, 2, Math.E - 1]);
 *
 * x.log1p().print();  // or tf.log1p(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function log1p_(x) {
    const $x = convertToTensor(x, 'x', 'log1p');
    const inputs = { x: $x };
    return ENGINE.runKernel(Log1p, inputs);
}
const log1p = op({ log1p_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Overrides the gradient computation of a function `f`.
 *
 * Takes a function
 * `f(...inputs, save) => {value: Tensor, gradFunc: (dy, saved) => Tensor[]}`
 * and returns another function `g(...inputs)` which takes the same inputs as
 * `f`. When called, `g` returns `f().value`. In backward mode, custom gradients
 * with respect to each input of `f` are computed using `f().gradFunc`.
 *
 * The `save` function passed to `f` should be used for saving tensors needed
 * in the gradient. And the `saved` passed to the `gradFunc` is a
 * `NamedTensorMap`, which contains those saved tensors.
 *
 * ```js
 * const customOp = tf.customGrad((x, save) => {
 *   // Save x to make sure it's available later for the gradient.
 *   save([x]);
 *   // Override gradient of our custom x ^ 2 op to be dy * abs(x);
 *   return {
 *     value: x.square(),
 *     // Note `saved.x` which points to the `x` we saved earlier.
 *     gradFunc: (dy, saved) => [dy.mul(saved[0].abs())]
 *   };
 * });
 *
 * const x = tf.tensor1d([-1, -2, 3]);
 * const dx = tf.grad(x => customOp(x));
 *
 * console.log(`f(x):`);
 * customOp(x).print();
 * console.log(`f'(x):`);
 * dx(x).print();
 * ```
 *
 * @param f The function to evaluate in forward mode, which should return
 *     `{value: Tensor, gradFunc: (dy, saved) => Tensor[]}`, where `gradFunc`
 *     returns the custom gradients of `f` with respect to its inputs.
 *
 * @doc {heading: 'Training', subheading: 'Gradients'}
 */
function customGrad(f) {
    return ENGINE.customGrad(f);
}

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes `-1 * x` element-wise.
 *
 * ```js
 * const x = tf.tensor2d([1, 2, -2, 0], [2, 2]);
 *
 * x.neg().print();  // or tf.neg(x)
 * ```
 *
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function neg_(x) {
    const $x = convertToTensor(x, 'x', 'neg');
    const inputs = { x: $x };
    return ENGINE.runKernel(Neg, inputs);
}
const neg = op({ neg_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes softplus of the input `tf.Tensor` element-wise: `log(exp(x) + 1)`
 *
 * ```js
 * const x = tf.tensor1d([0, 1, -1, .7]);
 *
 * x.softplus().print();  // or tf.softplus(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function softplus_(x) {
    const $x = convertToTensor(x, 'x', 'softplus');
    const inputs = { x: $x };
    return ENGINE.runKernel(Softplus, inputs);
}
const softplus = op({ softplus_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes log sigmoid of the input `tf.Tensor` element-wise:
 * `logSigmoid(x)`. For numerical stability, we use `-tf.softplus(-x)`.
 *
 * ```js
 * const x = tf.tensor1d([0, 1, -1, .7]);
 *
 * x.logSigmoid().print();  // or tf.logSigmoid(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function logSigmoid_(x) {
    const $x = convertToTensor(x, 'x', 'logSigmoid');
    // Use a custom gradient to maintain previous implementation.
    // There is no LogSigmoid kernel in TF so we can't use engine.runKernel
    // directly
    const customOp = customGrad((x) => {
        // TODO(yassogba) we can remove the chained softplus call here only
        // after backends have modualrized softplus at which point we can call
        // engine runKernel(..., Sotfplus, ...) directly.
        const value = neg(softplus(neg(x)));
        const gradFunc = (dy) => {
            const derX = mul(dy, sigmoid(neg(x)));
            return derX;
        };
        return { value, gradFunc };
    });
    return customOp($x);
}
op({ logSigmoid_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Subtracts two `tf.Tensor`s element-wise, A - B. Supports broadcasting.
 *
 * ```js
 * const a = tf.tensor1d([10, 20, 30, 40]);
 * const b = tf.tensor1d([1, 2, 3, 4]);
 *
 * a.sub(b).print();  // or tf.sub(a, b)
 * ```
 *
 * ```js
 * // Broadcast subtract a with b.
 * const a = tf.tensor1d([10, 20, 30, 40]);
 * const b = tf.scalar(5);
 *
 * a.sub(b).print();  // or tf.sub(a, b)
 * ```
 * @param a The first `tf.Tensor` to subtract from.
 * @param b The second `tf.Tensor` to be subtracted. Must have the same dtype as
 * `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Arithmetic'}
 */
function sub_(a, b) {
    let $a = convertToTensor(a, 'a', 'sub');
    let $b = convertToTensor(b, 'b', 'sub');
    [$a, $b] = makeTypesMatch($a, $b);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Sub, inputs);
}
const sub = op({ sub_ });

/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the log softmax.
 *
 * ```js
 * const a = tf.tensor1d([1, 2, 3]);
 *
 * a.logSoftmax().print();  // or tf.logSoftmax(a)
 * ```
 *
 * ```js
 * const a = tf.tensor2d([2, 4, 6, 1, 2, 3], [2, 3]);
 *
 * a.logSoftmax().print();  // or tf.logSoftmax(a)
 * ```
 *
 * @param logits The logits array.
 * @param axis The dimension softmax would be performed on. Defaults to `-1`
 *     which indicates the last dimension.
 *
 * @doc {heading: 'Operations', subheading: 'Normalization'}
 */
function logSoftmax_(logits, axis = -1) {
    const $logits = convertToTensor(logits, 'logits', 'logSoftmax');
    if (axis === -1) {
        axis = $logits.rank - 1;
    }
    if (axis !== $logits.rank - 1) {
        throw Error('Log Softmax along a non-last dimension is not yet supported. ' +
            `Logits was rank ${$logits.rank} and axis was ${axis}`);
    }
    // const forward: ForwardFunc<Tensor> = (backend, save) => {
    //   const keepDims = true;
    //   const xMax = max(logits, axis, true);
    //   const shifted = sub(logits, xMax);
    //   const value =
    //       sub(cast(shifted, 'float32'), log(sum(exp(shifted), axis,
    //       keepDims)));
    //   save([value]);
    //   return value;
    // };
    // Use a custom gradient for numerical stability.
    const customOp = customGrad((logits, save) => {
        const keepDims = true;
        const xMax = max(logits, axis, true);
        const shifted = sub(logits, xMax);
        const value = sub(cast(shifted, 'float32'), log(sum(exp(shifted), axis, keepDims)));
        save([value]);
        const gradFunc = (dy, saved) => {
            const [value] = saved;
            const keepDims = true;
            const softmax = exp(value);
            return sub(dy, mul(sum(dy, axis, keepDims), softmax));
        };
        return { value, gradFunc };
    });
    return customOp($logits);
    // TODO Use Engine.runKernel when CPU/WebGL/WASM backends implement this.
    // const inputs: LogSoftmaxInputs = {logits: $logits};
    // const attrs: LogSoftmaxAttrs = {axis};
    // return ENGINE.runKernel(
    //            LogSoftmax, inputs as {} as NamedTensorMap,
    //            attrs as {} as NamedAttrMap);
}
op({ logSoftmax_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the log(sum(exp(elements across the reduction dimensions))).
 *
 * Reduces the input along the dimensions given in `axis`. Unless `keepDims`
 * is true, the rank of the array is reduced by 1 for each entry in `axis`.
 * If `keepDims` is true, the reduced dimensions are retained with length 1.
 * If `axis` has no entries, all dimensions are reduced, and an array with a
 * single element is returned.
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3]);
 *
 * x.logSumExp().print();  // or tf.logSumExp(x)
 * ```
 *
 * ```js
 * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);
 *
 * const axis = 1;
 * x.logSumExp(axis).print();  // or tf.logSumExp(a, axis)
 * ```
 * @param x The input tensor.
 * @param axis The dimension(s) to reduce. If null (the default),
 *     reduces all dimensions.
 * @param keepDims If true, retains reduced dimensions with length
 *     of 1. Defaults to false.
 *
 * @doc {heading: 'Operations', subheading: 'Reduction'}
 */
function logSumExp_(x, axis = null, keepDims = false) {
    const $x = convertToTensor(x, 'x', 'logSumExp');
    const axes = parseAxisParam(axis, $x.shape);
    const xMax = max($x, axes, true /* keepDims */);
    const a = sub($x, xMax);
    const b = exp(a);
    const c = sum(b, axes);
    const d = log(c);
    const res = add(reshape(xMax, d.shape), d);
    if (keepDims) {
        const newShape = expandShapeToKeepDim(res.shape, axes);
        return reshape(res, newShape);
    }
    return res;
}
const logSumExp = op({ logSumExp_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns the truth value of `a AND b` element-wise. Supports broadcasting.
 *
 * ```js
 * const a = tf.tensor1d([false, false, true, true], 'bool');
 * const b = tf.tensor1d([false, true, false, true], 'bool');
 *
 * a.logicalAnd(b).print();
 * ```
 *
 * @param a The first input tensor. Must be of dtype bool.
 * @param b The second input tensor. Must be of dtype bool.
 *
 * @doc {heading: 'Operations', subheading: 'Logical'}
 */
function logicalAnd_(a, b) {
    const $a = convertToTensor(a, 'a', 'logicalAnd', 'bool');
    const $b = convertToTensor(b, 'b', 'logicalAnd', 'bool');
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(LogicalAnd, inputs);
}
const logicalAnd = op({ logicalAnd_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns the truth value of `NOT x` element-wise.
 *
 * ```js
 * const a = tf.tensor1d([false, true], 'bool');
 *
 * a.logicalNot().print();
 * ```
 *
 * @param x The input tensor. Must be of dtype 'bool'.
 *
 * @doc {heading: 'Operations', subheading: 'Logical'}
 */
function logicalNot_(x) {
    const $x = convertToTensor(x, 'x', 'logicalNot', 'bool');
    const inputs = { x: $x };
    return ENGINE.runKernel(LogicalNot, inputs);
}
const logicalNot = op({ logicalNot_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns the truth value of `a OR b` element-wise. Supports broadcasting.
 *
 * ```js
 * const a = tf.tensor1d([false, false, true, true], 'bool');
 * const b = tf.tensor1d([false, true, false, true], 'bool');
 *
 * a.logicalOr(b).print();
 * ```
 * @param a The first input tensor. Must be of dtype bool.
 * @param b The second input tensor. Must be of dtype bool.
 *
 * @doc {heading: 'Operations', subheading: 'Logical'}
 */
function logicalOr_(a, b) {
    const $a = convertToTensor(a, 'a', 'logicalOr', 'bool');
    const $b = convertToTensor(b, 'b', 'logicalOr', 'bool');
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(LogicalOr, inputs);
}
const logicalOr = op({ logicalOr_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns the truth value of `a XOR b` element-wise. Supports broadcasting.
 *
 * ```js
 * const a = tf.tensor1d([false, false, true, true], 'bool');
 * const b = tf.tensor1d([false, true, false, true], 'bool');
 *
 * a.logicalXor(b).print();
 * ```
 *
 * @param a The first input tensor. Must be of dtype bool.
 * @param b The second input tensor. Must be of dtype bool.
 *
 * @doc {heading: 'Operations', subheading: 'Logical'}
 */
function logicalXor_(a, b) {
    const $a = convertToTensor(a, 'a', 'logicalXor', 'bool');
    const $b = convertToTensor(b, 'b', 'logicalXor', 'bool');
    assertAndGetBroadcastShape($a.shape, $b.shape);
    // x ^ y = (x | y) & ~(x & y)
    return logicalAnd(logicalOr(a, b), logicalNot(logicalAnd(a, b)));
}
op({ logicalXor_ });

/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const INT32_MAX = 2147483648;
/**
 * Searches for where a value would go in a sorted sequence.
 *
 * This is not a method for checking containment (like javascript in).
 *
 * The typical use case for this operation is "binning", "bucketing", or
 * "discretizing". The values are assigned to bucket-indices based on the edges
 * listed in 'sortedSequence'. This operation returns the bucket-index for each
 * value.
 *
 * The side argument controls which index is returned if a value lands exactly
 * on an edge.
 *
 * The axis is not settable for this operation. It always operates on the
 * innermost dimension (axis=-1). The operation will accept any number of outer
 * dimensions.
 *
 * Note: This operation assumes that 'sortedSequence' is sorted along the
 * innermost axis, maybe using 'sort(..., axis=-1)'. If the sequence is not
 * sorted no error is raised and the content of the returned tensor is not well
 * defined.
 *
 * ```js
 * const edges = tf.tensor1d([-1, 3.3, 9.1, 10.0]);
 * let values = tf.tensor1d([0.0, 4.1, 12.0]);
 * const result1 = tf.searchSorted(edges, values, 'left');
 * result1.print(); // [1, 2, 4]
 *
 * const seq = tf.tensor1d([0, 3, 9, 10, 10]);
 * values = tf.tensor1d([0, 4, 10]);
 * const result2 = tf.searchSorted(seq, values, 'left');
 * result2.print(); // [0, 2, 3]
 * const result3 = tf.searchSorted(seq, values, 'right');
 * result3.print(); // [1, 2, 5]
 *
 * const sortedSequence = tf.tensor2d([[0., 3., 8., 9., 10.],
 *                                     [1., 2., 3., 4., 5.]]);
 * values = tf.tensor2d([[9.8, 2.1, 4.3],
 *                       [0.1, 6.6, 4.5, ]]);
 * const result4 = tf.searchSorted(sortedSequence, values, 'left');
 * result4.print(); // [[4, 1, 2], [0, 5, 4]]
 * ```
 * @param sortedSequence: N-D. Sorted sequence.
 * @param values: N-D. Search values.
 * @param side: 'left'|'right'. Defaults to 'left'. 'left' corresponds to lower
 *     bound and 'right' to upper bound.
 * @return An N-D int32 tensor the size of values containing the result of
 *     applying either lower bound or upper bound (depending on side) to each
 *     value. The result is not a global index to the entire Tensor, but the
 *     index in the last dimension.
 * @doc {heading: 'Operations', subheading: 'Evaluation'}
 */
function searchSorted_(sortedSequence, values, side = 'left') {
    const $sortedSequence = convertToTensor(sortedSequence, 'sortedSequence', 'searchSorted');
    const $values = convertToTensor(values, 'values', 'searchSorted');
    const sequenceSize = $sortedSequence.shape[$sortedSequence.shape.length - 1];
    const valuesSize = $values.shape[$values.shape.length - 1];
    const $sortedSequence2D = reshape($sortedSequence, [-1, sequenceSize]);
    const $values2D = reshape($values, [-1, valuesSize]);
    if ($sortedSequence2D.rank < 2) {
        throw new Error(`Sorted input argument must be at least 2-dimensional`);
    }
    if ($sortedSequence2D.shape[0] !== $values2D.shape[0]) {
        throw new Error(`Leading dimension of 'sortedSequence' and 'values' must match.`);
    }
    if (sizeFromShape($values2D.shape) >= INT32_MAX) {
        throw new Error(`values tensor size must less than ${INT32_MAX}`);
    }
    if ($sortedSequence2D.shape[1] >= INT32_MAX) {
        throw new Error(`trailing dim_size must less than ${INT32_MAX} for int32 output type, was ${$sortedSequence2D.shape[1]}`);
    }
    const inputs = {
        sortedSequence: $sortedSequence2D,
        values: $values2D,
    };
    const attrs = { side };
    return ENGINE.runKernel(SearchSorted, inputs, attrs);
}
op({ searchSorted_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the 2D max pooling of an image.
 *
 * @param x The input tensor, of rank 4 or rank 3 of shape
 *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.
 * @param filterSize The filter size: `[filterHeight, filterWidth]`. If
 *     `filterSize` is a single number, then `filterHeight == filterWidth`.
 * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If
 *     `strides` is a single number, then `strideHeight == strideWidth`.
 * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`
 *     in which we sample input values across the height and width dimensions
 *     in dilated pooling. Defaults to `[1, 1]`. If `dilations` is a single
 *     number, then `dilationHeight == dilationWidth`. If it is greater than
 *     1, then all values of `strides` must be 1.
 * @param pad The type of padding algorithm.
 *    - `same` and stride 1: output will be of same size as input,
 *       regardless of filter size.
 *    - `valid`: output will be smaller than input if filter is larger
 *       than 1x1.
 *    - For more info, see this guide:
 *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](
 *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)
 * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is
 *     provided, it will default to truncate.
 */
function maxPool_(x, filterSize, strides, pad, dimRoundingMode) {
    const $x = convertToTensor(x, 'x', 'maxPool');
    const dilations = 1;
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert(x4D.rank === 4, () => `Error in maxPool: input must be rank 4 but got rank ${x4D.rank}.`);
    assert(eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in maxPool: Either strides or dilations must be 1. ' +
        `Got strides ${strides} and dilations '${dilations}'`);
    checkPadOnDimRoundingMode('maxPool', pad, dimRoundingMode);
    const inputs = { x: x4D };
    const attrs = { filterSize, strides, pad, dimRoundingMode };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    const res = ENGINE.runKernel(MaxPool, inputs, attrs);
    if (reshapedTo4D) {
        return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
}
const maxPool = op({ maxPool_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the 3D max pooling.
 *
 * ```js
 * const x = tf.tensor5d([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 2, 2, 1]);
 * const result = tf.maxPool3d(x, 2, 1, 'valid');
 * result.print();
 * ```
 *
 * @param x The input tensor, of rank 5 or rank 4 of shape
 *     `[batch, depth, height, width, inChannels]`.
 * @param filterSize The filter size:
 *     `[filterDepth, filterHeight, filterWidth]`.
 *     If `filterSize` is a single number,
 *     then `filterDepth == filterHeight == filterWidth`.
 * @param strides The strides of the pooling:
 *     `[strideDepth, strideHeight, strideWidth]`.
 *     If `strides` is a single number,
 *     then `strideDepth == strideHeight == strideWidth`.
 * @param pad The type of padding algorithm.
 *    - `same` and stride 1: output will be of same size as input,
 *       regardless of filter size.
 *    - `valid`: output will be smaller than input if filter is larger
 *       than 1*1x1.
 *    - For more info, see this guide:
 *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](
 *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)
 * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is
 *     provided, it will default to truncate.
 * @param dataFormat An optional string from: "NDHWC", "NCDHW". Defaults to
 *     "NDHWC". Specify the data format of the input and output data. With the
 *     default format "NDHWC", the data is stored in the order of: [batch,
 *     depth, height, width, channels]. Only "NDHWC" is currently supported.
 * @doc {heading: 'Operations', subheading: 'Convolution'}
 */
function maxPool3d_(x, filterSize = [1, 1, 1], strides, pad, dimRoundingMode, dataFormat = 'NDHWC') {
    const $x = convertToTensor(x, 'x', 'maxPool3d');
    let x5D = $x;
    let reshapedTo5D = false;
    if ($x.rank === 4) {
        reshapedTo5D = true;
        x5D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
    }
    assert(x5D.rank === 5, () => `Error in maxPool3d: x must be rank 5 but got rank ${x5D.rank}.`);
    assert(dataFormat === 'NDHWC', () => `Error in maxPool3d: Only NDHWC is currently supported, ` +
        `but got dataFormat of ${dataFormat}`);
    checkPadOnDimRoundingMode('maxPool3d', pad, dimRoundingMode);
    const inputs = { x: x5D };
    const attrs = { filterSize, strides, pad, dimRoundingMode, dataFormat };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    const res = ENGINE.runKernel(MaxPool3D, inputs, attrs);
    if (reshapedTo5D) {
        return reshape(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
    }
    return res;
}
op({ maxPool3d_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the 2D max pooling of an image with Argmax index.
 * The indices in argmax are flattened, so that a maximum value at position `[b,
 * y, x, c]` becomes flattened index: `(y * width + x) * channels + c` if
 * include_batch_in_index is False; `((b * height + y) * width + x) * channels
 * +c` if include_batch_in_index is True.
 *
 * The indices returned are always in `[0, height) x [0, width)` before
 * flattening.
 *
 * @param x The input tensor, of rank 4 or rank 3 of shape
 *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.
 * @param filterSize The filter size: `[filterHeight, filterWidth]`. If
 *     `filterSize` is a single number, then `filterHeight == filterWidth`.
 * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If
 *     `strides` is a single number, then `strideHeight == strideWidth`.
 * @param dataFormat An optional string from: "NDHWC", "NCDHW". Defaults to
 *     "NDHWC". Specify the data format of the input and output data. With the
 *     default format "NDHWC", the data is stored in the order of: [batch,
 *     depth, height, width, channels]. Only "NDHWC" is currently supported.
 * @param pad The type of padding algorithm.
 *    - `same` and stride 1: output will be of same size as input,
 *       regardless of filter size.
 *    - `valid`: output will be smaller than input if filter is larger
 *       than 1x1.
 *    - For more info, see this guide:
 *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](
 *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)
 * @param includeBatchIndex Defaults to False. Whether to include batch
 *    dimension in flattened index of argmax.
 *
 * @doc {heading: 'Operations', subheading: 'Convolution'}
 */
function maxPoolWithArgmax_(x, filterSize, strides, pad, includeBatchInIndex = false) {
    const $x = convertToTensor(x, 'x', 'maxPoolWithArgmax');
    const inputs = { x: $x };
    const attrs = { filterSize, strides, pad, includeBatchInIndex };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    const result = ENGINE.runKernel(MaxPoolWithArgmax, inputs, attrs);
    return { result: result[0], indexes: result[1] };
}
op({ maxPoolWithArgmax_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns the max of a and b (`a > b ? a : b`) element-wise.
 * Supports broadcasting.
 *
 * We also expose `tf.maximumStrict` which has the same signature as this op and
 * asserts that `a` and `b` are the same shape (does not broadcast).
 *
 * ```js
 * const a = tf.tensor1d([1, 4, 3, 16]);
 * const b = tf.tensor1d([1, 2, 9, 4]);
 *
 * a.maximum(b).print();  // or tf.maximum(a, b)
 * ```
 *
 * ```js
 * // Broadcast maximum a with b.
 * const a = tf.tensor1d([2, 4, 6, 8]);
 * const b = tf.scalar(5);
 *
 * a.maximum(b).print();  // or tf.maximum(a, b)
 * ```
 *
 * @param a The first tensor.
 * @param b The second tensor. Must have the same type as `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Arithmetic'}
 */
function maximum_(a, b) {
    let $a = convertToTensor(a, 'a', 'maximum');
    let $b = convertToTensor(b, 'b', 'maximum');
    [$a, $b] = makeTypesMatch($a, $b);
    if ($a.dtype === 'bool') {
        $a = cast($a, 'int32');
        $b = cast($b, 'int32');
    }
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Maximum, inputs);
}
op({ maximum_ });

/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the mean of elements across dimensions of a `tf.Tensor`.
 *
 * Reduces `x` along the dimensions given in `axis`. Unless `keepDims` is
 * true, the rank of the `tf.Tensor` is reduced by 1 for each entry in `axis`.
 * If `keepDims` is true, the reduced dimensions are retained with length 1.
 * If `axis` has no entries, all dimensions are reduced, and a `tf.Tensor` with
 * a single element is returned.
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3]);
 *
 * x.mean().print();  // or tf.mean(a)
 * ```
 *
 * ```js
 * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);
 *
 * const axis = 1;
 * x.mean(axis).print();  // or tf.mean(x, axis)
 * ```
 *
 * @param x The input tensor.
 * @param axis The dimension(s) to reduce. By default it reduces
 *     all dimensions.
 * @param keepDims If true, retains reduced dimensions with size 1.
 *
 * @doc {heading: 'Operations', subheading: 'Reduction'}
 */
function mean_(x, axis = null, keepDims = false) {
    const $x = convertToTensor(x, 'x', 'mean');
    const inputs = { x: $x };
    const attrs = { axis, keepDims };
    return ENGINE.runKernel(Mean, inputs, attrs);
}
const mean = op({ mean_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Creates a `tf.Tensor` with all elements set to 0.
 *
 * ```js
 * tf.zeros([2, 2]).print();
 * ```
 *
 * @param shape An array of integers defining the output tensor shape.
 * @param dtype The type of an element in the resulting tensor. Can
 *     be 'float32', 'int32' or 'bool'. Defaults to 'float'.
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */
function zeros(shape, dtype = 'float32') {
    if (dtype === 'complex64') {
        const real = zeros(shape, 'float32');
        const imag = zeros(shape, 'float32');
        return complex(real, imag);
    }
    const values = makeZerosTypedArray(sizeFromShape(shape), dtype);
    return ENGINE.makeTensor(values, shape, dtype);
}

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Creates a `tf.Tensor` with all elements set to 1.
 *
 * ```js
 * tf.ones([2, 2]).print();
 * ```
 *
 * @param shape An array of integers defining the output tensor shape.
 * @param dtype The type of an element in the resulting tensor. Defaults to
 *     'float'.
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */
function ones(shape, dtype = 'float32') {
    if (dtype === 'complex64') {
        const real = ones(shape, 'float32');
        const imag = zeros(shape, 'float32');
        return complex(real, imag);
    }
    const values = makeOnesTypedArray(sizeFromShape(shape), dtype);
    return ENGINE.makeTensor(values, shape, dtype);
}

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns the min of a and b (`a < b ? a : b`) element-wise.
 * Supports broadcasting.
 *
 * We also expose `minimumStrict` which has the same signature as this op and
 * asserts that `a` and `b` are the same shape (does not broadcast).
 *
 * ```js
 * const a = tf.tensor1d([1, 4, 3, 16]);
 * const b = tf.tensor1d([1, 2, 9, 4]);
 *
 * a.minimum(b).print();  // or tf.minimum(a, b)
 * ```
 *
 * ```js
 * // Broadcast minimum a with b.
 * const a = tf.tensor1d([2, 4, 6, 8]);
 * const b = tf.scalar(5);
 *
 * a.minimum(b).print();  // or tf.minimum(a, b)
 * ```
 *
 * @param a The first tensor.
 * @param b The second tensor. Must have the same type as `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Arithmetic'}
 */
function minimum_(a, b) {
    let $a = convertToTensor(a, 'a', 'minimum');
    let $b = convertToTensor(b, 'b', 'minimum');
    [$a, $b] = makeTypesMatch($a, $b);
    if ($a.dtype === 'bool') {
        $a = cast($a, 'int32');
        $b = cast($b, 'int32');
    }
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Minimum, inputs);
}
const minimum = op({ minimum_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Pads a `tf.Tensor` using mirror padding.
 *
 * This operation implements the `REFLECT` and `SYMMETRIC` modes of pad.
 *
 * ```js
 * const x = tf.range(0, 9).reshape([1, 1, 3, 3]);
 * x.mirrorPad([[0, 0], [0, 0], [2, 2], [2, 2]], 'reflect').print();
 * ```
 * @param x The tensor to pad.
 * @param paddings An array of length `R` (the rank of the tensor), where
 * each element is a length-2 tuple of ints `[padBefore, padAfter]`,
 * specifying how much to pad along each dimension of the tensor.
 * In "reflect" mode, the padded regions do not include the borders,
 * while in "symmetric" mode the padded regions do include the borders.
 * For example, if the input is `[1, 2, 3]` and paddings is `[0, 2]`,
 * then the output is `[1, 2, 3, 2, 1]` in "reflect" mode, and
 * `[1, 2, 3, 3, 2]` in "symmetric" mode.
 * If `mode` is "reflect" then both `paddings[D, 0]` and `paddings[D, 1]`
 * must be no greater than `x.shape[D] - 1`. If mode is "symmetric"
 * then both `paddings[D, 0]` and `paddings[D, 1]` must be no greater than
 * `x.shape[D]`
 * @param mode String to specify padding mode. Can be `'reflect' | 'symmetric'`
 */
/** @doc {heading: 'Tensors', subheading: 'Transformations'} */
function mirrorPad_(x, paddings, mode) {
    assert(mode === 'reflect' || mode === 'symmetric', () => `Invalid mode. Mode must be either reflect or symmetric. ` +
        `Got ${mode}.`);
    const $x = convertToTensor(x, 'x', 'mirrorPad');
    if ($x.rank === 0) {
        throw new Error('mirrorPad(scalar) is not defined. ' +
            'Pass non-scalar to mirrorPad');
    }
    assert(paddings.length === $x.rank, () => `Padding doesn't match input. Must be ${$x.rank}. ` +
        `Got ${paddings.length}.`);
    const shapeOffset = mode === 'reflect' ? 1 : 0;
    for (let i = 0; i < $x.rank; i++) {
        assert(paddings[i].length === 2, () => `Invalid number of paddings. Must be length of 2 each.`);
        assert(paddings[i][0] >= 0 && paddings[i][0] <= $x.shape[i] - shapeOffset &&
            paddings[i][1] >= 0 && paddings[i][1] <= $x.shape[i] - shapeOffset, () => `Padding in dimension ${i} cannot be greater than or equal ` +
            `to ${$x.shape[i] - shapeOffset} or less than 0 for input of ` +
            `shape ${$x.shape}`);
    }
    const attrs = { paddings, mode };
    const inputs = { x: $x };
    return ENGINE.runKernel(MirrorPad, inputs, attrs);
}
op({ mirrorPad_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns the mod of a and b element-wise.
 * `floor(x / y) * y + mod(x, y) = x`
 * Supports broadcasting.
 *
 * We also expose `tf.modStrict` which has the same signature as this op and
 * asserts that `a` and `b` are the same shape (does not broadcast).
 *
 * ```js
 * const a = tf.tensor1d([1, 4, 3, 16]);
 * const b = tf.tensor1d([1, 2, 9, 4]);
 *
 * a.mod(b).print();  // or tf.mod(a, b)
 * ```
 *
 * ```js
 * // Broadcast a mod b.
 * const a = tf.tensor1d([2, 4, 6, 8]);
 * const b = tf.scalar(5);
 *
 * a.mod(b).print();  // or tf.mod(a, b)
 * ```
 *
 * @param a The first tensor.
 * @param b The second tensor. Must have the same type as `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Arithmetic'}
 */
function mod_(a, b) {
    let $a = convertToTensor(a, 'a', 'mod');
    let $b = convertToTensor(b, 'b', 'mod');
    [$a, $b] = makeTypesMatch($a, $b);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Mod, inputs);
}
op({ mod_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Calculates the mean and variance of `x`. The mean and variance are
 * calculated by aggregating the contents of `x` across `axes`. If `x` is
 * 1-D and `axes = [0]` this is just the mean and variance of a vector.
 *
 * @param x The input tensor.
 * @param axis The dimension(s) along with to compute mean and
 *     variance. By default it reduces all dimensions.
 * @param keepDims If true, the moments have the same dimensionality as the
 *     input.
 * @return An object with two keys: `mean` and `variance`.
 *
 * @doc {heading: 'Operations', subheading: 'Normalization'}
 */
function moments_(x, axis = null, keepDims = false) {
    x = convertToTensor(x, 'x', 'moments');
    const axes = parseAxisParam(axis, x.shape);
    const xMean = mean(x, axes, keepDims);
    let keepDimsShape = xMean.shape;
    if (!keepDims) {
        keepDimsShape = expandShapeToKeepDim(xMean.shape, axes);
    }
    const devSquared = square(sub(cast(x, 'float32'), reshape(xMean, keepDimsShape)));
    const variance = mean(devSquared, axes, keepDims);
    return { mean: xMean, variance };
}
op({ moments_ });

/**
 * Computes the next states and outputs of a stack of LSTMCells.
 *
 * Each cell output is used as input to the next cell.
 *
 * Returns `[cellState, cellOutput]`.
 *
 * Derived from tf.contrib.rn.MultiRNNCell.
 *
 * @param lstmCells Array of LSTMCell functions.
 * @param data The input to the cell.
 * @param c Array of previous cell states.
 * @param h Array of previous cell outputs.
 *
 * @doc {heading: 'Operations', subheading: 'RNN'}
 */
function multiRNNCell_(lstmCells, data, c, h) {
    const $data = convertToTensor(data, 'data', 'multiRNNCell');
    const $c = convertToTensorArray(c, 'c', 'multiRNNCell');
    const $h = convertToTensorArray(h, 'h', 'multiRNNCell');
    let input = $data;
    const newStates = [];
    for (let i = 0; i < lstmCells.length; i++) {
        const output = lstmCells[i](input, $c[i], $h[i]);
        newStates.push(output[0]);
        newStates.push(output[1]);
        input = output[1];
    }
    const newC = [];
    const newH = [];
    for (let i = 0; i < newStates.length; i += 2) {
        newC.push(newStates[i]);
        newH.push(newStates[i + 1]);
    }
    return [newC, newH];
}
op({ multiRNNCell_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Creates a `tf.Tensor` with values drawn from a multinomial distribution.
 *
 * ```js
 * const probs = tf.tensor([.75, .25]);
 * tf.multinomial(probs, 3).print();
 * ```
 *
 * @param logits 1D array with unnormalized log-probabilities, or
 *     2D array of shape `[batchSize, numOutcomes]`. See the `normalized`
 *     parameter.
 * @param numSamples Number of samples to draw for each row slice.
 * @param seed The seed number.
 * @param normalized Whether the provided `logits` are normalized true
 *     probabilities (sum to 1). Defaults to false.
 * @return 1D array of shape `[numSamples]`, or 2D array of shape
 *     `[batchSize, numSamples]`, depending on the rank of the input.
 *
 * @doc {heading: 'Tensors', subheading: 'Random'}
 */
function multinomial_(logits, numSamples, seed, normalized = false) {
    const $logits = convertToTensor(logits, 'logits', 'multinomial');
    const numOutcomes = $logits.size;
    const origRank = $logits.rank;
    if (numOutcomes < 2) {
        throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ` +
            `${numOutcomes}.`);
    }
    if (origRank > 2) {
        throw new Error(`Rank of probabilities must be 1 or 2, but is ${origRank}`);
    }
    // TODO(lina128): Investigate correct seed behavior. The code seems not allow
    // setting see to 0.
    seed = seed || Math.random();
    // The kernel only accepts (and returns) rank 2 tensors.
    const logits2D = origRank === 1 ? reshape($logits, [1, -1]) : $logits;
    const inputs = { logits: logits2D };
    const attrs = { numSamples, seed, normalized };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    const res = ENGINE.runKernel(Multinomial, inputs, attrs);
    // tslint:disable-next-line:no-unnecessary-type-assertion
    return origRank === 1 ? reshape(res, [res.size]) : res;
}
op({ multinomial_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns the truth value of (a != b) element-wise. Supports broadcasting.
 *
 * ```js
 * const a = tf.tensor1d([1, 2, 3]);
 * const b = tf.tensor1d([0, 2, 3]);
 *
 * a.notEqual(b).print();
 * ```
 * @param a The first input tensor.
 * @param b The second input tensor. Must have the same dtype as `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Logical'}
 */
function notEqual_(a, b) {
    let $a = convertToTensor(a, 'a', 'notEqual', 'string_or_numeric');
    let $b = convertToTensor(b, 'b', 'notEqual', 'string_or_numeric');
    [$a, $b] = makeTypesMatch($a, $b);
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(NotEqual, inputs);
}
const notEqual = op({ notEqual_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Creates a one-hot `tf.Tensor`. The locations represented by `indices` take
 * value `onValue` (defaults to 1), while all other locations take value
 * `offValue` (defaults to 0). If `indices` is rank `R`, the output has rank
 * `R+1` with the last axis of size `depth`.
 * `indices` used to encode prediction class must start from 0. For example,
 *  if you have 3 classes of data, class 1 should be encoded as 0, class 2
 *  should be 1, and class 3 should be 2.
 *
 * ```js
 * tf.oneHot(tf.tensor1d([0, 1], 'int32'), 3).print();
 * ```
 *
 * @param indices `tf.Tensor` of indices with dtype `int32`. Indices must
 * start from 0.
 * @param depth The depth of the one hot dimension.
 * @param onValue A number used to fill in the output when the index matches
 * the location.
 * @param offValue A number used to fill in the output when the index does
 *     not match the location.
 * @param dtype The dtype of the output tensor, default to 'int32'.
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */
function oneHot_(indices, depth, onValue = 1, offValue = 0, dtype = 'int32') {
    if (depth < 2) {
        throw new Error(`Error in oneHot: depth must be >=2, but it is ${depth}`);
    }
    const $indices = convertToTensor(indices, 'indices', 'oneHot', 'int32');
    const inputs = { indices: $indices };
    const attrs = { dtype, depth, onValue, offValue };
    return ENGINE.runKernel(OneHot, inputs, attrs);
}
op({ oneHot_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Creates a `tf.Tensor` with all elements set to 1 with the same shape as the
 * given tensor.
 *
 * ```js
 * const x = tf.tensor([1, 2]);
 * tf.onesLike(x).print();
 * ```
 * @param x A tensor.
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */
function onesLike_(x) {
    const $x = convertToTensor(x, 'x', 'onesLike');
    const inputs = { x: $x };
    return ENGINE.runKernel(OnesLike, inputs);
}
op({ onesLike_ });

/**
 * Computes the outer product of two vectors, `v1` and `v2`.
 *
 * ```js
 * const a = tf.tensor1d([1, 2, 3]);
 * const b = tf.tensor1d([3, 4, 5]);
 *
 * tf.outerProduct(a, b).print();
 * ```
 * @param v1 The first vector in the outer product operation.
 * @param v2 The second vector in the outer product operation.
 *
 * @doc {heading: 'Operations', subheading: 'Matrices'}
 */
function outerProduct_(v1, v2) {
    const $v1 = convertToTensor(v1, 'v1', 'outerProduct');
    const $v2 = convertToTensor(v2, 'v2', 'outerProduct');
    assert($v1.rank === 1 && $v2.rank === 1, () => `Error in outerProduct: inputs must be rank 1, but got ranks ` +
        `${$v1.rank} and ${$v2.rank}.`);
    const v12D = reshape($v1, [-1, 1]);
    const v22D = reshape($v2, [1, -1]);
    return matMul(v12D, v22D);
}
op({ outerProduct_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Pads a `tf.Tensor` with a given value and paddings.
 *
 * This operation implements `CONSTANT` mode. For `REFLECT` and `SYMMETRIC`,
 * refer to `tf.mirrorPad`.
 *
 * Also available are stricter rank-specific methods with the same signature
 * as this method that assert that `paddings` is of given length.
 *   - `tf.pad1d`
 *   - `tf.pad2d`
 *   - `tf.pad3d`
 *   - `tf.pad4d`
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3, 4]);
 * x.pad([[1, 2]]).print();
 * ```
 * @param x The tensor to pad.
 * @param paddings An array of length `R` (the rank of the tensor), where
 * each element is a length-2 tuple of ints `[padBefore, padAfter]`,
 * specifying how much to pad along each dimension of the tensor.
 * @param constantValue The pad value to use. Defaults to 0.
 *
 * @doc {heading: 'Tensors', subheading: 'Transformations'}
 */
function pad_(x, paddings, constantValue = 0) {
    const $x = convertToTensor(x, 'x', 'pad');
    if ($x.rank === 0) {
        throw new Error('pad(scalar) is not defined. Pass non-scalar to pad');
    }
    const attrs = { paddings, constantValue };
    const inputs = { x: $x };
    return ENGINE.runKernel(PadV2, inputs, attrs);
}
const pad = op({ pad_ });

/**
 * Pads a `tf.Tensor1D` with a given value and paddings. See `pad` for details.
 */
function pad1d_(x, paddings, constantValue = 0) {
    assert(paddings.length === 2, () => 'Invalid number of paddings. Must be length of 2.');
    return pad(x, [paddings], constantValue);
}
op({ pad1d_ });

/**
 * Pads a `tf.Tensor2D` with a given value and paddings. See `pad` for details.
 */
function pad2d_(x, paddings, constantValue = 0) {
    assert(paddings.length === 2 && paddings[0].length === 2 &&
        paddings[1].length === 2, () => 'Invalid number of paddings. Must be length of 2 each.');
    return pad(x, paddings, constantValue);
}
op({ pad2d_ });

/**
 * Pads a `tf.Tensor3D` with a given value and paddings. See `pad` for details.
 */
function pad3d_(x, paddings, constantValue = 0) {
    assert(paddings.length === 3 && paddings[0].length === 2 &&
        paddings[1].length === 2 && paddings[2].length === 2, () => 'Invalid number of paddings. Must be length of 2 each.');
    return pad(x, paddings, constantValue);
}
op({ pad3d_ });

/**
 * Pads a `tf.Tensor4D` with a given value and paddings. See `pad` for details.
 */
function pad4d_(x, paddings, constantValue = 0) {
    assert(paddings.length === 4 && paddings[0].length === 2 &&
        paddings[1].length === 2 && paddings[2].length === 2 &&
        paddings[3].length === 2, () => 'Invalid number of paddings. Must be length of 2 each.');
    return pad(x, paddings, constantValue);
}
op({ pad4d_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * This operation divides "spatial" dimensions `[1, ..., M]` of the input into
 * a grid of blocks of shape `blockShape`, and interleaves these blocks with
 * the "batch" dimension (0) such that in the output, the spatial
 * dimensions `[1, ..., M]` correspond to the position within the grid,
 * and the batch dimension combines both the position within a spatial block
 * and the original batch position. Prior to division into blocks,
 * the spatial dimensions of the input are optionally zero padded
 * according to `paddings`. See below for a precise description.
 *
 * ```js
 * const x = tf.tensor4d([1, 2, 3, 4], [1, 2, 2, 1]);
 * const blockShape = [2, 2];
 * const paddings = [[0, 0], [0, 0]];
 *
 * x.spaceToBatchND(blockShape, paddings).print();
 * ```
 *
 * @param x A `tf.Tensor`. N-D with `x.shape` = `[batch] + spatialShape +
 * remainingShape`, where spatialShape has `M` dimensions.
 * @param blockShape A 1-D array. Must have shape `[M]`, all values must
 * be >= 1.
 * @param paddings A 2-D array. Must have shape `[M, 2]`, all values must be >=
 *     0. `paddings[i] = [padStart, padEnd]` specifies the amount to zero-pad
 * from input dimension `i + 1`, which corresponds to spatial dimension `i`. It
 * is required that
 * `(inputShape[i + 1] + padStart + padEnd) % blockShape[i] === 0`
 *
 * This operation is equivalent to the following steps:
 *
 * 1. Zero-pad the start and end of dimensions `[1, ..., M]` of the input
 * according to `paddings` to produce `padded` of shape paddedShape.
 *
 * 2. Reshape `padded` to `reshapedPadded` of shape:
 * `[batch] + [paddedShape[1] / blockShape[0], blockShape[0], ...,
 * paddedShape[M] / blockShape[M-1], blockShape[M-1]] + remainingShape`
 *
 * 3. Permute dimensions of `reshapedPadded` to produce `permutedReshapedPadded`
 * of shape: `blockShape + [batch] + [paddedShape[1] / blockShape[0], ...,
 * paddedShape[M] / blockShape[M-1]] + remainingShape`
 *
 * 4. Reshape `permutedReshapedPadded` to flatten `blockShape` into the
 * batch dimension, producing an output tensor of shape:
 * `[batch * prod(blockShape)] + [paddedShape[1] / blockShape[0], ...,
 * paddedShape[M] / blockShape[M-1]] + remainingShape`
 *
 * @doc {heading: 'Tensors', subheading: 'Transformations'}
 */
function spaceToBatchND_(x, blockShape, paddings) {
    const $x = convertToTensor(x, 'x', 'spaceToBatchND');
    assert($x.rank >= 1 + blockShape.length, () => `input rank ${$x.rank} should be > than [blockShape] ${blockShape.length}`);
    assert(paddings.length === blockShape.length, () => `paddings.shape[0] ${paddings.length} must be equal to [blockShape] ${blockShape.length}`);
    assert($x.shape.reduce((a, b, i) => {
        if (i > 0 && i <= blockShape.length) {
            return a &&
                ((b + paddings[i - 1][0] + paddings[i - 1][1]) %
                    blockShape[i - 1] ===
                    0);
        }
        return a;
    }, true), () => `input spatial dimensions ${$x.shape.slice(1)} with paddings ${paddings.toString()} must be divisible by blockShapes ${blockShape.toString()}`);
    const inputs = { x: $x };
    const attrs = { blockShape, paddings };
    return ENGINE.runKernel(SpaceToBatchND, inputs, attrs);
}
const spaceToBatchND = op({ spaceToBatchND_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Performs an N-D pooling operation
 *
 * @param input The input tensor, of rank 4 or rank 3 of shape
 *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.
 * @param windowShape The filter size: `[filterHeight, filterWidth]`. If
 *     `filterSize` is a single number, then `filterHeight == filterWidth`.
 * @param poolingType The type of pooling, either 'max' or 'avg'.
 * @param pad The type of padding algorithm:
 *    - `same` and stride 1: output will be of same size as input,
 *       regardless of filter size.
 *    - `valid`: output will be smaller than input if filter is larger
 *       than 1x1.
 *    - For more info, see this guide:
 *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](
 *         https://www.tensorflow.org/api_guides/python/nn#Convolution)
 * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`
 *     in which we sample input values across the height and width dimensions
 *     in dilated pooling. Defaults to `[1, 1]`. If `dilationRate` is a single
 *     number, then `dilationHeight == dilationWidth`. If it is greater than
 *     1, then all values of `strides` must be 1.
 * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If
 *     `strides` is a single number, then `strideHeight == strideWidth`.
 * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is
 *     provided, it will default to truncate.
 *
 * @doc {heading: 'Operations', subheading: 'Convolution'}
 */
function pool_(input, windowShape, poolingType, pad, dilations, strides, dimRoundingMode) {
    if (dilations == null) {
        dilations = [1, 1];
    }
    if (strides == null) {
        strides = 1;
    }
    if (pad === 0) {
        pad = 'valid';
    }
    const $x = convertToTensor(input, 'x', 'maxPool');
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert(eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in pool: Either strides or dilations must be 1. ' +
        `Got strides ${strides} and dilations '${dilations}'`);
    const convInfo = computePool2DInfo(x4D.shape, windowShape, strides, dilations, pad);
    const dilation = [convInfo.dilationHeight, convInfo.dilationWidth];
    // The following implementation does batchToSpace(pool(spaceToBatch(x)))
    // whenever dilation > 1 since the TF kernels do not support dilation > 1.
    // tslint:disable-next-line:max-line-length
    // https://github.com/tensorflow/tensorflow/blob/50f6bb67dc98c9b74630b6047aae7a4f8a40fd02/tensorflow/python/ops/nn_ops.py#L1037
    let basePadding;
    if (pad === 'same') {
        basePadding = withSpaceToBatchBasePaddings([convInfo.filterHeight, convInfo.filterWidth], dilation);
    }
    else {
        basePadding = [[0, 0], [0, 0]];
    }
    const isDilationOne = dilation[0] === 1 && dilation[1] === 1;
    const [adjustedPadding, adjustedCrops] = requiredSpaceToBatchPaddings([convInfo.inHeight, convInfo.inWidth], dilation, basePadding);
    const convertedPad = isDilationOne ? pad : 'valid';
    const convertedX = isDilationOne ? x4D : spaceToBatchND(x4D, dilation, adjustedPadding);
    const forwardOp = poolingType === 'avg' ?
        () => avgPool(convertedX, windowShape, strides, convertedPad, dimRoundingMode) :
        () => maxPool(convertedX, windowShape, strides, convertedPad, dimRoundingMode);
    const y = forwardOp();
    const res = isDilationOne ? y : batchToSpaceND(y, dilation, adjustedCrops);
    if (reshapedTo4D) {
        return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
}
// Helper function to compute crops and paddings for pool with dilation > 1.
// tslint:disable-next-line:max-line-length
// https://github.com/tensorflow/tensorflow/blob/50f6bb67dc98c9b74630b6047aae7a4f8a40fd02/tensorflow/python/ops/array_ops.py#L2184
function requiredSpaceToBatchPaddings(inputShape, blockShape, basePadding) {
    const padStart = basePadding.map(b => b[0]);
    const origPadEnd = basePadding.map(b => b[1]);
    const fullInputShape = inputShape.concat(padStart, origPadEnd);
    const padEndExtra = blockShape.map((b, i) => (b - fullInputShape[i] % b) % b);
    const padEnd = origPadEnd.map((s, i) => s + padEndExtra[i]);
    const paddings = blockShape.map((_, i) => [padStart[i], padEnd[i]]);
    const crops = blockShape.map((_, i) => [0, padEndExtra[i]]);
    return [paddings, crops];
}
// Helper function to compute base paddings for pool with dilation > 1.
// tslint:disable-next-line:max-line-length
// https://github.com/tensorflow/tensorflow/blob/50f6bb67dc98c9b74630b6047aae7a4f8a40fd02/tensorflow/python/ops/nn_ops.py#L524
function withSpaceToBatchBasePaddings(filterShape, dilation) {
    // Spatial dimensions of the filters and the upsampled filters in which we
    // introduce (rate - 1) zeros between consecutive filter values.
    const dilatedFilterShape = filterShape.map((s, i) => {
        return s + (s - 1) * (dilation[i] - 1);
    });
    const padExtraShape = dilatedFilterShape.map(s => s - 1);
    // When padding is odd, we pad more at end, following the same
    // convention as conv2d.
    const padExtraStart = padExtraShape.map(s => Math.floor(s / 2));
    const padExtraEnd = padExtraShape.map((s, i) => s - padExtraStart[i]);
    return padExtraShape.map((_, i) => {
        return [padExtraStart[i], padExtraEnd[i]];
    });
}
op({ pool_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes leaky rectified linear element-wise with parametric alphas.
 *
 * `x < 0 ? alpha * x : f(x) = x`
 *
 * ```js
 * const x = tf.tensor1d([-1, 2, -3, 4]);
 * const alpha = tf.scalar(0.1);
 *
 * x.prelu(alpha).print();  // or tf.prelu(x, alpha)
 * ```
 * @param x The input tensor.
 * @param alpha Scaling factor for negative values.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function prelu_(x, alpha) {
    const $x = convertToTensor(x, 'x', 'prelu');
    const $alpha = convertToTensor(alpha, 'alpha', 'prelu');
    const inputs = { x: $x, alpha: $alpha };
    return ENGINE.runKernel(Prelu, inputs);
}
const prelu = op({ prelu_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the product of elements across dimensions of a `tf.Tensor`.
 *
 * Reduces the input along the dimensions given in `axes`. Unless `keepDims`
 * is true, the rank of the `tf.Tensor` is reduced by 1 for each entry in
 * `axes`. If `keepDims` is true, the reduced dimensions are retained with
 * length 1. If `axes` has no entries, all dimensions are reduced, and a
 * `tf.Tensor` with a single element is returned.
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3]);
 *
 * x.prod().print();  // or tf.prod(x)
 * ```
 *
 * ```js
 * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);
 *
 * const axis = 1;
 * x.prod(axis).print();  // or tf.prod(x, axis)
 * ```
 *
 * @param x The input tensor to compute the product over. If the dtype is `bool`
 *   it will be converted to `int32` and the output dtype will be `int32`.
 * @param axis The dimension(s) to reduce. By default it reduces
 *     all dimensions.
 * @param keepDims If true, retains reduced dimensions with size 1.
 *
 * @doc {heading: 'Operations', subheading: 'Reduction'}
 */
function prod_(x, axis = null, keepDims = false) {
    let $x = convertToTensor(x, 'x', 'prod');
    if ($x.dtype === 'bool') {
        // bool is not an allowed type for the underlying kernel.
        $x = cast($x, 'int32');
    }
    const inputs = { x: $x };
    const attrs = { axis, keepDims };
    return ENGINE.runKernel(Prod, inputs, attrs);
}
op({ prod_ });

/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function raggedGather_(paramsNestedSplits, paramsDenseValues, indices, outputRaggedRank) {
    const $paramsNestedSplits = paramsNestedSplits.map((t, i) => convertToTensor(t, `tensors${i}`, 'raggedGather', 'int32'));
    const $paramsDenseValues = convertToTensor(paramsDenseValues, 'paramsDenseValues', 'raggedGather');
    const $indices = convertToTensor(indices, 'indices', 'raggedGather', 'int32');
    const inputs = {
        paramsNestedSplits: $paramsNestedSplits,
        paramsDenseValues: $paramsDenseValues,
        indices: $indices,
    };
    const attrs = { outputRaggedRank };
    const result = ENGINE.runKernel(RaggedGather, inputs, attrs);
    return {
        outputNestedSplits: result.slice(0, result.length - 1),
        outputDenseValues: result[result.length - 1],
    };
}
op({ raggedGather_ });

/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Create a dense tensor from a ragged tensor, possibly altering its shape.
 *
 * The raggedTensorToTensor op creates a dense tensor from am array of row
 * partition tensors, a value vector, and default values. If the shape is
 * unspecified, the minimal shape required to contain all the elements in the
 * ragged tensor (the natural shape) will be used. If some dimensions are left
 * unspecified, then the size of the natural shape is used in that dimension.
 *
 * The defaultValue will be broadcast to the output shape. After that, the
 * values from the ragged tensor overwrite the default values. Note that the
 * defaultValue must have less dimensions than the value.
 *
 * The row partition tensors are in the order of the dimensions. At present, the
 * types can be: "ROW_SPLITS": the row_splits tensor from the ragged tensor.
 *   "VALUE_ROWIDS": the value_rowids tensor from the ragged tensor.
 *   "FIRST_DIM_SIZE": if value_rowids is used for the first dimension, then it
 * is preceded by "FIRST_DIM_SIZE".
 * ```
 * @param shape: A Tensor. Must be one of the following types: 'int32'. The
 *     desired shape of the output tensor. If left unspecified (empty), the
 *     minimal shape required to contain all the elements in the ragged tensor
 *     (the natural shape) will be used. If some dimensions are left
 *     unspecified, then the size of the natural shape is used in that
 *     dimension.
 *
 *     Note that dense dimensions cannot be modified by the shape argument.
 *     Trying to change the size of a dense dimension will cause the op to fail.
 *     Examples: natural shape: [4, 5, 6] shape: -1 output shape: [4, 5, 6]
 *
 *     natural shape: [4, 5, 6] shape: [3, -1, 2] output shape: [3, 5, 2]
 *
 *     natural shape: [4, 5, 6] shape: [3, 7, 2] output shape: [3, 7, 2]
 * @param values: A Tensor. A 1D tensor representing the values of the ragged
 *     tensor.
 * @param defaultValue: A Tensor. Must have the same type as values. The
 *     defaultValue when the shape is larger than the ragged tensor. The
 *     defaultValue is broadcast until it is the shape of the output tensor,
 *     and then overwritten by values in the ragged tensor. The default value
 *     must be compatible with this broadcast operation, and must have fewer
 *     dimensions than the value tensor.
 * @param rowPartitionTensors: A list of at least 1 Tensor objects with the same
 *     type in: 'int32'.
 * @param rowPartitionTypes: A list of strings. The types of the row partition
 *     tensors. At present, these can be:
 *     "ROW_SPLITS": the row_splits tensor from the ragged tensor.
 *     "VALUE_ROWIDS": the value_rowids tensor from the ragged tensor.
 *     "FIRST_DIM_SIZE": if value_rowids is used for the first dimension, then
 *         it is preceeded by "FIRST_DIM_SIZE". The tensors are in the order of
 *         the dimensions.
 * @return A Tensor. Has the same type as values.
 * @doc {heading: 'Operations', subheading: 'Ragged'}
 */
function raggedTensorToTensor_(shape, values, defaultValue, rowPartitionTensors, rowPartitionTypes) {
    const $shape = convertToTensor(shape, 'shape', 'raggedTensorToTensor', 'int32');
    const $values = convertToTensor(values, 'values', 'raggedTensorToTensor');
    const $defaultValue = convertToTensor(defaultValue, 'defaultValue', 'raggedTensorToTensor', $values.dtype);
    const $rowPartitionTensors = rowPartitionTensors.map((t, i) => convertToTensor(t, `tensors${i}`, 'raggedTensorToTensor', 'int32'));
    const inputs = {
        shape: $shape,
        values: $values,
        defaultValue: $defaultValue,
        rowPartitionTensors: $rowPartitionTensors
    };
    const attrs = { rowPartitionTypes };
    return ENGINE.runKernel(RaggedTensorToTensor, inputs, attrs);
}
op({ raggedTensorToTensor_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Creates a `tf.Tensor` with values sampled from a random number generator
 * function defined by the user.
 *
 * @param shape An array of integers defining the output tensor shape.
 * @param randFunction A random number generator function which is called
 * for each element in the output tensor.
 * @param dtype The data type of the output tensor. Defaults to 'float32'.
 *
 * @doc {heading: 'Tensors', subheading: 'Random'}
 */
function rand_(shape, randFunction, dtype) {
    const size = sizeFromShape(shape);
    let values = null;
    if (dtype == null || dtype === 'float32') {
        values = new Float32Array(size);
    }
    else if (dtype === 'int32') {
        values = new Int32Array(size);
    }
    else if (dtype === 'bool') {
        values = new Uint8Array(size);
    }
    else {
        throw new Error(`Unknown data type ${dtype}`);
    }
    for (let i = 0; i < size; i++) {
        values[i] = randFunction();
    }
    return ENGINE.makeTensor(values, shape, dtype);
}
op({ rand_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
// https://en.wikipedia.org/wiki/Marsaglia_polar_method
class MPRandGauss {
    constructor(mean, stdDeviation, dtype, truncated, seed) {
        this.mean = mean;
        this.stdDev = stdDeviation;
        this.dtype = dtype;
        this.nextVal = NaN;
        this.truncated = truncated;
        if (this.truncated) {
            this.upper = this.mean + this.stdDev * 2;
            this.lower = this.mean - this.stdDev * 2;
        }
        const seedValue = seed ? seed : Math.random();
        this.random = seedrandom.alea(seedValue.toString());
    }
    /** Returns next sample from a Gaussian distribution. */
    nextValue() {
        if (!isNaN(this.nextVal)) {
            const value = this.nextVal;
            this.nextVal = NaN;
            return value;
        }
        let resultX, resultY;
        let isValid = false;
        while (!isValid) {
            let v1, v2, s;
            do {
                v1 = 2 * this.random() - 1;
                v2 = 2 * this.random() - 1;
                s = v1 * v1 + v2 * v2;
            } while (s >= 1 || s === 0);
            const mul = Math.sqrt(-2.0 * Math.log(s) / s);
            resultX = this.mean + this.stdDev * v1 * mul;
            resultY = this.mean + this.stdDev * v2 * mul;
            if (!this.truncated || this.isValidTruncated(resultX)) {
                isValid = true;
            }
        }
        if (!this.truncated || this.isValidTruncated(resultY)) {
            this.nextVal = this.convertValue(resultY);
        }
        return this.convertValue(resultX);
    }
    /** Handles proper rounding for non-floating-point numbers. */
    convertValue(value) {
        if (this.dtype == null || this.dtype === 'float32') {
            return value;
        }
        return Math.round(value);
    }
    /** Returns true if less than 2-standard-deviations from the mean. */
    isValidTruncated(value) {
        return value <= this.upper && value >= this.lower;
    }
}
// Marsaglia, George, and Wai Wan Tsang. 2000. "A Simple Method for Generating
// Gamma Variables."
class RandGamma {
    constructor(alpha, beta, dtype, seed) {
        this.alpha = alpha;
        this.beta = 1 / beta; // convert rate to scale parameter
        this.dtype = dtype;
        const seedValue = seed ? seed : Math.random();
        this.randu = seedrandom.alea(seedValue.toString());
        this.randn = new MPRandGauss(0, 1, dtype, false, this.randu());
        if (alpha < 1) {
            this.d = alpha + (2 / 3);
        }
        else {
            this.d = alpha - (1 / 3);
        }
        this.c = 1 / Math.sqrt(9 * this.d);
    }
    /** Returns next sample from a gamma distribution. */
    nextValue() {
        let x2, v0, v1, x, u, v;
        while (true) {
            do {
                x = this.randn.nextValue();
                v = 1 + (this.c * x);
            } while (v <= 0);
            v *= v * v;
            x2 = x * x;
            v0 = 1 - (0.331 * x2 * x2);
            v1 = (0.5 * x2) + (this.d * (1 - v + Math.log(v)));
            u = this.randu();
            if (u < v0 || Math.log(u) < v1) {
                break;
            }
        }
        v = (1 / this.beta) * this.d * v;
        if (this.alpha < 1) {
            v *= Math.pow(this.randu(), 1 / this.alpha);
        }
        return this.convertValue(v);
    }
    /** Handles proper rounding for non-floating-point numbers. */
    convertValue(value) {
        if (this.dtype === 'float32') {
            return value;
        }
        return Math.round(value);
    }
}
class UniformRandom {
    constructor(min = 0, max = 1, dtype, seed) {
        /** Handles proper rounding for non floating point numbers. */
        this.canReturnFloat = () => (this.dtype == null || this.dtype === 'float32');
        this.min = min;
        this.range = max - min;
        this.dtype = dtype;
        if (seed == null) {
            seed = Math.random();
        }
        if (typeof seed === 'number') {
            seed = seed.toString();
        }
        if (!this.canReturnFloat() && this.range <= 1) {
            throw new Error(`The difference between ${min} - ${max} <= 1 and dtype is not float`);
        }
        this.random = seedrandom.alea(seed);
    }
    convertValue(value) {
        if (this.canReturnFloat()) {
            return value;
        }
        return Math.round(value);
    }
    nextValue() {
        return this.convertValue(this.min + this.range * this.random());
    }
}

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Creates a `tf.Tensor` with values sampled from a gamma distribution.
 *
 * ```js
 * tf.randomGamma([2, 2], 1).print();
 * ```
 *
 * @param shape An array of integers defining the output tensor shape.
 * @param alpha The shape parameter of the gamma distribution.
 * @param beta The inverse scale parameter of the gamma distribution. Defaults
 *     to 1.
 * @param dtype The data type of the output. Defaults to float32.
 * @param seed The seed for the random number generator.
 *
 * @doc {heading: 'Tensors', subheading: 'Random'}
 */
function randomGamma_(shape, alpha, beta = 1, dtype = 'float32', seed) {
    if (beta == null) {
        beta = 1;
    }
    if (dtype == null) {
        dtype = 'float32';
    }
    if (dtype !== 'float32' && dtype !== 'int32') {
        throw new Error(`Unsupported data type ${dtype}`);
    }
    const rgamma = new RandGamma(alpha, beta, dtype, seed);
    const res = buffer(shape, dtype);
    for (let i = 0; i < res.values.length; i++) {
        res.values[i] = rgamma.nextValue();
    }
    return res.toTensor();
}
op({ randomGamma_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Creates a `tf.Tensor` with values sampled from a normal distribution.
 *
 * ```js
 * tf.randomNormal([2, 2]).print();
 * ```
 *
 * @param shape An array of integers defining the output tensor shape.
 * @param mean The mean of the normal distribution.
 * @param stdDev The standard deviation of the normal distribution.
 * @param dtype The data type of the output.
 * @param seed The seed for the random number generator.
 *
 * @doc {heading: 'Tensors', subheading: 'Random'}
 */
function randomNormal_(shape, mean = 0, stdDev = 1, dtype, seed) {
    if (dtype != null && dtype === 'bool') {
        throw new Error(`Unsupported data type ${dtype}`);
    }
    const randGauss = new MPRandGauss(mean, stdDev, dtype, false /* truncated */, seed);
    const res = buffer(shape, dtype);
    for (let i = 0; i < res.values.length; i++) {
        res.values[i] = randGauss.nextValue();
    }
    return res.toTensor();
}
const randomNormal = op({ randomNormal_ });

/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Creates a `tf.Tensor` with values sampled from a normal distribution.
 *
 * The generated values will have mean 0 and standard deviation 1.
 *
 * ```js
 * tf.randomStandardNormal([2, 2]).print();
 * ```
 *
 * @param shape An array of integers defining the output tensor shape.
 * @param dtype The data type of the output.
 * @param seed The seed for the random number generator.
 *
 * @doc {heading: 'Tensors', subheading: 'Random'}
 */
function randomStandardNormal_(shape, dtype, seed) {
    if (dtype != null && dtype === 'bool') {
        throw new Error(`Unsupported data type ${dtype}`);
    }
    return randomNormal(shape, 0, 1, dtype, seed);
}
op({ randomStandardNormal_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Creates a `tf.Tensor` with values sampled from a uniform distribution.
 *
 * The generated values follow a uniform distribution in the range [minval,
 * maxval). The lower bound minval is included in the range, while the upper
 * bound maxval is excluded.
 *
 * ```js
 * tf.randomUniform([2, 2]).print();
 * ```
 *
 * @param shape An array of integers defining the output tensor shape.
 * @param minval The lower bound on the range of random values to generate.
 *   Defaults to 0.
 * @param maxval The upper bound on the range of random values to generate.
 *   Defaults to 1.
 * @param dtype The data type of the output tensor. Defaults to 'float32'.
 *
 * @doc {heading: 'Tensors', subheading: 'Random'}
 */
function randomUniform_(shape, minval = 0, maxval = 1, dtype = 'float32', seed) {
    const res = buffer(shape, dtype);
    const random = new UniformRandom(minval, maxval, null, seed);
    for (let i = 0; i < res.values.length; i++) {
        res.values[i] = random.nextValue();
    }
    return res.toTensor();
}
const randomUniform = op({ randomUniform_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Creates a new `tf.Tensor1D` filled with the numbers in the range provided.
 *
 * The tensor is a half-open interval meaning it includes start, but
 * excludes stop. Decrementing ranges and negative step values are also
 * supported.
 *
 *
 * ```js
 * tf.range(0, 9, 2).print();
 * ```
 *
 * @param start An integer start value
 * @param stop An integer stop value
 * @param step An integer increment (will default to 1 or -1)
 * @param dtype The data type of the output tensor. Defaults to 'float32'.
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */
function range(start, stop, step = 1, dtype = 'float32') {
    if (step === 0) {
        throw new Error('Cannot have a step of zero');
    }
    const attrs = { start, stop, step, dtype };
    return ENGINE.runKernel(Range, {} /* inputs */, attrs);
}

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns the real part of a complex (or real) tensor.
 *
 * Given a tensor input, this operation returns a tensor of type float that is
 * the real part of each element in input considered as a complex number.
 *
 * If the input is real, it simply makes a clone.
 *
 * ```js
 * const x = tf.complex([-2.25, 3.25], [4.75, 5.75]);
 * tf.real(x).print();
 * ```
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */
function real_(input) {
    const $input = convertToTensor(input, 'input', 'real');
    const inputs = { input: $input };
    return ENGINE.runKernel(Real, inputs);
}
const real = op({ real_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes reciprocal of x element-wise: `1 / x`
 *
 * ```js
 * const x = tf.tensor1d([0, 1, 2]);
 *
 * x.reciprocal().print();  // or tf.reciprocal(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function reciprocal_(x) {
    const $x = convertToTensor(x, 'x', 'reciprocal');
    const inputs = { x: $x };
    return ENGINE.runKernel(Reciprocal, inputs);
}
op({ reciprocal_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes rectified linear element-wise: `max(x, 0)`.
 *
 * ```js
 * const x = tf.tensor1d([-1, 2, -3, 4]);
 *
 * x.relu().print();  // or tf.relu(x)
 * ```
 * @param x The input tensor. If the dtype is `bool`, the output dtype will be
 *     `int32`.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function relu_(x) {
    const $x = convertToTensor(x, 'x', 'relu');
    const inputs = { x: $x };
    return ENGINE.runKernel(Relu, inputs);
}
const relu = op({ relu_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes rectified linear 6 element-wise: `min(max(x, 0), 6)`.
 *
 * ```js
 * const x = tf.tensor1d([-1, 2, -3, 8]);
 *
 * x.relu6().print();  // or tf.relu6(x)
 * ```
 * @param x The input tensor. If the dtype is `bool`, the output dtype will be
 *     `int32`.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function relu6_(x) {
    const $x = convertToTensor(x, 'x', 'relu6');
    const inputs = { x: $x };
    return ENGINE.runKernel(Relu6, inputs);
}
const relu6 = op({ relu6_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Reverses a `tf.Tensor` along a specified axis.
 *
 * Also available are stricter rank-specific methods that assert that `x` is
 * of the given rank:
 *   - `tf.reverse1d`
 *   - `tf.reverse2d`
 *   - `tf.reverse3d`
 *   - `tf.reverse4d`
 *
 * Except `tf.reverse1d` (which does not have axis param), all methods have
 * same signature as this method.
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3, 4]);
 *
 * x.reverse().print();
 * ```
 *
 * ```js
 * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);
 *
 * const axis = 1;
 * x.reverse(axis).print();
 * ```
 * @param x The input tensor to be reversed.
 * @param axis The set of dimensions to reverse. Must be in the
 *     range [-rank(x), rank(x)). Defaults to all axes.
 *
 * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}
 */
function reverse_(x, axis) {
    const $x = convertToTensor(x, 'x', 'reverse');
    const inputs = { x: $x };
    const attrs = { dims: axis };
    return ENGINE.runKernel(Reverse, inputs, attrs);
}
const reverse = op({ reverse_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Reverses a `tf.Tensor1D`.
 *
 * @param x The input tensor.
 */
function reverse1d_(x) {
    const $x = convertToTensor(x, 'x', 'reverse');
    assert($x.rank === 1, () => `Error in reverse1D: x must be rank 1 but got rank ${$x.rank}.`);
    return reverse($x, 0);
}
op({ reverse1d_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Reverses a `tf.Tensor2D` along a specified axis.
 *
 * @param x The input tensor.
 * @param axis The set of dimensions to reverse. Must be in the
 *     range [-rank(x), rank(x)). Defaults to all axes.
 */
function reverse2d_(x, axis) {
    const $x = convertToTensor(x, 'x', 'reverse');
    assert($x.rank === 2, () => `Error in reverse2D: x must be rank 2 but got rank ${$x.rank}.`);
    return reverse($x, axis);
}
op({ reverse2d_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Reverses a `tf.Tensor3D` along a specified axis.
 *
 * @param x The input tensor.
 * @param axis The set of dimensions to reverse. Must be in the
 *     range [-rank(x), rank(x)). Defaults to all axes.
 */
function reverse3d_(x, axis) {
    const $x = convertToTensor(x, 'x', 'reverse');
    assert($x.rank === 3, () => `Error in reverse3D: x must be rank 3 but got rank ${$x.rank}.`);
    return reverse($x, axis);
}
op({ reverse3d_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Reverses a `tf.Tensor4D` along a specified axis.
 *
 * @param x The input tensor.
 * @param axis The set of dimensions to reverse. Must be in the
 *     range [-rank(x), rank(x)). Defaults to all axes.
 */
function reverse4d_(x, axis) {
    const $x = convertToTensor(x, 'x', 'reverse');
    assert($x.rank === 4, () => `Error in reverse4D: x must be rank 4 but got rank ${$x.rank}.`);
    return reverse($x, axis);
}
op({ reverse4d_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes round of input `tf.Tensor` element-wise: `round(x)`.
 * It implements banker's rounding.
 *
 * ```js
 * const x = tf.tensor1d([.6, 1.1, -3.3]);
 *
 * x.round().print();  // or tf.round(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function round_(x) {
    const $x = convertToTensor(x, 'x', 'round');
    const inputs = { x: $x };
    return ENGINE.runKernel(Round, inputs);
}
const round$1 = op({ round_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes reciprocal of square root of the input `tf.Tensor` element-wise:
 * `y = 1 / sqrt(x)`
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 4, -1]);
 *
 * x.rsqrt().print();  // or tf.rsqrt(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function rsqrt_(x) {
    const $x = convertToTensor(x, 'x', 'rsqrt', 'float32');
    const inputs = { x: $x };
    return ENGINE.runKernel(Rsqrt, inputs);
}
op({ rsqrt_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes scaled exponential linear element-wise.
 *
 * `x < 0 ? scale * alpha * (exp(x) - 1) : scale * x`
 *
 * ```js
 * const x = tf.tensor1d([-1, 2, -3, 4]);
 *
 * x.selu().print();  // or tf.selu(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function selu_(x) {
    const $x = convertToTensor(x, 'x', 'selu');
    const inputs = { x: $x };
    return ENGINE.runKernel(Selu, inputs);
}
op({ selu_ });

/**
 * 2-D convolution with separable filters.
 *
 * Performs a depthwise convolution that acts separately on channels followed
 * by a pointwise convolution that mixes channels. Note that this is
 * separability between dimensions [1, 2] and 3, not spatial separability
 * between dimensions 1 and 2.
 *
 * See
 * [https://www.tensorflow.org/api_docs/python/tf/nn/separable_conv2d](
 *     https://www.tensorflow.org/api_docs/python/tf/nn/separable_conv2d)
 * for more details.
 *
 * @param x The input tensor, of rank 4 or rank 3, of shape
 *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is
 * assumed.
 * @param depthwiseFilter The depthwise filter tensor, rank 4, of shape
 *     `[filterHeight, filterWidth, inChannels, channelMultiplier]`. This is
 *     the filter used in the first step.
 * @param pointwiseFilter The pointwise filter tensor, rank 4, of shape
 *     `[1, 1, inChannels * channelMultiplier, outChannels]`. This is
 *     the filter used in the second step.
 * @param strides The strides of the convolution: `[strideHeight,
 * strideWidth]`. If strides is a single number, then `strideHeight ==
 * strideWidth`.
 * @param pad The type of padding algorithm.
 *   - `same` and stride 1: output will be of same size as input,
 *       regardless of filter size.
 *   - `valid`: output will be smaller than input if filter is larger
 *       than 1x1.
 *   - For more info, see this guide:
 *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](
 *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)
 * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`
 *     in which we sample input values across the height and width dimensions
 *     in atrous convolution. Defaults to `[1, 1]`. If `rate` is a single
 *     number, then `dilationHeight == dilationWidth`. If it is greater than
 *     1, then all values of `strides` must be 1.
 * @param dataFormat: An optional string from: "NHWC", "NCHW". Defaults to
 *     "NHWC". Specify the data format of the input and output data. With the
 *     default format "NHWC", the data is stored in the order of: [batch,
 *     height, width, channels]. Only "NHWC" is currently supported.
 *
 * @doc {heading: 'Operations', subheading: 'Convolution'}
 */
function separableConv2d_(x, depthwiseFilter, pointwiseFilter, strides, pad, dilation = [1, 1], dataFormat = 'NHWC') {
    const $x = convertToTensor(x, 'x', 'separableConv2d');
    const $depthwiseFilter = convertToTensor(depthwiseFilter, 'depthwiseFilter', 'separableConv2d');
    const $pointwiseFilter = convertToTensor(pointwiseFilter, 'pointwiseFilter', 'separableConv2d');
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    if (dataFormat === 'NCHW') {
        throw new Error('separableConv2d currently does not support dataFormat NCHW; only ' +
            'NHWC is supported');
    }
    assert(x4D.rank === 4, () => `Error in separableConv2d: input must be rank 4, but got ` +
        `rank ${x4D.rank}.`);
    assert($depthwiseFilter.rank === 4, () => `Error in separableConv2d: depthwise filter must be rank 4, but ` +
        `got rank ${$depthwiseFilter.rank}.`);
    assert($pointwiseFilter.rank === 4, () => `Error in separableConv2d: pointwise filter must be rank 4, but ` +
        `got rank ${$depthwiseFilter.rank}.`);
    assert($pointwiseFilter.shape[0] === 1, () => `Error in separableConv2d: the first dimension of pointwise filter ` +
        ` must be 1, but got ${$pointwiseFilter.shape[0]}.`);
    assert($pointwiseFilter.shape[1] === 1, () => `Error in separableConv2d: the second dimension of pointwise ` +
        `filter must be 1, but got ${$pointwiseFilter.shape[1]}.`);
    const inChannels = $depthwiseFilter.shape[2];
    const channelMultiplier = $depthwiseFilter.shape[3];
    assert($pointwiseFilter.shape[2] === inChannels * channelMultiplier, () => `Error in separableConv2d: the third dimension of pointwise filter ` +
        `must be ${inChannels * channelMultiplier}, ` +
        `but got ${$pointwiseFilter.shape[2]}.`);
    const depthwise = depthwiseConv2d(x4D, $depthwiseFilter, strides, pad, dataFormat, dilation);
    const pointwiseStride = 1;
    const res = conv2d(depthwise, $pointwiseFilter, pointwiseStride, 'valid', dataFormat);
    if (reshapedTo4D) {
        return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
}
op({ separableConv2d_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns an element-wise indication of the sign of a number.
 *
 * ```js
 * const x = tf.tensor1d([.6, 1.1, -3.3, NaN, 0]);
 *
 * x.sign().print();  // or tf.sign(x)
 * ```
 * @param x The input Tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function sign_(x) {
    const $x = convertToTensor(x, 'x', 'sign');
    const inputs = { x: $x };
    return ENGINE.runKernel(Sign, inputs);
}
op({ sign_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes sin of the input Tensor element-wise: `sin(x)`
 *
 * ```js
 * const x = tf.tensor1d([0, Math.PI / 2, Math.PI * 3 / 4]);
 *
 * x.sin().print();  // or tf.sin(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function sin_(x) {
    const $x = convertToTensor(x, 'x', 'sin', 'float32');
    const inputs = { x: $x };
    return ENGINE.runKernel(Sin, inputs);
}
op({ sin_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes hyperbolic sin of the input `tf.Tensor` element-wise: `sinh(x)`
 *
 * ```js
 * const x = tf.tensor1d([0, 1, -1, .7]);
 *
 * x.sinh().print();  // or tf.sinh(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function sinh_(x) {
    const $x = convertToTensor(x, 'x', 'sinh');
    const inputs = { x: $x };
    return ENGINE.runKernel(Sinh, inputs);
}
op({ sinh_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Extracts a 1D slice from 1D array starting at coordinates `begin` and is
 * of length `size`. See `slice` for details.
 */
function slice1d_(x, begin, size) {
    const $x = convertToTensor(x, 'x', 'slice1d');
    assert($x.rank === 1, () => `slice1d expects a rank-1 tensor, but got a rank-${$x.rank} tensor`);
    return slice($x, [begin], [size]);
}
op({ slice1d_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Extracts a 2D slice from a 2D array starting at coordinates `begin` and
 * is of size `size`. See `slice` for details.
 */
function slice2d_(x, begin, size) {
    const $x = convertToTensor(x, 'x', 'slice2d');
    assert($x.rank === 2, () => `slice2d expects a rank-2 tensor, but got a rank-${$x.rank} tensor`);
    return slice($x, begin, size);
}
op({ slice2d_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Extracts a 3D slice from a 3D array starting at coordinates `begin` and
 * is of size `size`. See `slice` for details.
 */
function slice3d_(x, begin, size) {
    const $x = convertToTensor(x, 'x', 'slice3d');
    assert($x.rank === 3, () => `slice3d expects a rank-3 tensor, but got a rank-${$x.rank} tensor`);
    return slice($x, begin, size);
}
op({ slice3d_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Extracts a 4D slice from a 4D array starting at coordinates `begin` and
 * is of size `size`. See `slice` for details.
 */
function slice4d_(x, begin, size) {
    const $x = convertToTensor(x, 'x', 'slice4d');
    assert($x.rank === 4, () => `slice4d expects a rank-4 tensor, but got a rank-${$x.rank} tensor`);
    return slice($x, begin, size);
}
op({ slice4d_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the softmax normalized vector given the logits.
 *
 * ```js
 * const a = tf.tensor1d([1, 2, 3]);
 *
 * a.softmax().print();  // or tf.softmax(a)
 * ```
 *
 * ```js
 * const a = tf.tensor2d([2, 4, 6, 1, 2, 3], [2, 3]);
 *
 * a.softmax().print();  // or tf.softmax(a)
 * ```
 *
 * @param logits The logits array.
 * @param dim The dimension softmax would be performed on. Defaults to `-1`
 *     which indicates the last dimension.
 *
 * @doc {heading: 'Operations', subheading: 'Normalization'}
 */
function softmax_(logits, dim = -1) {
    const $logits = convertToTensor(logits, 'logits', 'softmax', 'float32');
    if (dim === -1) {
        dim = $logits.rank - 1;
    }
    if (dim !== $logits.rank - 1) {
        throw Error('Softmax along a non-last dimension is not yet supported. ' +
            `Logits was rank ${$logits.rank} and dim was ${dim}`);
    }
    const inputs = { logits: $logits };
    const attrs = { dim };
    return ENGINE.runKernel(Softmax, inputs, attrs);
}
op({ softmax_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Fast Fourier transform.
 *
 * Computes the 1-dimensional discrete Fourier transform over the inner-most
 * dimension of input.
 *
 * ```js
 * const real = tf.tensor1d([1, 2, 3]);
 * const imag = tf.tensor1d([1, 2, 3]);
 * const x = tf.complex(real, imag);
 *
 * x.fft().print();  // tf.spectral.fft(x).print();
 * ```
 * @param input The complex input to compute an fft over.
 *
 * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}
 */
function fft_(input) {
    assert(input.dtype === 'complex64', () => `The dtype for tf.spectral.fft() must be complex64 ` +
        `but got ${input.dtype}.`);
    const inputs = { input };
    return ENGINE.runKernel(FFT, inputs);
}
const fft = op({ fft_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Inverse fast Fourier transform.
 *
 * Computes the inverse 1-dimensional discrete Fourier transform over the
 * inner-most dimension of input.
 *
 * ```js
 * const real = tf.tensor1d([1, 2, 3]);
 * const imag = tf.tensor1d([1, 2, 3]);
 * const x = tf.complex(real, imag);
 *
 * x.ifft().print();  // tf.spectral.ifft(x).print();
 * ```
 * @param input The complex input to compute an ifft over.
 *
 * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}
 */
function ifft_(input) {
    assert(input.dtype === 'complex64', () => `The dtype for tf.spectral.ifft() must be complex64 ` +
        `but got ${input.dtype}.`);
    const inputs = { input };
    return ENGINE.runKernel(IFFT, inputs);
}
const ifft = op({ ifft_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Inversed real value input fast Fourier transform.
 *
 * Computes the 1-dimensional inversed discrete Fourier transform over the
 * inner-most dimension of the real input.
 *
 * ```js
 * const real = tf.tensor1d([1, 2, 3]);
 * const imag = tf.tensor1d([0, 0, 0]);
 * const x = tf.complex(real, imag);
 *
 * x.irfft().print();
 * ```
 * @param input The real value input to compute an irfft over.
 *
 * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}
 */
function irfft_(input) {
    const innerDimensionSize = input.shape[input.shape.length - 1];
    const batch = input.size / innerDimensionSize;
    let ret;
    if (innerDimensionSize <= 2) {
        const complexInput = reshape(input, [batch, innerDimensionSize]);
        ret = ifft(complexInput);
    }
    else {
        // The length of unique components of the DFT of a real-valued signal
        // is 2 * (input_len - 1)
        const outputShape = [batch, 2 * (innerDimensionSize - 1)];
        const realInput = reshape(real(input), [batch, innerDimensionSize]);
        const imagInput = reshape(imag(input), [batch, innerDimensionSize]);
        const realConjugate = reverse(slice(realInput, [0, 1], [batch, innerDimensionSize - 2]), 1);
        const imagConjugate = mul(reverse(slice(imagInput, [0, 1], [batch, innerDimensionSize - 2]), 1), scalar(-1));
        const r = concat([realInput, realConjugate], 1);
        const i = concat([imagInput, imagConjugate], 1);
        const complexInput = reshape(complex(r, i), [outputShape[0], outputShape[1]]);
        ret = ifft(complexInput);
    }
    ret = real(ret);
    // reshape the result if the input is 3D tensor.
    if (input.rank === 3 && input.shape[0] !== 0) {
        const temp = ret;
        const batch = input.shape[0];
        ret = reshape(ret, [batch, ret.shape[0] / batch, ret.shape[1]]);
        temp.dispose();
    }
    return ret;
}
op({ irfft_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Splits a `tf.Tensor` into sub tensors.
 *
 * If `numOrSizeSplits` is a number, splits `x` along dimension `axis`
 * into `numOrSizeSplits` smaller tensors.
 * Requires that `numOrSizeSplits` evenly divides `x.shape[axis]`.
 *
 * If `numOrSizeSplits` is a number array, splits `x` into
 * `numOrSizeSplits.length` pieces. The shape of the `i`-th piece has the
 * same size as `x` except along dimension `axis` where the size is
 * `numOrSizeSplits[i]`.
 *
 * ```js
 * const x = tf.tensor2d([1, 2, 3, 4, 5, 6, 7, 8], [2, 4]);
 * const [a, b] = tf.split(x, 2, 1);
 * a.print();
 * b.print();
 *
 * const [c, d, e] = tf.split(x, [1, 2, 1], 1);
 * c.print();
 * d.print();
 * e.print();
 * ```
 *
 * @param x The input tensor to split.
 * @param numOrSizeSplits Either an integer indicating the number of
 * splits along the axis or an array of integers containing the sizes of
 * each output tensor along the axis. If a number then it must evenly divide
 * `x.shape[axis]`; otherwise the sum of sizes must match `x.shape[axis]`.
 * Can contain one -1 indicating that dimension is to be inferred.
 * @param axis The dimension along which to split. Defaults to 0 (the first
 * dim).
 *
 * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}
 */
function split_(x, numOrSizeSplits, axis = 0) {
    const $x = convertToTensor(x, 'x', 'split');
    const inputs = { x: $x };
    const attr = { numOrSizeSplits, axis };
    return ENGINE.runKernel(SplitV, inputs, attr);
}
const split = op({ split_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Real value input fast Fourier transform.
 *
 * Computes the 1-dimensional discrete Fourier transform over the
 * inner-most dimension of the real input.
 *
 * ```js
 * const real = tf.tensor1d([1, 2, 3]);
 *
 * real.rfft().print();
 * ```
 * @param input The real value input to compute an rfft over.
 *
 * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}
 */
function rfft_(input, fftLength) {
    assert(input.dtype === 'float32', () => `The dtype for rfft() must be real value but got ${input.dtype}`);
    let innerDimensionSize = input.shape[input.shape.length - 1];
    const batch = input.size / innerDimensionSize;
    let adjustedInput;
    if (fftLength != null && fftLength < innerDimensionSize) {
        // Need to crop
        const begin = input.shape.map(v => 0);
        const size = input.shape.map(v => v);
        size[input.shape.length - 1] = fftLength;
        adjustedInput = slice(input, begin, size);
        innerDimensionSize = fftLength;
    }
    else if (fftLength != null && fftLength > innerDimensionSize) {
        // Need to pad with zeros
        const zerosShape = input.shape.map(v => v);
        zerosShape[input.shape.length - 1] = fftLength - innerDimensionSize;
        adjustedInput = concat([input, zeros(zerosShape)], input.shape.length - 1);
        innerDimensionSize = fftLength;
    }
    else {
        adjustedInput = input;
    }
    // Complement the input with zero imaginary numbers.
    const zerosInput = zerosLike(adjustedInput);
    const complexInput = reshape(complex(adjustedInput, zerosInput), [batch, innerDimensionSize]);
    const ret = fft(complexInput);
    // Exclude complex conjugations. These conjugations are put symmetrically.
    const half = Math.floor(innerDimensionSize / 2) + 1;
    const realValues = real(ret);
    const imagValues = imag(ret);
    const realComplexConjugate = split(realValues, [half, innerDimensionSize - half], realValues.shape.length - 1);
    const imagComplexConjugate = split(imagValues, [half, innerDimensionSize - half], imagValues.shape.length - 1);
    const outputShape = adjustedInput.shape.slice();
    outputShape[adjustedInput.shape.length - 1] = half;
    return reshape(complex(realComplexConjugate[0], imagComplexConjugate[0]), outputShape);
}
const rfft = op({ rfft_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Returns (a - b) * (a - b) element-wise.
 * Supports broadcasting.
 *
 * ```js
 * const a = tf.tensor1d([1, 4, 3, 16]);
 * const b = tf.tensor1d([1, 2, 9, 4]);
 *
 * a.squaredDifference(b).print();  // or tf.squaredDifference(a, b)
 * ```
 *
 * ```js
 * // Broadcast squared difference  a with b.
 * const a = tf.tensor1d([2, 4, 6, 8]);
 * const b = tf.scalar(5);
 *
 * a.squaredDifference(b).print();  // or tf.squaredDifference(a, b)
 * ```
 *
 * @param a The first tensor.
 * @param b The second tensor. Must have the same type as `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Arithmetic'}
 */
function squaredDifference_(a, b) {
    let $a = convertToTensor(a, 'a', 'squaredDifference');
    let $b = convertToTensor(b, 'b', 'squaredDifference');
    [$a, $b] = makeTypesMatch($a, $b);
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    const attrs = {};
    return ENGINE.runKernel(SquaredDifference, inputs, attrs);
}
const squaredDifference = op({ squaredDifference_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Stacks a list of rank-`R` `tf.Tensor`s into one rank-`(R+1)` `tf.Tensor`.
 *
 * ```js
 * const a = tf.tensor1d([1, 2]);
 * const b = tf.tensor1d([3, 4]);
 * const c = tf.tensor1d([5, 6]);
 * tf.stack([a, b, c]).print();
 * ```
 *
 * @param tensors A list of tensor objects with the same shape and dtype.
 * @param axis The axis to stack along. Defaults to 0 (the first dim).
 *
 * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}
 */
function stack_(tensors, axis = 0) {
    const $tensors = convertToTensorArray(tensors, 'tensors', 'stack', 'string_or_numeric');
    assert($tensors.length >= 1, () => 'Pass at least one tensor to tf.stack');
    if ($tensors.length > 0) {
        assert(axis <= $tensors[0].rank, () => 'Axis must be <= rank of the tensor');
    }
    const inputs = $tensors;
    const attrs = { axis };
    return ENGINE.runKernel(Pack, inputs, attrs);
}
const stack = op({ stack_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes step of the input `tf.Tensor` element-wise: `x > 0 ? 1 : alpha * x`
 *
 * ```js
 * const x = tf.tensor1d([0, 2, -1, -3]);
 *
 * x.step(.5).print();  // or tf.step(x, .5)
 * ```
 * @param x The input tensor.
 * @param alpha The gradient when input is negative.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function step_(x, alpha = 0.0) {
    const $x = convertToTensor(x, 'x', 'step');
    const inputs = { x: $x };
    const attrs = { alpha };
    return ENGINE.runKernel(Step, inputs, attrs);
}
const step = op({ step_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Extracts a strided slice of a tensor.
 *
 * Roughly speaking, this op extracts a slice of size (end-begin)/stride from
 * the given input tensor (x). Starting at the location specified by begin the
 * slice continues by adding stride to the index until all dimensions are not
 * less than end. Note that a stride can be negative, which causes a reverse
 * slice.
 *
 * ```js
 * const t = tf.tensor3d([1, 1, 1 ,2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6],
 *    [3, 2, 3]);
 * t.stridedSlice([1, 0, 0], [2, 1, 3], [1, 1, 1]).print()  // [[[3, 3, 3]]]
 * t.stridedSlice([1, 0, 0], [2, 2, 3], [1, 1, 1]).print()  // [[[3, 3, 3],
 *                                                     // [4, 4, 4]]]
 * t.stridedSlice([1, -1, 0], [2, -3, 3], [1, -1, 1]).print() // [[[4, 4, 4],
 *                                                     // [3, 3, 3]]]
 * ```
 *
 * @param x The tensor to stride slice.
 * @param begin The coordinates to start the slice from.
 * @param end: The coordinates to end the slice at.
 * @param strides: The size of the slice.
 * @param beginMask: If the ith bit of beginMask is set, begin[i] is ignored
 *      and the fullest possible range in that dimension is used instead.
 * @param endMask: If the ith bit of endMask is set, end[i] is ignored
 *      and the fullest possible range in that dimension is used instead.
 * @param shrinkAxisMask: a bitmask where bit i implies that
 * the ith specification should shrink the dimensionality. begin and end must
 * imply a slice of size 1 in the dimension.
 *
 * @doc {heading: 'Operations', subheading: 'Slicing and Joining'}
 */
function stridedSlice_(x, begin, end, strides, beginMask = 0, endMask = 0, ellipsisMask = 0, newAxisMask = 0, shrinkAxisMask = 0) {
    const $x = convertToTensor(x, 'x', 'stridedSlice', 'string_or_numeric');
    const inputs = { x: $x };
    const attrs = {
        begin,
        end,
        strides,
        beginMask,
        endMask,
        ellipsisMask,
        newAxisMask,
        shrinkAxisMask
    };
    return ENGINE.runKernel(StridedSlice, inputs, attrs);
}
op({ stridedSlice_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes tan of the input `tf.Tensor` element-wise, `tan(x)`
 *
 * ```js
 * const x = tf.tensor1d([0, Math.PI / 2, Math.PI * 3 / 4]);
 *
 * x.tan().print();  // or tf.tan(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */
function tan_(x) {
    const $x = convertToTensor(x, 'x', 'tan', 'float32');
    const inputs = { x: $x };
    return ENGINE.runKernel(Tan, inputs);
}
op({ tan_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Creates a `tf.Tensor` with the provided values, shape and dtype.
 *
 * ```js
 * // Pass an array of values to create a vector.
 * tf.tensor([1, 2, 3, 4]).print();
 * ```
 *
 * ```js
 * // Pass a nested array of values to make a matrix or a higher
 * // dimensional tensor.
 * tf.tensor([[1, 2], [3, 4]]).print();
 * ```
 *
 * ```js
 * // Pass a flat array and specify a shape yourself.
 * tf.tensor([1, 2, 3, 4], [2, 2]).print();
 * ```
 *
 * @param values The values of the tensor. Can be nested array of numbers,
 *     or a flat array, or a `TypedArray`. If the values are strings,
 *     they will be encoded as utf-8 and kept as `Uint8Array[]`.
 * @param shape The shape of the tensor. Optional. If not provided,
 *   it is inferred from `values`.
 * @param dtype The data type.
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */
function tensor(values, shape, dtype) {
    const inferredShape = inferShape(values, dtype);
    return makeTensor(values, shape, inferredShape, dtype);
}

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Creates rank-1 `tf.Tensor` with the provided values, shape and dtype.
 *
 * The same functionality can be achieved with `tf.tensor`, but in general
 * we recommend using `tf.tensor1d` as it makes the code more readable.
 *
 * ```js
 * tf.tensor1d([1, 2, 3]).print();
 * ```
 *
 * @param values The values of the tensor. Can be array of numbers,
 *     or a `TypedArray`.
 * @param dtype The data type.
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */
function tensor1d(values, dtype) {
    assertNonNull(values);
    const inferredShape = inferShape(values, dtype);
    if (inferredShape.length !== 1) {
        throw new Error('tensor1d() requires values to be a flat/TypedArray');
    }
    const shape = null;
    return makeTensor(values, shape, inferredShape, dtype);
}

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Creates rank-2 `tf.Tensor` with the provided values, shape and dtype.
 *
 * The same functionality can be achieved with `tf.tensor`, but in general
 * we recommend using `tf.tensor2d` as it makes the code more readable.
 *
 *  ```js
 * // Pass a nested array.
 * tf.tensor2d([[1, 2], [3, 4]]).print();
 * ```
 * ```js
 * // Pass a flat array and specify a shape.
 * tf.tensor2d([1, 2, 3, 4], [2, 2]).print();
 * ```
 *
 * @param values The values of the tensor. Can be nested array of numbers,
 *     or a flat array, or a `TypedArray`.
 * @param shape The shape of the tensor. If not provided, it is inferred from
 *     `values`.
 * @param dtype The data type.
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */
function tensor2d(values, shape, dtype) {
    assertNonNull(values);
    if (shape != null && shape.length !== 2) {
        throw new Error('tensor2d() requires shape to have two numbers');
    }
    const inferredShape = inferShape(values, dtype);
    if (inferredShape.length !== 2 && inferredShape.length !== 1) {
        throw new Error('tensor2d() requires values to be number[][] or flat/TypedArray');
    }
    if (inferredShape.length === 1 && shape == null) {
        throw new Error('tensor2d() requires shape to be provided when `values` ' +
            'are a flat/TypedArray');
    }
    return makeTensor(values, shape, inferredShape, dtype);
}

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Finds the values and indices of the `k` largest entries along the last
 * dimension.
 *
 * If the input is a vector (rank=1), finds the k largest entries in the vector
 * and outputs their values and indices as vectors. Thus values[j] is the j-th
 * largest entry in input, and its index is indices[j].
 * For higher rank inputs, computes the top k entries along the last dimension.
 *
 * If two elements are equal, the lower-index element appears first.
 *
 * ```js
 * const a = tf.tensor2d([[1, 5], [4, 3]]);
 * const {values, indices} = tf.topk(a);
 * values.print();
 * indices.print();
 * ```
 * @param x 1-D or higher `tf.Tensor` with last dimension being at least `k`.
 * @param k Number of top elements to look for along the last dimension.
 * @param sorted If true, the resulting `k` elements will be sorted by the
 *     values in descending order.
 *
 * @doc {heading: 'Operations', subheading: 'Evaluation'}
 */
function topk_(x, k = 1, sorted = true) {
    const $x = convertToTensor(x, 'x', 'topk');
    if ($x.rank === 0) {
        throw new Error('topk() expects the input to be of rank 1 or higher');
    }
    const lastDim = $x.shape[$x.shape.length - 1];
    if (k < 0) {
        throw new Error(`'k' passed to topk() must be >= 0 but got ${k}`);
    }
    if (k > lastDim) {
        throw new Error(`'k' passed to topk() must be <= the last dimension (${lastDim}) ` +
            `but got ${k}`);
    }
    const inputs = { x: $x };
    const attrs = { k, sorted };
    const [values, indices] = ENGINE.runKernel(TopK, inputs, attrs);
    return { values, indices };
}
op({ topk_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Creates a `tf.Tensor` with values sampled from a truncated normal
 * distribution.
 *
 * ```js
 * tf.truncatedNormal([2, 2]).print();
 * ```
 *
 * The generated values follow a normal distribution with specified mean and
 * standard deviation, except that values whose magnitude is more than 2
 * standard deviations from the mean are dropped and re-picked.
 *
 * @param shape An array of integers defining the output tensor shape.
 * @param mean The mean of the normal distribution.
 * @param stdDev The standard deviation of the normal distribution.
 * @param dtype The data type of the output tensor.
 * @param seed The seed for the random number generator.
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */
function truncatedNormal_(shape, mean = 0, stdDev = 1, dtype, seed) {
    if (dtype != null && dtype === 'bool') {
        throw new Error(`Unsupported data type $ { dtype }`);
    }
    const randGauss = new MPRandGauss(mean, stdDev, dtype, true /* truncated */, seed);
    const res = buffer(shape, dtype);
    for (let i = 0; i < res.values.length; i++) {
        res.values[i] = randGauss.nextValue();
    }
    return res.toTensor();
}
op({ truncatedNormal_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Finds unique elements along an axis of a tensor.
 *
 * It returns a tensor `values` containing all of the unique elements along the
 * `axis` of the given tensor `x` in the same order that they occur along the
 * `axis` in `x`; `x` does not need to be sorted. It also returns a tensor
 * `indices` the same size as the number of the elements in `x` along the `axis`
 * dimension. It contains the index in the unique output `values`.
 *
 * ```js
 * // A 1-D tensor
 * const a = tf.tensor1d([1, 1, 2, 4, 4, 4, 7, 8, 8]);
 * const {values, indices} = tf.unique(a);
 * values.print();   // [1, 2, 4, 7, 8,]
 * indices.print();  // [0, 0, 1, 2, 2, 2, 3, 4, 4]
 * ```
 *
 * ```js
 * // A 2-D tensor with axis=0
 * //
 * // 'a' is: [[1, 0, 0],
 * //          [1, 0, 0],
 * //          [2, 0, 0]]
 * const a = tf.tensor2d([[1, 0, 0], [1, 0, 0], [2, 0, 0]]);
 * const {values, indices} = tf.unique(a, 0)
 * values.print();   // [[1, 0, 0],
 *                   //  [2, 0, 0]]
 * indices.print();  // [0, 0, 1]
 * ```
 *
 * ```js
 * // A 2-D tensor with axis=1
 * //
 * // 'a' is: [[1, 0, 0],
 * //          [1, 0, 0],
 * //          [2, 0, 0]]
 * const a = tf.tensor2d([[1, 0, 0], [1, 0, 0], [2, 0, 0]]);
 * const {values, indices} = tf.unique(a, 1)
 * values.print();   // [[1, 0],
 *                   //  [1, 0],
 *                   //  [2, 0]]
 * indices.print();  // [0, 1, 1]
 * ```
 * @param x A tensor (int32, string, bool).
 * @param axis The axis of the tensor to find the unique elements.
 * @returns [uniqueElements, indices] (see above for details)
 *
 * @doc {heading: 'Operations', subheading: 'Evaluation'}
 */
function unique_(x, axis = 0) {
    const $x = convertToTensor(x, 'x', 'unique', 'string_or_numeric');
    assert($x.rank > 0, () => 'The input tensor must be at least 1D');
    const inputs = { x: $x };
    const attrs = { axis };
    const [values, indices] = ENGINE.runKernel(Unique, inputs, attrs);
    return { values, indices };
}
op({ unique_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the sum along segments of a `tf.Tensor`.
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3, 4]);
 * const segmentIds = tf.tensor1d([1, 2, 0, 1], 'int32');
 * const numSegments = 3;
 *
 * x.unsortedSegmentSum(segmentIds, numSegments).print()
 * //or tf.unsortedSegmentSum(x, segmentIds, numSegments)
 * ```
 * @param x The `tf.Tensor` that will be summed along its segments.
 * @param segmentIds A `tf.Tensor1D` whose rank is equal to the rank of `x`'s
 * dimension along the `axis`.  Maps each element of `x` to a segment.
 * @param numSegments The number of distinct `segmentIds`.
 *
 * @doc {heading: 'Operations', subheading: 'Segment'}
 */
function unsortedSegmentSum_(x, segmentIds, numSegments) {
    const $x = convertToTensor(x, 'x', 'unsortedSegmentSum');
    const $segmentIds = convertToTensor(segmentIds, 'segmentIds', 'unsortedSegmentSum', 'int32');
    assert(isInt(numSegments), () => 'numSegments must be of dtype int');
    const inputs = { x: $x, segmentIds: $segmentIds };
    const attrs = { numSegments };
    return ENGINE.runKernel(UnsortedSegmentSum, inputs, attrs);
}
op({ unsortedSegmentSum_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Unstacks a `tf.Tensor` of rank-`R` into a list of rank-`(R-1)` `tf.Tensor`s.
 *
 * ```js
 * const a = tf.tensor2d([1, 2, 3, 4], [2, 2]);
 *
 * tf.unstack(a).forEach(tensor => tensor.print());
 * ```
 *
 * @param x A tensor object.
 * @param axis The axis to unstack along. Defaults to 0 (the first dim).
 *
 * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}
 */
function unstack_(x, axis = 0) {
    const $x = convertToTensor(x, 'x', 'unstack', 'string_or_numeric');
    assert(axis >= -$x.shape.length && axis < $x.shape.length, () => `Axis = ${axis} is not in [-${$x.shape.length}, ${$x.shape.length})`);
    const inputs = { value: $x };
    const attrs = { axis };
    return ENGINE.runKernel(Unpack, inputs, attrs);
}
const unstack = op({ unstack_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Executes the provided function `fn` and after it is executed, cleans up all
 * intermediate tensors allocated by `fn` except those returned by `fn`.
 * `fn` must not return a Promise (async functions not allowed). The returned
 * result can be a complex object.
 *
 * Using this method helps avoid memory leaks. In general, wrap calls to
 * operations in `tf.tidy` for automatic memory cleanup.
 *
 * NOTE: Variables do *not* get cleaned up when inside a tidy(). If you want to
 * dispose variables, please use `tf.disposeVariables` or call dispose()
 * directly on variables.
 *
 * ```js
 * // y = 2 ^ 2 + 1
 * const y = tf.tidy(() => {
 *   // a, b, and one will be cleaned up when the tidy ends.
 *   const one = tf.scalar(1);
 *   const a = tf.scalar(2);
 *   const b = a.square();
 *
 *   console.log('numTensors (in tidy): ' + tf.memory().numTensors);
 *
 *   // The value returned inside the tidy function will return
 *   // through the tidy, in this case to the variable y.
 *   return b.add(one);
 * });
 *
 * console.log('numTensors (outside tidy): ' + tf.memory().numTensors);
 * y.print();
 * ```
 *
 * @param nameOrFn The name of the closure, or the function to execute.
 *     If a name is provided, the 2nd argument should be the function.
 *     If debug mode is on, the timing and the memory usage of the function
 *     will be tracked and displayed on the console using the provided name.
 * @param fn The function to execute.
 *
 * @doc {heading: 'Performance', subheading: 'Memory'}
 */
function tidy(nameOrFn, fn) {
    return ENGINE.tidy(nameOrFn, fn);
}
/**
 * Disposes any `tf.Tensor`s found within the provided object.
 *
 * @param container an object that may be a `tf.Tensor` or may directly
 *     contain `tf.Tensor`s, such as a `Tensor[]` or `{key: Tensor, ...}`. If
 *     the object is not a `tf.Tensor` or does not contain `Tensors`, nothing
 *     happens. In general it is safe to pass any object here, except that
 *     `Promise`s are not supported.
 *
 * @doc {heading: 'Performance', subheading: 'Memory'}
 */
function dispose(container) {
    const tensors = getTensorsInContainer(container);
    tensors.forEach(tensor => tensor.dispose());
}

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Transposes the `tf.Tensor`. Permutes the dimensions according to `perm`.
 *
 * The returned `tf.Tensor`'s dimension `i` will correspond to the input
 * dimension `perm[i]`. If `perm` is not given, it is set to `[n-1...0]`,
 * where `n` is the rank of the input `tf.Tensor`. Hence by default, this
 * operation performs a regular matrix transpose on 2-D input `tf.Tensor`s.
 *
 * ```js
 * const a = tf.tensor2d([1, 2, 3, 4, 5, 6], [2, 3]);
 *
 * a.transpose().print();  // or tf.transpose(a)
 * ```
 *
 * @param x The tensor to transpose.
 * @param perm The permutation of the dimensions of a.
 * @param conjugate Will conjugate complex input if true.
 *
 * @doc {heading: 'Operations', subheading: 'Matrices'}
 */
function transpose_(x, perm, conjugate) {
    const $x = convertToTensor(x, 'x', 'transpose');
    if (perm == null) {
        perm = $x.shape.map((s, i) => i).reverse();
    }
    assert($x.rank === perm.length, () => `Error in transpose: rank of input ${$x.rank} ` +
        `must match length of perm ${perm}.`);
    perm.forEach(axis => {
        assert(axis >= 0 && axis < $x.rank, () => `All entries in 'perm' must be between 0 and ${$x.rank - 1}` +
            ` but got ${perm}`);
    });
    if ($x.rank <= 1) {
        return $x.clone();
    }
    const inputs = { x: $x };
    const attrs = { perm };
    if ($x.dtype === 'complex64') {
        return tidy(() => {
            let $real = real($x);
            let $imag = imag($x);
            $real = ENGINE.runKernel(Transpose, { x: $real }, attrs);
            $imag = ENGINE.runKernel(Transpose, { x: $imag }, attrs);
            if (conjugate) {
                $imag = neg($imag);
            }
            return complex($real, $imag);
        });
    }
    return ENGINE.runKernel(Transpose, inputs, attrs);
}
const transpose = op({ transpose_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Compute the moving average of a variable.
 *
 * Without zeroDebias, the moving average operation is defined by:
 *   `v += delta`
 * where
 *   `delta = (1 - decay) * (x - v)`
 *
 * With zeroDebias (default), the `delta` term is scaled to debias the
 * effect of the (assumed) zero-initialization of `v`.
 *   `delta /= (1 - decay ^ step)`
 *
 * For more details on the zero-debiasing algorithm, see:
 *   https://arxiv.org/abs/1412.6980
 *
 * Note that this function is completely stateless and does not keep track of
 * step count. The step count needs to be maintained by the caller and passed
 * in as `step`.
 *
 * @param v The current moving average value.
 * @param x New input value, must have the same shape and dtype as `v`.
 * @param decay The decay factor. Typical values are 0.95 and 0.99.
 * @param step Step count.
 * @param zeroDebias: Whether zeroDebias is to be performed (default: `true`).
 * @returns The new moving average value.
 *
 * @doc {heading: 'Operations', subheading: 'Moving Average'}
 */
function movingAverage_(v, x, decay, step, zeroDebias = true) {
    const $v = convertToTensor(v, 'v', 'movingAverage');
    const $x = convertToTensor(x, 'x', 'movingAverage');
    const $decay = convertToTensor(decay, 'decay', 'movingAverage');
    assertTypesMatch($v, $x);
    assert(arraysEqual($v.shape, $x.shape), () => 'Shape mismatch in v and x');
    const one = scalar(1);
    const oneMinusDecay = sub(one, $decay);
    let update = mul(sub($x, $v), oneMinusDecay);
    if (zeroDebias) {
        assert(step != null, () => 'When using zeroDebias: true, step is required.');
        const $step = convertToTensor(step, 'step', 'movingAverage');
        update = div(update, sub(one, pow($decay, $step)));
    }
    return add($v, update);
}
op({ movingAverage_ });

/**
 * Check whether updates.shape = indices.shape[:batchDim] +
 * shape[sliceDim:]
 *
 * @param x The input tensor.
 */
function validateUpdateShape(shape, indices, updates) {
    const sliceDim = (indices.rank > 1) ? indices.shape[indices.rank - 1] : 1;
    const batchDim = (indices.rank > 1) ? indices.rank - 1 : 1;
    const shapeError = 'Must have updates.shape = indices.shape[:batchDim] + ' +
        `shape[sliceDim:], got updates.shape: ${updates.shape}` +
        `, indices.shape: ${indices.shape}, shape: ${shape}` +
        `, sliceDim: ${sliceDim}, and batchDim: ${batchDim}.`;
    if (updates.rank < batchDim) {
        throw new Error(shapeError + ` update.rank < ${batchDim}. `);
    }
    if (shape.length < sliceDim + (updates.rank - batchDim)) {
        throw new Error(shapeError +
            ` Output shape length < ${sliceDim + (updates.rank - batchDim)}`);
    }
    if (updates.rank !== batchDim + shape.length - sliceDim) {
        throw new Error(shapeError + ` update.rank != ${batchDim + shape.length - sliceDim}`);
    }
    for (let d = 0; d < batchDim; ++d) {
        if (updates.shape[d] !== indices.shape[d]) {
            throw new Error(shapeError +
                ` updates.shape[${d}] (${updates.shape[d]}) != indices.shape[${d}] (${indices.shape[d]}).`);
        }
    }
    for (let d = 0; d < updates.rank - batchDim; ++d) {
        if (updates.shape[d + batchDim] !== shape[d + sliceDim]) {
            throw new Error(shapeError +
                ` updates.shape[${d + batchDim}] (${updates.shape[d + batchDim]}) != shape[${d + batchDim}] (${shape[d + batchDim]})`);
        }
    }
}
/**
 * Validate scatter nd inputs.
 *
 * @param update The tensor contains the update values.
 * @param indices The tensor contains the indices for the update values.
 * @param shape The shape of the output tensor.
 */
function validateInput$1(updates, indices, shape) {
    if (indices.rank < 1) {
        throw new Error('tf.scatterND() expects the indices to be rank 1 or higher,' +
            ` but the rank was ${indices.rank}.`);
    }
    if (updates.rank < 1) {
        throw new Error('tf.scatterND() expects the updates to be rank 1 or higher,' +
            ` but the rank was ${updates.rank}.`);
    }
    if (indices.dtype !== 'int32') {
        throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${indices.dtype}`);
    }
    if (shape.length < 1) {
        throw new Error(`Output rank must be greater or equal to 1, but got shape: ${shape}`);
    }
    if (shape.length === 0) {
        if (indices.size === 0) {
            throw new Error(`Indices specified for empty output. indices shape: ${indices.shape}`);
        }
        if (updates.size === 0) {
            throw new Error(`Updates specified for empty output. updates shape: ${updates.shape}`);
        }
    }
    validateUpdateShape(shape, indices, updates);
}

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Creates a new tensor by applying sparse updates to individual
 * values or slices within a zero tensor of the given shape tensor according to
 * indices. This operator is the inverse of the `tf.gatherND` operator which
 * extracts values or slices from a given tensor.
 *
 * ```js
 * const indices = tf.tensor2d([4, 3, 1, 7], [4, 1], 'int32');
 * const updates = tf.tensor1d([9, 10, 11, 12]);
 * const shape = [8];
 * tf.scatterND(indices, updates, shape).print() //[0, 11, 0, 10, 9, 0, 0, 12]
 * ```
 *
 * @param indices The tensor contains the indices into the output tensor.
 * @param updates The tensor contains the value for the indices.
 * @param shape: The shape of the output tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Slicing and Joining'}
 */
function scatterND_(indices, updates, shape) {
    const $indices = convertToTensor(indices, 'indices', 'scatterND', 'int32');
    const $updates = convertToTensor(updates, 'updates', 'scatterND');
    validateInput$1($updates, $indices, shape);
    const inputs = { indices: $indices, updates: $updates };
    const attrs = { shape };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    return ENGINE.runKernel(ScatterNd, inputs, attrs);
}
op({ scatterND_ });

/**
 * Validate sparseToDense inputs.
 *
 * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.
 * sparseIndices[i] contains the complete index where sparseValues[i] will be
 * placed.
 * @param sparseValues A 0-D or 1-D Tensor. Values
 * corresponding to each row of sparseIndices, or a scalar value to be used for
 * all sparse indices.
 * @param outputShape number[]. Shape of the dense output tensor.
 * @param validateIndices boolean. indice validation is not supported, error
 * will be thrown if it is set.
 */
function validateInput(sparseIndices, sparseValues, outputShape, defaultValues) {
    if (sparseIndices.dtype !== 'int32') {
        throw new Error('tf.sparseToDense() expects the indices to be int32 type,' +
            ` but the dtype was ${sparseIndices.dtype}.`);
    }
    if (sparseIndices.rank > 2) {
        throw new Error('sparseIndices should be a scalar, vector, or matrix,' +
            ` but got shape ${sparseIndices.shape}.`);
    }
    const numElems = sparseIndices.rank > 0 ? sparseIndices.shape[0] : 1;
    const numDims = sparseIndices.rank > 1 ? sparseIndices.shape[1] : 1;
    if (outputShape.length !== numDims) {
        throw new Error('outputShape has incorrect number of elements:,' +
            ` ${outputShape.length}, should be: ${numDims}.`);
    }
    const numValues = sparseValues.size;
    if (!(sparseValues.rank === 0 ||
        sparseValues.rank === 1 && numValues === numElems)) {
        throw new Error('sparseValues has incorrect shape ' +
            `${sparseValues.shape}, should be [] or [${numElems}]`);
    }
    if (sparseValues.dtype !== defaultValues.dtype) {
        throw new Error('sparseValues.dtype must match defaultValues.dtype');
    }
}

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Converts a sparse representation into a dense tensor.
 *
 * Builds an array dense with shape outputShape such that:
 *
 * // If sparseIndices is scalar
 * dense[i] = (i == sparseIndices ? sparseValues : defaultValue)
 *
 * // If sparseIndices is a vector, then for each i
 * dense[sparseIndices[i]] = sparseValues[i]
 *
 * // If sparseIndices is an n by d matrix, then for each i in [0, n)
 * dense[sparseIndices[i][0], ..., sparseIndices[i][d-1]] = sparseValues[i]
 * All other values in dense are set to defaultValue. If sparseValues is a
 * scalar, all sparse indices are set to this single value.
 *
 * If indices are repeated the final value is summed over all values for those
 * indices.
 *
 * ```js
 * const indices = tf.tensor1d([4, 5, 6, 1, 2, 3], 'int32');
 * const values = tf.tensor1d([10, 11, 12, 13, 14, 15], 'float32');
 * const shape = [8];
 * tf.sparseToDense(indices, values, shape).print();
 * ```
 *
 * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.
 * sparseIndices[i] contains the complete index where sparseValues[i] will be
 * placed.
 * @param sparseValues A 0-D or 1-D Tensor. Values
 * corresponding to each row of sparseIndices, or a scalar value to be used for
 * all sparse indices.
 * @param outputShape Shape of the dense output tensor. The type is inferred.
 * @param defaultValue Scalar. Value to set for indices not specified in
 * sparseIndices. Defaults to zero.
 *
 * @doc {heading: 'Operations', subheading: 'Normalization'}
 */
function sparseToDense_(sparseIndices, sparseValues, outputShape, defaultValue = 0) {
    const $sparseIndices = convertToTensor(sparseIndices, 'sparseIndices', 'sparseToDense', 'int32');
    const $sparseValues = convertToTensor(sparseValues, 'sparseValues', 'sparseToDense', 'string_or_numeric');
    const $defaultValue = convertToTensor(defaultValue, 'defaultValue', 'sparseToDense', $sparseValues.dtype);
    validateInput($sparseIndices, $sparseValues, outputShape, $defaultValue);
    const inputs = {
        sparseIndices: $sparseIndices,
        sparseValues: $sparseValues,
        defaultValue: $defaultValue
    };
    const attrs = { outputShape };
    return ENGINE.runKernel(SparseToDense, inputs, attrs);
}
op({ sparseToDense_ });

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Gather slices from input tensor into a Tensor with shape specified by
 * `indices`.
 *
 * `indices` is a K-dimensional integer tensor, best thought of as a
 * (K-1)-dimensional tensor of indices into input, where each element defines a
 * slice of input:
 * output[\\(i_0, ..., i_{K-2}\\)] = input[indices[\\(i_0, ..., i_{K-2}\\)]]
 *
 * Whereas in `tf.gather`, `indices` defines slices into the first dimension of
 * input, in `tf.gatherND`, `indices` defines slices into the first N dimensions
 * of input, where N = indices.shape[-1].
 *
 * The last dimension of indices can be at most the rank of input:
 * indices.shape[-1] <= input.rank
 *
 * The last dimension of `indices` corresponds to elements
 * (if indices.shape[-1] == input.rank) or slices
 * (if indices.shape[-1] < input.rank) along dimension indices.shape[-1] of
 * input.
 * The output tensor has shape
 * indices.shape[:-1] + input.shape[indices.shape[-1]:]
 *
 * Note that on CPU, if an out of bound index is found, an error is returned. On
 * GPU, if an out of bound index is found, a 0 is stored in the corresponding
 * output value.
 *
 * ```js
 * const indices = tf.tensor2d([0, 1, 1, 0], [2,2], 'int32');
 * const input = tf.tensor2d([9, 10, 11, 12], [2, 2]);
 * tf.gatherND(input, indices).print() // [10, 11]
 * ```
 *
 * @param x The tensor from which to gather values.
 * @param indices Index tensor, must be of type int32.
 *
 * @doc {heading: 'Operations', subheading: 'Slicing and Joining'}
 */
function gatherND_(x, indices) {
    const $indices = convertToTensor(indices, 'indices', 'gatherND', 'int32');
    const $x = convertToTensor(x, 'x', 'gatherND', 'string_or_numeric');
    const inputs = { params: $x, indices: $indices };
    return ENGINE.runKernel(GatherNd, inputs);
}
op({ gatherND_ });

/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Normalize noise shape based on provided tensor and noise shape.
 *
 * @param x Tensor.
 * @param noiseShape The shape for the randomly generated keep/drop flags, as
 *   an array of numbers. Optional.
 * @returns Normalized noise shape.
 */
function getNoiseShape(x, noiseShape) {
    if (noiseShape == null) {
        return x.shape.slice();
    }
    if (arraysEqual(x.shape, noiseShape)) {
        return noiseShape;
    }
    if (x.shape.length === noiseShape.length) {
        const newDimension = [];
        for (let i = 0; i < x.shape.length; i++) {
            if (noiseShape[i] == null && x.shape[i] != null) {
                newDimension.push(x.shape[i]);
            }
            else {
                newDimension.push(noiseShape[i]);
            }
        }
        return newDimension;
    }
    return noiseShape;
}

/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes dropout.
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 2, 1]);
 * const rate = 0.75;
 * const output = tf.dropout(x, rate);
 * output.print();
 * ```
 *
 * @param x A floating point Tensor or TensorLike.
 * @param rate A float in the range [0, 1). The probability that each element
 *   of x is discarded.
 * @param noiseShape An array of numbers of type int32, representing the
 * shape for randomly generated keep/drop flags. If the noiseShape has null
 * value, it will be automatically replaced with the x's relative dimension
 * size. Optional.
 * @param seed Used to create random seeds. Optional.
 * @returns A Tensor of the same shape of x.
 *
 * @doc {heading: 'Operations', subheading: 'Dropout'}
 */
function dropout_(x, rate, noiseShape, seed) {
    const $x = convertToTensor(x, 'x', 'dropout');
    assert($x.dtype === 'float32', () => `x has to be a floating point tensor since it's going to be ` +
        `scaled, but got a ${$x.dtype} tensor instead.`);
    assert(rate >= 0 && rate < 1, () => `rate must be a float in the range [0, 1), but got ${rate}.`);
    if (rate === 0) {
        return x instanceof Tensor ? $x.clone() : $x;
    }
    const $noiseShape = getNoiseShape($x, noiseShape);
    const keepProb = 1 - rate;
    const multiplier = div(floor(add(randomUniform($noiseShape, 0, 1, 'float32', seed), keepProb)), keepProb);
    return mul($x, multiplier);
}
op({ dropout_ });

/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function enclosingPowerOfTwo(value) {
    // Return 2**N for integer N such that 2**N >= value.
    return Math.floor(Math.pow(2, Math.ceil(Math.log(value) / Math.log(2.0))));
}
function cosineWindow(windowLength, a, b) {
    const even = 1 - windowLength % 2;
    const newValues = new Float32Array(windowLength);
    for (let i = 0; i < windowLength; ++i) {
        const cosArg = (2.0 * Math.PI * i) / (windowLength + even - 1);
        newValues[i] = a - b * Math.cos(cosArg);
    }
    return tensor1d(newValues, 'float32');
}

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the derivative of the filter of a 2D convolution.
 *
 * @param x The input tensor, of rank 4 or rank 3 of shape
 *     [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.
 * @param dy The dy image, of rank 4 or rank 3, of shape
 *     [batch, height, width, outDepth]. If rank 3, batch of 1 is assumed.
 * @param filterShape The shape of the filter, length 4,
 *     [filterHeight, filterWidth, inDepth, outDepth].
 * @param strides The strides of the convolution: [strideHeight,
 * strideWidth].
 * @param pad A string from: 'same', 'valid'. The type of padding algorithm
 *     used in the forward prop of the op.
 * @param dataFormat: An optional string from: "NHWC", "NCHW". Defaults to
 *     "NHWC". Specify the data format of the input and output data. With the
 *     default format "NHWC", the data is stored in the order of: [batch,
 *     height, width, channels].
 * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is
 *     provided, it will default to truncate.
 */
function conv2DBackpropFilter_(x, dy, filterShape, strides, pad, dataFormat = 'NHWC', dimRoundingMode) {
    let x4D = x;
    if (x.rank === 3) {
        x4D = reshape(x, [1, x.shape[0], x.shape[1], x.shape[2]]);
    }
    let dy4D = dy;
    if (dy4D.rank === 3) {
        dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
    }
    assert(x4D.rank === 4, () => `Error in conv2dDerFilter: input must be rank 4, but got shape ` +
        `${x4D.shape}.`);
    assert(dy4D.rank === 4, () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ` +
        `${dy4D.shape}.`);
    assert(filterShape.length === 4, () => `Error in conv2dDerFilter: filterShape must be length 4, but got ` +
        `${filterShape}.`);
    const inDepth = dataFormat === 'NHWC' ? x4D.shape[3] : x4D.shape[1];
    const outDepth = dataFormat === 'NHWC' ? dy4D.shape[3] : dy4D.shape[1];
    assert(inDepth === filterShape[2], () => `Error in conv2dDerFilter: depth of input ${inDepth}) must ` +
        `match input depth in filter (${filterShape[2]}.`);
    assert(outDepth === filterShape[3], () => `Error in conv2dDerFilter: depth of dy (${outDepth}) must ` +
        `match output depth for filter (${filterShape[3]}).`);
    checkPadOnDimRoundingMode('conv2dDerFilter', pad, dimRoundingMode);
    const inputs = { x: x4D, dy: dy4D };
    const attrs = { strides, pad, dataFormat, dimRoundingMode, filterShape };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    return ENGINE.runKernel(Conv2DBackpropFilter, inputs, attrs);
}
const conv2DBackpropFilter = op({ conv2DBackpropFilter_ });

/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
// Returns gradient for fused activation.
function getFusedDyActivation(dy, y, activation) {
    if (activation == null || activation === 'linear') {
        return dy;
    }
    if (activation === 'relu') {
        return mul(dy, step(y));
    }
    throw new Error(`Cannot compute gradient for fused activation ${activation}.`);
}
// Returns gradient for fused bias.
function getFusedBiasGradient(bias, dyActivation) {
    let res = dyActivation;
    const reduceAxes = getReductionAxes(bias.shape, dyActivation.shape);
    if (reduceAxes.length > 0) {
        res = sum(res, reduceAxes);
    }
    return reshape(res, bias.shape);
}
function applyActivation(x, activation, preluActivationWeights, leakyreluAlpha) {
    if (activation === 'linear') {
        return x;
    }
    else if (activation === 'relu') {
        return relu(x);
    }
    else if (activation === 'elu') {
        return elu(x);
    }
    else if (activation === 'relu6') {
        return relu6(x);
    }
    else if (activation === 'prelu') {
        return prelu(x, preluActivationWeights);
    }
    else if (activation === 'leakyrelu') {
        return leakyRelu(x, leakyreluAlpha);
    }
    else if (activation === 'sigmoid') {
        return sigmoid(x);
    }
    throw new Error(`Unknown fused activation ${activation}.`);
}
// Whether we should call fused ops.
const shouldFuse = (gradientDepth, activation) => {
    const gradientMode = gradientDepth > 0;
    return !gradientMode || activation === 'linear';
};

/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes a 2D convolution over the input x, optionally fused with adding a
 * bias and applying an activation.
 *
 * ```js
 * const inputDepth = 2;
 * const inShape = [2, 2, 2, inputDepth];
 * const outputDepth = 2;
 * const fSize = 1;
 * const pad = 0;
 * const strides = 1;
 *
 * const x = tf.tensor4d( [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
 * 16], inShape);
 * const w = tf.tensor4d([-1, 1, -2, 0.5], [fSize, fSize, inputDepth,
 * outputDepth]);
 *
 * tf.fused.conv2d({ x, filter: w, strides, pad, dataFormat: 'NHWC',
 * dilations: [1, 1], bias: tf.scalar(5), activation: 'relu' }).print();
 * ```
 *
 * @param obj An object with the following properties:
 * @param x The input tensor, of rank 4 or rank 3, of shape
 *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is
 * assumed.
 * @param filter The filter, rank 4, of shape
 *     `[filterHeight, filterWidth, inDepth, outDepth]`.
 * @param strides The strides of the convolution: `[strideHeight,
 * strideWidth]`.
 * @param pad The type of padding algorithm.
 *   - `same` and stride 1: output will be of same size as input,
 *       regardless of filter size.
 *   - `valid` output will be smaller than input if filter is larger
 *       than 1x1.
 *   - For more info, see this guide:
 *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](
 *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)
 * @param dataFormat An optional string from: "NHWC", "NCHW". Defaults to
 *     "NHWC". Specify the data format of the input and output data. With the
 *     default format "NHWC", the data is stored in the order of: [batch,
 *     height, width, channels]. Only "NHWC" is currently supported.
 * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`
 *     in which we sample input values across the height and width dimensions
 *     in atrous convolution. Defaults to `[1, 1]`. If `dilations` is a single
 *     number, then `dilationHeight == dilationWidth`. If it is greater than
 *     1, then all values of `strides` must be 1.
 * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is
 *     provided, it will default to truncate.
 * @param bias Tensor to be added to the result.
 * @param activation Name of activation kernel (defaults to `linear`) to be
 *     applied
 *      after biasAdd.
 * @param preluActivationWeights Tensor of prelu weights to be applied as part
 *     of a `prelu` activation, typically the same shape as `x`.
 * @param leakyreluAlpha Optional. Alpha to be applied as part of a `leakyrelu`
 *     activation.
 */
function fusedConv2d_({ x, filter, strides, pad, dataFormat = 'NHWC', dilations = [1, 1], dimRoundingMode, bias, activation = 'linear', preluActivationWeights, leakyreluAlpha }) {
    activation = activation || 'linear';
    if (shouldFuse(ENGINE.state.gradientDepth, activation) === false) {
        // TODO: Transpose bias and preluActivationWeights properly for NCHW
        // format before computation.
        assert(dataFormat === 'NHWC', () => `Error in fused conv2d: got dataFormat of ${dataFormat} but ` +
            `only NHWC is currently supported for the case of gradient depth ` +
            `is 0 and the activation is not linear.`);
        let result = conv2d(x, filter, strides, pad, dataFormat, dilations, dimRoundingMode);
        if (bias != null) {
            result = add(result, bias);
        }
        return applyActivation(result, activation, preluActivationWeights, leakyreluAlpha);
    }
    const $x = convertToTensor(x, 'x', 'conv2d', 'float32');
    const $filter = convertToTensor(filter, 'filter', 'conv2d', 'float32');
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert(x4D.rank === 4, () => `Error in fused conv2d: input must be rank 4, but got rank ` +
        `${x4D.rank}.`);
    assert($filter.rank === 4, () => `Error in fused conv2d: filter must be rank 4, but got rank ` +
        `${$filter.rank}.`);
    checkPadOnDimRoundingMode('fused conv2d', pad, dimRoundingMode);
    const inputChannels = dataFormat === 'NHWC' ? x4D.shape[3] : x4D.shape[1];
    assert($filter.shape[2] === inputChannels, () => `Error in conv2d: depth of input (${inputChannels}) must match ` +
        `input depth for filter ${$filter.shape[2]}.`);
    assert(eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in conv2D: Either strides or dilations must be 1. ' +
        `Got strides ${strides} and dilations '${dilations}'`);
    const convInfo = computeConv2DInfo(x4D.shape, $filter.shape, strides, dilations, pad, dimRoundingMode);
    let $bias;
    if (bias != null) {
        $bias = convertToTensor(bias, 'bias', 'fused conv2d');
        [$bias] = makeTypesMatch($bias, $x);
        // According to TensorFlow, the bias is supposed be a 1-D tensor or a
        // scalar.
        //
        // 3-D or 4-D bias is not disabled for NHWC format, because they are
        // currently being used in some cases. For examplem in our code base,
        // https://github.com/tensorflow/tfjs/blob/b53bd47e880367ae57493f0ea628abaf08db2d5d/tfjs-core/src/ops/fused/fused_conv2d_test.ts#L1972.
        if (dataFormat === 'NHWC') {
            assertAndGetBroadcastShape(convInfo.outShape, $bias.shape);
        }
        else {
            assert($bias.shape.length <= 1, () => `Error in fused conv2d: only supports scalar or 1-D Tensor ` +
                `bias for NCHW format but got the bias of ` +
                `rank-${$bias.shape.length}.`);
            assert($bias.shape.length === 0 || $bias.shape[0] === convInfo.outChannels ||
                $bias.shape[0] === 1, () => `Error in fused conv2d: bias shape (${$bias.shape}) is not ` +
                `compatible with the number of output channels ` +
                `(${convInfo.outChannels})`);
        }
    }
    let $preluActivationWeights;
    if (preluActivationWeights != null) {
        // PReLU's activation weights could be a scalar, a 1-D tensor or a 3-D
        // tensor.
        const alphaShape = preluActivationWeights.shape;
        assert(alphaShape.length <= 1 || alphaShape.length === 3, () => `Error in fused conv2d: only supports scalar, 1-D Tensor or ` +
            `3-D Tensor PReLU activation weights but got a tensor of ` +
            `rank-${alphaShape.length}.`);
        if (alphaShape.length === 1) {
            // Whether the data format is NCHW or NHWC, the 1-D PReLU activation
            // weights tensor should be aligned with the output channels of conv2d
            // result.
            assert(alphaShape[0] === 1 || alphaShape[0] === convInfo.outChannels, () => `Error in fused conv2d: PReLU activation weights ` +
                `(${alphaShape}) is not compatible with the number of output ` +
                `channels (${convInfo.outChannels}).`);
        }
        else if (alphaShape.length === 3) {
            // Whether the data format is NCHW or NHWC, the PReLU activation weights
            // tensor should has the compatible shape with the result of conv2d.
            try {
                assertAndGetBroadcastShape(alphaShape, convInfo.outShape);
            }
            catch (e) {
                const errMsg = `Error in fused conv2d: PReLU activation weights (${alphaShape}) ` +
                    `is not compatible with the output shape of the conv2d ` +
                    `(${convInfo.outShape}).`;
                throw Error(errMsg);
            }
        }
        $preluActivationWeights = convertToTensor(preluActivationWeights, 'prelu weights', 'fused conv2d');
    }
    const grad = (dy, saved) => {
        assert(dataFormat === 'NHWC', () => `Error in gradient of fused conv2D: got dataFormat of ${dataFormat} but only NHWC is currently supported.`);
        const [$filter, x4D, y, $bias] = saved;
        const dyActivation = getFusedDyActivation(dy, y, activation);
        assert(tupleValuesAreOne(dilations), () => 'Error in gradient of fused conv2D: ' +
            `dilation rates greater than 1 ` +
            `are not yet supported in gradients. Got dilations '${dilations}'`);
        const xDer = conv2DBackpropInput(x4D.shape, dyActivation, $filter, strides, pad);
        const filterDer = conv2DBackpropFilter(x4D, dyActivation, $filter.shape, strides, pad);
        const der = [xDer, filterDer];
        if ($bias != null) {
            const biasDer = getFusedBiasGradient($bias, dyActivation);
            der.push(biasDer);
        }
        return der;
    };
    const inputs = {
        x: x4D,
        filter: $filter,
        bias: $bias,
        preluActivationWeights: $preluActivationWeights
    };
    const attrs = {
        strides,
        pad,
        dataFormat,
        dilations,
        dimRoundingMode,
        activation,
        leakyreluAlpha
    };
    // Depending on the the params passed in we will have different number of
    // inputs and thus a a different number of elements in the gradient.
    if (bias == null) {
        const customOp = customGrad((x4D, filter, save) => {
            let res = 
            // tslint:disable-next-line: no-unnecessary-type-assertion
            ENGINE.runKernel(FusedConv2D, inputs, attrs);
            save([filter, x4D, res]);
            if (reshapedTo4D) {
                // tslint:disable-next-line: no-unnecessary-type-assertion
                res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
            }
            return { value: res, gradFunc: grad };
        });
        return customOp(x4D, $filter);
    }
    else {
        const customOpWithBias = customGrad((x4D, filter, bias, save) => {
            let res = ENGINE.runKernel(FusedConv2D, inputs, attrs);
            save([filter, x4D, res, bias]);
            if (reshapedTo4D) {
                // tslint:disable-next-line: no-unnecessary-type-assertion
                res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
            }
            return { value: res, gradFunc: grad };
        });
        return customOpWithBias(x4D, $filter, $bias);
    }
}
op({ fusedConv2d_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function depthwiseConv2dNativeBackpropFilter_(x, dy, filterShape, strides, pad, dilations = [1, 1], dimRoundingMode) {
    let x4D = x;
    if (x.rank === 3) {
        x4D = reshape(x, [1, x.shape[0], x.shape[1], x.shape[2]]);
    }
    let dy4D = dy;
    if (dy4D.rank === 3) {
        dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
    }
    const inputs = { x: x4D, dy: dy4D };
    const attrs = { strides, pad, dimRoundingMode, dilations, filterShape };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    return ENGINE.runKernel(DepthwiseConv2dNativeBackpropFilter, inputs, attrs);
}
const depthwiseConv2dNativeBackpropFilter = op({ depthwiseConv2dNativeBackpropFilter_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function depthwiseConv2dNativeBackpropInput_(xShape, dy, filter, strides, pad, dilations = [1, 1], dimRoundingMode) {
    let dy4D = dy;
    let reshapedTo4D = false;
    if (dy.rank === 3) {
        reshapedTo4D = true;
        dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
    }
    const inputs = { dy: dy4D, filter };
    const attrs = { strides, pad, dimRoundingMode, dilations, inputShape: xShape };
    const res = 
    // tslint:disable-next-line: no-unnecessary-type-assertion
    ENGINE.runKernel(DepthwiseConv2dNativeBackpropInput, inputs, attrs);
    if (reshapedTo4D) {
        return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
}
const depthwiseConv2dNativeBackpropInput = op({ depthwiseConv2dNativeBackpropInput_ });

/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes depthwise 2D convolution, optionally fused with adding a
 * bias and applying an activation.
 *
 * Given a 4D `input` array and a `filter` array of shape
 * `[filterHeight, filterWidth, inChannels, channelMultiplier]` containing
 * `inChannels` convolutional filters of depth 1, this op applies a
 * different filter to each input channel (expanding from 1 channel to
 * `channelMultiplier` channels for each), then concatenates the results
 * together. The output has `inChannels * channelMultiplier` channels.
 *
 * See
 * [https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d](
 *     https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d)
 * for more details.
 *
 * @param obj An object with the following properties:
 * @param x The input tensor, of rank 4 or rank 3, of shape
 *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is
 * assumed.
 * @param filter The filter tensor, rank 4, of shape
 *     `[filterHeight, filterWidth, inChannels, channelMultiplier]`.
 * @param strides The strides of the convolution: `[strideHeight,
 * strideWidth]`. If strides is a single number, then `strideHeight ==
 * strideWidth`.
 * @param pad The type of padding algorithm.
 *   - `same` and stride 1: output will be of same size as input,
 *       regardless of filter size.
 *   - `valid`: output will be smaller than input if filter is larger
 *       than 1x1.
 *   - For more info, see this guide:
 *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](
 *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)
 * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`
 *     in which we sample input values across the height and width dimensions
 *     in atrous convolution. Defaults to `[1, 1]`. If `rate` is a single
 *     number, then `dilationHeight == dilationWidth`. If it is greater than
 *     1, then all values of `strides` must be 1.
 * @param dataFormat: An optional string from: "NHWC", "NCHW". Defaults to
 *     "NHWC". Specify the data format of the input and output data. With the
 *     default format "NHWC", the data is stored in the order of: [batch,
 *     height, width, channels]. Only "NHWC" is currently supported.
 * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is
 *     provided, it will default to truncate.
 * @param bias Tensor to be added to the result.
 * @param activation Name of activation kernel (defaults to `linear`).
 * @param preluActivationWeights Tensor of prelu weights to be applied as part
 *     of a `prelu` activation, typically the same shape as `x`.
 * @param leakyreluAlpha Optional. Alpha to be applied as part of a `leakyrelu`
 *     activation.
 */
function fusedDepthwiseConv2d_({ x, filter, strides, pad, dataFormat = 'NHWC', dilations = [1, 1], dimRoundingMode, bias, activation = 'linear', preluActivationWeights, leakyreluAlpha }) {
    if (shouldFuse(ENGINE.state.gradientDepth, activation) === false) {
        let result = depthwiseConv2d(x, filter, strides, pad, dataFormat, dilations, dimRoundingMode);
        if (bias != null) {
            result = add(result, bias);
        }
        return applyActivation(result, activation, preluActivationWeights, leakyreluAlpha);
    }
    const $x = convertToTensor(x, 'x', 'depthwiseConv2d', 'float32');
    const $filter = convertToTensor(filter, 'filter', 'depthwiseConv2d', 'float32');
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert(x4D.rank === 4, () => `Error in fused depthwiseConv2d: input must be rank 4, but got ` +
        `rank ${x4D.rank}.`);
    assert($filter.rank === 4, () => `Error in fused depthwiseConv2d: filter must be rank 4, ` +
        `but got rank ${$filter.rank}.`);
    assert(x4D.shape[3] === $filter.shape[2], () => `Error in fused depthwiseConv2d: number of input channels ` +
        `(${x4D.shape[3]}) must match the inChannels dimension in ` +
        `filter ${$filter.shape[2]}.`);
    if (dilations == null) {
        dilations = [1, 1];
    }
    assert(eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in fused depthwiseConv2d: Either strides or dilations must ' +
        `be 1. Got strides ${strides} and dilations '${dilations}'`);
    checkPadOnDimRoundingMode('fused depthwiseConv2d', pad, dimRoundingMode);
    const convInfo = computeConv2DInfo(x4D.shape, $filter.shape, strides, dilations, pad, dimRoundingMode, true /* depthwise */);
    let $bias;
    if (bias != null) {
        $bias = convertToTensor(bias, 'bias', 'fused conv2d');
        [$bias] = makeTypesMatch($bias, $x);
        assertAndGetBroadcastShape(convInfo.outShape, $bias.shape);
    }
    let $preluActivationWeights;
    if (preluActivationWeights != null) {
        $preluActivationWeights = convertToTensor(preluActivationWeights, 'prelu weights', 'fused depthwiseConv2d');
    }
    const grad = (dy, saved) => {
        assert(tupleValuesAreOne(dilations), () => 'Error in gradient of fused depthwiseConv2d: dilation rates ' +
            `greater than 1 are not yet supported. Got dilations ` +
            `'${dilations}'`);
        const [$filter, x4D, y, bias] = saved;
        const dyActivation = getFusedDyActivation(dy, y, activation);
        const xDer = depthwiseConv2dNativeBackpropInput(x4D.shape, dyActivation, $filter, strides, pad, dilations, dimRoundingMode);
        const filterDer = depthwiseConv2dNativeBackpropFilter(x4D, dyActivation, $filter.shape, strides, pad, dilations, dimRoundingMode);
        if (bias != null) {
            const biasDer = getFusedBiasGradient($bias, dyActivation);
            return [xDer, filterDer, biasDer];
        }
        return [xDer, filterDer];
    };
    const inputs = {
        x: x4D,
        filter: $filter,
        bias: $bias,
        preluActivationWeights: $preluActivationWeights
    };
    const attrs = {
        strides,
        pad,
        dataFormat,
        dilations,
        dimRoundingMode,
        activation,
        leakyreluAlpha
    };
    // Depending on the the params passed in we will have different number of
    // inputs and thus a a different number of elements in the gradient.
    if (bias == null) {
        const customOp = customGrad((x4D, filter, save) => {
            // tslint:disable-next-line: no-unnecessary-type-assertion
            let res = ENGINE.runKernel(FusedDepthwiseConv2D, inputs, attrs);
            save([filter, x4D, res]);
            if (reshapedTo4D) {
                // tslint:disable-next-line: no-unnecessary-type-assertion
                res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
            }
            return { value: res, gradFunc: grad };
        });
        return customOp(x4D, $filter);
    }
    else {
        const customOpWithBias = customGrad((x4D, filter, bias, save) => {
            // tslint:disable-next-line: no-unnecessary-type-assertion
            let res = ENGINE.runKernel(FusedDepthwiseConv2D, inputs, attrs);
            save([filter, x4D, res, bias]);
            if (reshapedTo4D) {
                // tslint:disable-next-line: no-unnecessary-type-assertion
                res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
            }
            return { value: res, gradFunc: grad };
        });
        return customOpWithBias(x4D, $filter, $bias);
    }
}
op({ fusedDepthwiseConv2d_ });

/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the dot product of two matrices with optional activation and bias.
 *
 * ```js
 * const a = tf.tensor2d([-1, -2], [1, 2]);
 * const b = tf.tensor2d([1, 2, 3, 4], [2, 2]);
 * const bias = tf.tensor2d([1, 2], [1, 2]);
 *
 * tf.fused.matMul({a, b, bias, activation: 'relu'}).print();
 * ```
 *
 * @param obj An object with the following properties:
 * - `a` First matrix in dot product operation.
 * - `b` Second matrix in dot product operation.
 * - `transposeA` If true, `a` is transposed before multiplication.
 * - `transposeB` If true, `b` is transposed before multiplication.
 * - `bias` Matrix to be added to the result.
 * - `activation` Name of activation kernel (defaults to `linear`).
 * - `preluActivationWeights` Tensor of prelu weights.
 * - `leakyreluAlpha` Alpha of leakyrelu.
 */
function fusedMatMul_({ a, b, transposeA = false, transposeB = false, bias, activation = 'linear', preluActivationWeights, leakyreluAlpha = 0.2, }) {
    if (shouldFuse(ENGINE.state.gradientDepth, activation) === false) {
        let result = matMul(a, b, transposeA, transposeB);
        if (bias != null) {
            result = add(result, bias);
        }
        return applyActivation(result, activation, preluActivationWeights, leakyreluAlpha);
    }
    let $a = convertToTensor(a, 'a', 'fused matMul');
    let $b = convertToTensor(b, 'b', 'fused matMul');
    [$a, $b] = makeTypesMatch($a, $b);
    const innerShapeA = transposeA ? $a.shape[$a.rank - 2] : $a.shape[$a.rank - 1];
    const innerShapeB = transposeB ? $b.shape[$b.rank - 1] : $b.shape[$b.rank - 2];
    const outerShapeA = transposeA ? $a.shape[$a.rank - 1] : $a.shape[$a.rank - 2];
    const outerShapeB = transposeB ? $b.shape[$b.rank - 2] : $b.shape[$b.rank - 1];
    const outerDimsA = $a.shape.slice(0, -2);
    const outerDimsB = $b.shape.slice(0, -2);
    const batchDimA = sizeFromShape(outerDimsA);
    const batchDimB = sizeFromShape(outerDimsB);
    assert(innerShapeA === innerShapeB, () => `Error in fused matMul: inner shapes (${innerShapeA}) and (` +
        `${innerShapeB}) of Tensors with shapes ${$a.shape} and ` +
        `${$b.shape} and transposeA=${transposeA}` +
        ` and transposeB=${transposeB} must match.`);
    const outShapeOuterDims = assertAndGetBroadcastShape($a.shape.slice(0, -2), $b.shape.slice(0, -2));
    const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);
    const a3D = transposeA ?
        reshape($a, [batchDimA, innerShapeA, outerShapeA]) :
        reshape($a, [batchDimA, outerShapeA, innerShapeA]);
    const b3D = transposeB ?
        reshape($b, [batchDimB, outerShapeB, innerShapeB]) :
        reshape($b, [batchDimB, innerShapeB, outerShapeB]);
    let $bias;
    if (bias != null) {
        $bias = convertToTensor(bias, 'bias', 'fused matMul');
        [$bias] = makeTypesMatch($bias, $a);
        assertAndGetBroadcastShape(outShape, $bias.shape);
    }
    let $preluActivationWeights;
    if (preluActivationWeights != null) {
        $preluActivationWeights = convertToTensor(preluActivationWeights, 'prelu weights', 'fused matMul');
    }
    const grad = (dy, saved) => {
        const [a3D, b3D, y, $bias] = saved;
        // we reshape dy because the result of the forward is not
        // necessarily going to be a 3d tensor due to a reshape done at the end of
        // the customOp.
        const dyActivation = getFusedDyActivation(reshape(dy, y.shape), y, activation);
        let aDer;
        let bDer;
        if (!transposeA && !transposeB) {
            aDer = matMul(dyActivation, b3D, false, true);
            bDer = matMul(a3D, dyActivation, true, false);
        }
        else if (!transposeA && transposeB) {
            aDer = matMul(dyActivation, b3D, false, false);
            bDer = matMul(dyActivation, a3D, true, false);
        }
        else if (transposeA && !transposeB) {
            aDer = matMul(b3D, dyActivation, false, true);
            bDer = matMul(a3D, dyActivation, false, false);
        }
        else {
            aDer = matMul(b3D, dyActivation, true, true);
            bDer = matMul(dyActivation, a3D, true, true);
        }
        if (bias != null) {
            const biasDer = getFusedBiasGradient($bias, dyActivation);
            return [aDer, bDer, biasDer];
        }
        else {
            return [aDer, bDer];
        }
    };
    const inputs = {
        a: a3D,
        b: b3D,
        bias: $bias,
        preluActivationWeights: $preluActivationWeights
    };
    const attrs = { transposeA, transposeB, activation, leakyreluAlpha };
    // Depending on the the params passed in we will have different number of
    // inputs and thus a a different number of elements in the gradient.
    if (bias == null) {
        const customOp = customGrad((a3D, b3D, save) => {
            const res = 
            // tslint:disable-next-line: no-unnecessary-type-assertion
            ENGINE.runKernel(_FusedMatMul, inputs, attrs);
            save([a3D, b3D, res]);
            return { value: reshape(res, outShape), gradFunc: grad };
        });
        return customOp(a3D, b3D);
    }
    else {
        const customOpWithBias = customGrad((a3D, b3D, $bias, save) => {
            const res = 
            // tslint:disable-next-line: no-unnecessary-type-assertion
            ENGINE.runKernel(_FusedMatMul, inputs, attrs);
            save([a3D, b3D, res, $bias]);
            return { value: reshape(res, outShape), gradFunc: grad };
        });
        return customOpWithBias(a3D, b3D, $bias);
    }
}
op({ fusedMatMul_ });

/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Generate a hamming window.
 *
 * See: https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows
 *
 * ```js
 * tf.signal.hammingWindow(10).print();
 * ```
 * @param The length of window
 *
 * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}
 */
function hammingWindow_(windowLength) {
    return cosineWindow(windowLength, 0.54, 0.46);
}
op({ hammingWindow_ });

/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Generate a Hann window.
 *
 * See: https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows
 *
 * ```js
 * tf.signal.hannWindow(10).print();
 * ```
 * @param The length of window
 *
 * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}
 */
function hannWindow_(windowLength) {
    return cosineWindow(windowLength, 0.5, 0.5);
}
const hannWindow = op({ hannWindow_ });

/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Expands input into frames of frameLength.
 * Slides a window size with frameStep.
 *
 * ```js
 * tf.signal.frame([1, 2, 3], 2, 1).print();
 * ```
 * @param signal The input tensor to be expanded
 * @param frameLength Length of each frame
 * @param frameStep The frame hop size in samples.
 * @param padEnd Whether to pad the end of signal with padValue.
 * @param padValue A number to use where the input signal does
 *     not exist when padEnd is True.
 *
 * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}
 */
function frame_(signal, frameLength, frameStep, padEnd = false, padValue = 0) {
    let start = 0;
    const output = [];
    while (start + frameLength <= signal.size) {
        output.push(slice(signal, start, frameLength));
        start += frameStep;
    }
    if (padEnd) {
        while (start < signal.size) {
            const padLen = (start + frameLength) - signal.size;
            const pad = concat([
                slice(signal, start, frameLength - padLen), fill([padLen], padValue)
            ]);
            output.push(pad);
            start += frameStep;
        }
    }
    if (output.length === 0) {
        return tensor2d([], [0, frameLength]);
    }
    return reshape(concat(output), [output.length, frameLength]);
}
const frame = op({ frame_ });

/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the Short-time Fourier Transform of signals
 * See: https://en.wikipedia.org/wiki/Short-time_Fourier_transform
 *
 * ```js
 * const input = tf.tensor1d([1, 1, 1, 1, 1])
 * tf.signal.stft(input, 3, 1).print();
 * ```
 * @param signal 1-dimensional real value tensor.
 * @param frameLength The window length of samples.
 * @param frameStep The number of samples to step.
 * @param fftLength The size of the FFT to apply.
 * @param windowFn A callable that takes a window length and returns 1-d tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}
 */
function stft_(signal, frameLength, frameStep, fftLength, windowFn = hannWindow) {
    if (fftLength == null) {
        fftLength = enclosingPowerOfTwo(frameLength);
    }
    const framedSignal = frame(signal, frameLength, frameStep);
    const windowedSignal = mul(framedSignal, windowFn(frameLength));
    return rfft(windowedSignal, fftLength);
}
op({ stft_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Extracts crops from the input image tensor and resizes them using bilinear
 * sampling or nearest neighbor sampling (possibly with aspect ratio change)
 * to a common output size specified by cropSize.
 *
 * @param image 4d tensor of shape `[batch,imageHeight,imageWidth, depth]`,
 *     where imageHeight and imageWidth must be positive, specifying the
 *     batch of images from which to take crops
 * @param boxes 2d float32 tensor of shape `[numBoxes, 4]`. Each entry is
 *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the normalized
 *     coordinates of the box in the `boxInd[i]`th image in the batch
 * @param boxInd 1d int32 tensor of shape `[numBoxes]` with values in range
 *     `[0, batch)` that specifies the image that the `i`-th box refers to.
 * @param cropSize 1d int32 tensor of 2 elements `[cropHeigh, cropWidth]`
 *     specifying the size to which all crops are resized to.
 * @param method Optional string from `'bilinear' | 'nearest'`,
 *     defaults to bilinear, which specifies the sampling method for resizing
 * @param extrapolationValue A threshold for deciding when to remove boxes based
 *     on score. Defaults to 0.
 * @return A 4D tensor of the shape `[numBoxes,cropHeight,cropWidth,depth]`
 *
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}
 */
function cropAndResize_(image, boxes, boxInd, cropSize, method = 'bilinear', extrapolationValue = 0) {
    const $image = convertToTensor(image, 'image', 'cropAndResize');
    const $boxes = convertToTensor(boxes, 'boxes', 'cropAndResize', 'float32');
    const $boxInd = convertToTensor(boxInd, 'boxInd', 'cropAndResize', 'int32');
    const numBoxes = $boxes.shape[0];
    assert($image.rank === 4, () => 'Error in cropAndResize: image must be rank 4,' +
        `but got rank ${$image.rank}.`);
    assert($boxes.rank === 2 && $boxes.shape[1] === 4, () => `Error in cropAndResize: boxes must be have size [${numBoxes},4] ` +
        `but had shape ${$boxes.shape}.`);
    assert($boxInd.rank === 1 && $boxInd.shape[0] === numBoxes, () => `Error in cropAndResize: boxInd must be have size [${numBoxes}] ` +
        `but had shape ${$boxes.shape}.`);
    assert(cropSize.length === 2, () => `Error in cropAndResize: cropSize must be of length 2, but got ` +
        `length ${cropSize.length}.`);
    assert(cropSize[0] >= 1 && cropSize[1] >= 1, () => `cropSize must be atleast [1,1], but was ${cropSize}`);
    assert(method === 'bilinear' || method === 'nearest', () => `method must be bilinear or nearest, but was ${method}`);
    const inputs = { image: $image, boxes: $boxes, boxInd: $boxInd };
    const attrs = { method, extrapolationValue, cropSize };
    const res = ENGINE.runKernel(CropAndResize, inputs, attrs);
    return res;
}
op({ cropAndResize_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Flips the image left to right. Currently available in the CPU, WebGL, and
 * WASM backends.
 *
 * @param image 4d tensor of shape `[batch, imageHeight, imageWidth, depth]`.
 */
/** @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'} */
function flipLeftRight_(image) {
    const $image = convertToTensor(image, 'image', 'flipLeftRight', 'float32');
    assert($image.rank === 4, () => 'Error in flipLeftRight: image must be rank 4,' +
        `but got rank ${$image.rank}.`);
    const inputs = { image: $image };
    const res = ENGINE.runKernel(FlipLeftRight, inputs, {});
    return res;
}
op({ flipLeftRight_ });

/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Converts images from grayscale to RGB format.
 *
 * @param image A grayscale tensor to convert. The `image`'s last dimension must
 *     be size 1 with at least a two-dimensional shape.
 *
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}
 */
function grayscaleToRGB_(image) {
    const $image = convertToTensor(image, 'image', 'grayscaleToRGB');
    const lastDimsIdx = $image.rank - 1;
    const lastDims = $image.shape[lastDimsIdx];
    assert($image.rank >= 2, () => 'Error in grayscaleToRGB: images must be at least rank 2, ' +
        `but got rank ${$image.rank}.`);
    assert(lastDims === 1, () => 'Error in grayscaleToRGB: last dimension of a grayscale image ' +
        `should be size 1, but got size ${lastDims}.`);
    const reps = new Array($image.rank);
    reps.fill(1, 0, lastDimsIdx);
    reps[lastDimsIdx] = 3;
    return tile($image, reps);
}
op({ grayscaleToRGB_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Rotates the input image tensor counter-clockwise with an optional offset
 * center of rotation. Currently available in the CPU, WebGL, and WASM backends.
 *
 * @param image 4d tensor of shape `[batch, imageHeight, imageWidth, depth]`.
 * @param radians The amount of rotation.
 * @param fillValue The value to fill in the empty space leftover
 *     after rotation. Can be either a single grayscale value (0-255), or an
 *     array of three numbers `[red, green, blue]` specifying the red, green,
 *     and blue channels. Defaults to `0` (black).
 * @param center The center of rotation. Can be either a single value (0-1), or
 *     an array of two numbers `[centerX, centerY]`. Defaults to `0.5` (rotates
 *     the image around its center).
 *
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}
 */
function rotateWithOffset_(image, radians, fillValue = 0, center = 0.5) {
    const $image = convertToTensor(image, 'image', 'rotateWithOffset', 'float32');
    assert($image.rank === 4, () => 'Error in rotateWithOffset: image must be rank 4,' +
        `but got rank ${$image.rank}.`);
    const inputs = { image: $image };
    const attrs = { radians, fillValue, center };
    const res = ENGINE.runKernel(RotateWithOffset, inputs, attrs);
    return res;
}
op({ rotateWithOffset_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nonMaxSuppSanityCheck(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {
    if (iouThreshold == null) {
        iouThreshold = 0.5;
    }
    if (scoreThreshold == null) {
        scoreThreshold = Number.NEGATIVE_INFINITY;
    }
    if (softNmsSigma == null) {
        softNmsSigma = 0.0;
    }
    const numBoxes = boxes.shape[0];
    maxOutputSize = Math.min(maxOutputSize, numBoxes);
    assert(0 <= iouThreshold && iouThreshold <= 1, () => `iouThreshold must be in [0, 1], but was '${iouThreshold}'`);
    assert(boxes.rank === 2, () => `boxes must be a 2D tensor, but was of rank '${boxes.rank}'`);
    assert(boxes.shape[1] === 4, () => `boxes must have 4 columns, but 2nd dimension was ${boxes.shape[1]}`);
    assert(scores.rank === 1, () => 'scores must be a 1D tensor');
    assert(scores.shape[0] === numBoxes, () => `scores has incompatible shape with boxes. Expected ${numBoxes}, ` +
        `but was ${scores.shape[0]}`);
    assert(0 <= softNmsSigma && softNmsSigma <= 1, () => `softNmsSigma must be in [0, 1], but was '${softNmsSigma}'`);
    return { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma };
}

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Performs non maximum suppression of bounding boxes based on
 * iou (intersection over union).
 *
 * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is
 *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of
 *     the bounding box.
 * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.
 * @param maxOutputSize The maximum number of boxes to be selected.
 * @param iouThreshold A float representing the threshold for deciding whether
 *     boxes overlap too much with respect to IOU. Must be between [0, 1].
 *     Defaults to 0.5 (50% box overlap).
 * @param scoreThreshold A threshold for deciding when to remove boxes based
 *     on score. Defaults to -inf, which means any score is accepted.
 * @return A 1D tensor with the selected box indices.
 *
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}
 */
function nonMaxSuppression_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY) {
    const $boxes = convertToTensor(boxes, 'boxes', 'nonMaxSuppression', 'float32');
    const $scores = convertToTensor(scores, 'scores', 'nonMaxSuppression', 'float32');
    const inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);
    maxOutputSize = inputs.maxOutputSize;
    iouThreshold = inputs.iouThreshold;
    scoreThreshold = inputs.scoreThreshold;
    const attrs = { maxOutputSize, iouThreshold, scoreThreshold };
    return ENGINE.runKernel(NonMaxSuppressionV3, { boxes: $boxes, scores: $scores }, attrs);
}
op({ nonMaxSuppression_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Performs non maximum suppression of bounding boxes based on
 * iou (intersection over union).
 *
 * This op also supports a Soft-NMS mode (cf.
 * Bodla et al, https://arxiv.org/abs/1704.04503) where boxes reduce the score
 * of other overlapping boxes, therefore favoring different regions of the image
 * with high scores. To enable this Soft-NMS mode, set the `softNmsSigma`
 * parameter to be larger than 0.
 *
 * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is
 *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of
 *     the bounding box.
 * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.
 * @param maxOutputSize The maximum number of boxes to be selected.
 * @param iouThreshold A float representing the threshold for deciding whether
 *     boxes overlap too much with respect to IOU. Must be between [0, 1].
 *     Defaults to 0.5 (50% box overlap).
 * @param scoreThreshold A threshold for deciding when to remove boxes based
 *     on score. Defaults to -inf, which means any score is accepted.
 * @param softNmsSigma A float representing the sigma parameter for Soft NMS.
 *     When sigma is 0, it falls back to nonMaxSuppression.
 * @return A map with the following properties:
 *     - selectedIndices: A 1D tensor with the selected box indices.
 *     - selectedScores: A 1D tensor with the corresponding scores for each
 *       selected box.
 *
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}
 */
function nonMaxSuppressionWithScore_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, softNmsSigma = 0.0) {
    const $boxes = convertToTensor(boxes, 'boxes', 'nonMaxSuppression');
    const $scores = convertToTensor(scores, 'scores', 'nonMaxSuppression');
    const params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
    maxOutputSize = params.maxOutputSize;
    iouThreshold = params.iouThreshold;
    scoreThreshold = params.scoreThreshold;
    softNmsSigma = params.softNmsSigma;
    const inputs = { boxes: $boxes, scores: $scores };
    const attrs = { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    const result = ENGINE.runKernel(NonMaxSuppressionV5, inputs, attrs);
    return { selectedIndices: result[0], selectedScores: result[1] };
}
op({ nonMaxSuppressionWithScore_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Asynchronously performs non maximum suppression of bounding boxes based on
 * iou (intersection over union), with an option to pad results.
 *
 * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is
 *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of
 *     the bounding box.
 * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.
 * @param maxOutputSize The maximum number of boxes to be selected.
 * @param iouThreshold A float representing the threshold for deciding whether
 *     boxes overlap too much with respect to IOU. Must be between [0, 1].
 *     Defaults to 0.5 (50% box overlap).
 * @param scoreThreshold A threshold for deciding when to remove boxes based
 *     on score. Defaults to -inf, which means any score is accepted.
 * @param padToMaxOutputSize Defaults to false. If true, size of output
 *     `selectedIndices` is padded to maxOutputSize.
 * @return A map with the following properties:
 *     - selectedIndices: A 1D tensor with the selected box indices.
 *     - validOutputs: A scalar denoting how many elements in `selectedIndices`
 *       are valid. Valid elements occur first, then padding.
 *
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}
 */
function nonMaxSuppressionPadded_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, padToMaxOutputSize = false) {
    const $boxes = convertToTensor(boxes, 'boxes', 'nonMaxSuppression');
    const $scores = convertToTensor(scores, 'scores', 'nonMaxSuppression');
    const params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, null /* softNmsSigma */);
    const $maxOutputSize = params.maxOutputSize;
    const $iouThreshold = params.iouThreshold;
    const $scoreThreshold = params.scoreThreshold;
    const inputs = { boxes: $boxes, scores: $scores };
    const attrs = {
        maxOutputSize: $maxOutputSize,
        iouThreshold: $iouThreshold,
        scoreThreshold: $scoreThreshold,
        padToMaxOutputSize
    };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    const result = ENGINE.runKernel(NonMaxSuppressionV4, inputs, attrs);
    return { selectedIndices: result[0], validOutputs: result[1] };
}
op({ nonMaxSuppressionPadded_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Bilinear resize a single 3D image or a batch of 3D images to a new shape.
 *
 * @param images The images, of rank 4 or rank 3, of shape
 *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.
 * @param size The new shape `[newHeight, newWidth]` to resize the
 *     images to. Each channel is resized individually.
 * @param alignCorners Defaults to `false`. If true, rescale
 *     input by `(new_height - 1) / (height - 1)`, which exactly aligns the 4
 *     corners of images and resized images. If false, rescale by
 *     `new_height / height`. Treat similarly the width dimension.
 * @param halfPixelCenters Defaults to `false`. Whether to assume pixel centers
 *     are at 0.5, which would make the floating point coordinates of the top
 *     left pixel 0.5, 0.5.
 *
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}
 */
function resizeBilinear_(images, size, alignCorners = false, halfPixelCenters = false) {
    const $images = convertToTensor(images, 'images', 'resizeBilinear');
    assert($images.rank === 3 || $images.rank === 4, () => `Error in resizeBilinear: x must be rank 3 or 4, but got ` +
        `rank ${$images.rank}.`);
    assert(size.length === 2, () => `Error in resizeBilinear: new shape must 2D, but got shape ` +
        `${size}.`);
    assert(halfPixelCenters === false || alignCorners === false, () => `Error in resizeBilinear: If halfPixelCenters is true, ` +
        `alignCorners must be false.`);
    let batchImages = $images;
    let reshapedTo4D = false;
    if ($images.rank === 3) {
        reshapedTo4D = true;
        batchImages = reshape($images, [1, $images.shape[0], $images.shape[1], $images.shape[2]]);
    }
    const inputs = { images: batchImages };
    const attrs = { alignCorners, halfPixelCenters, size };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    const res = ENGINE.runKernel(ResizeBilinear, inputs, attrs);
    if (reshapedTo4D) {
        return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
}
op({ resizeBilinear_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * NearestNeighbor resize a batch of 3D images to a new shape.
 *
 * @param images The images, of rank 4 or rank 3, of shape
 *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.
 * @param size The new shape `[newHeight, newWidth]` to resize the
 *     images to. Each channel is resized individually.
 * @param alignCorners Defaults to False. If true, rescale
 *     input by `(new_height - 1) / (height - 1)`, which exactly aligns the 4
 *     corners of images and resized images. If false, rescale by
 *     `new_height / height`. Treat similarly the width dimension.
 * @param halfPixelCenters Defaults to `false`. Whether to assume pixels are of
 *      half the actual dimensions, and yield more accurate resizes. This flag
 *      would also make the floating point coordinates of the top left pixel
 *      0.5, 0.5.
 *
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}
 */
function resizeNearestNeighbor_(images, size, alignCorners = false, halfPixelCenters = false) {
    const $images = convertToTensor(images, 'images', 'resizeNearestNeighbor');
    assert($images.rank === 3 || $images.rank === 4, () => `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got ` +
        `rank ${$images.rank}.`);
    assert(size.length === 2, () => `Error in resizeNearestNeighbor: new shape must 2D, but got shape ` +
        `${size}.`);
    assert($images.dtype === 'float32' || $images.dtype === 'int32', () => '`images` must have `int32` or `float32` as dtype');
    assert(halfPixelCenters === false || alignCorners === false, () => `Error in resizeNearestNeighbor: If halfPixelCenters is true, ` +
        `alignCorners must be false.`);
    let batchImages = $images;
    let reshapedTo4D = false;
    if ($images.rank === 3) {
        reshapedTo4D = true;
        batchImages = reshape($images, [1, $images.shape[0], $images.shape[1], $images.shape[2]]);
    }
    const inputs = { images: batchImages };
    const attrs = { alignCorners, halfPixelCenters, size };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    const res = ENGINE.runKernel(ResizeNearestNeighbor, inputs, attrs);
    if (reshapedTo4D) {
        return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
}
op({ resizeNearestNeighbor_ });

/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Performs image binarization with corresponding threshold
 * (depends on the method)value, which creates a binary image from a grayscale.
 * @param image 3d tensor of shape [imageHeight,imageWidth, depth],
 * where imageHeight and imageWidth must be positive.The image color
 * range should be [0, 255].
 * @param method Optional string from `'binary' | 'otsu'`
 * which specifies the method for thresholding. Defaults to 'binary'.
 * @param inverted Optional boolean whichspecifies
 * if colours should be inverted. Defaults to false.
 * @param threshValue Optional number which defines threshold value from 0 to 1.
 * Defaults to 0.5.
 * @return A 3d tensor of shape [imageHeight,imageWidth, depth], which
 * contains binarized image.
 */
function threshold_(image, method = 'binary', inverted = false, threshValue = 0.5) {
    const $image = convertToTensor(image, 'image', 'threshold');
    /* 0.2989, 0.5870, 0.1140 are represent luma coefficients in CCIR601.
    Reference for converting between RGB and grayscale: https://en.wikipedia.org/wiki/Luma_%28video%29  */
    const RED_INTENCITY_COEF = 0.2989;
    const GREEN_INTENCITY_COEF = 0.5870;
    const BLUE_INTENCITY_COEF = 0.1140;
    const totalPixelsInImage = $image.shape[0] * $image.shape[1];
    let $threshold = mul(tensor1d([threshValue]), 255);
    let r, g, b, grayscale;
    assert($image.rank === 3, () => 'Error in threshold: image must be rank 3,' +
        `but got rank ${$image.rank}.`);
    assert($image.shape[2] === 3 || $image.shape[2] === 1, () => 'Error in threshold: ' +
        'image color channel must be equal to 3 or 1' +
        `but got ${$image.shape[2]}.`);
    assert($image.dtype === 'int32' || $image.dtype === 'float32', () => 'Error in dtype: image dtype must be int32 or float32,' +
        `but got dtype ${$image.dtype}.`);
    assert(method === 'otsu' || method === 'binary', () => `Method must be binary or otsu, but was ${method}`);
    if ($image.shape[2] === 3) {
        [r, g, b] = split($image, [1, 1, 1], -1);
        const $r = mul(r, RED_INTENCITY_COEF);
        const $g = mul(g, GREEN_INTENCITY_COEF);
        const $b = mul(b, BLUE_INTENCITY_COEF);
        grayscale = add(add($r, $g), $b);
    }
    else {
        grayscale = image;
    }
    if (method === 'otsu') {
        const $histogram = bincount(cast(round$1(grayscale), 'int32'), tensor([]), 256);
        $threshold = otsu($histogram, totalPixelsInImage);
    }
    const invCondition = inverted ?
        lessEqual(grayscale, $threshold) : greater(grayscale, $threshold);
    const result = cast(mul(invCondition, 255), 'int32');
    return result;
}
function otsu(histogram, total) {
    let bestThresh = tensor1d([-1]);
    let bestInBetVar = tensor1d([0]);
    let cInBetVar = tensor1d([0]);
    let classFirst, classSecond, meanFirst, meanSec, weightForeground, weightBack;
    for (let index = 0; index < histogram.size - 1; index++) {
        classFirst = slice(histogram, 0, index + 1);
        classSecond = slice(histogram, index + 1);
        weightForeground = div(sum(classFirst), total);
        weightBack = div(sum(classSecond), total);
        const meanFirstDivA = sum(mul(classFirst, range(0, classFirst.size)));
        meanFirst = div(meanFirstDivA, sum(classFirst));
        const meanSecFill = fill(classSecond.shape, classFirst.size);
        const meanSecAdd = add(range(0, classSecond.size), meanSecFill);
        const meanSecMul = mul(classSecond, (meanSecAdd));
        meanSec = div(sum(meanSecMul), sum(classSecond));
        const cInBetVarSubA = sub(meanFirst, meanSec);
        const cInBetVarSubB = sub(meanFirst, meanSec);
        const cInBetVarMul = mul(weightForeground, weightBack);
        cInBetVar = mul(mul(cInBetVarMul, cInBetVarSubA), cInBetVarSubB);
        const condition = greater(cInBetVar, bestInBetVar);
        bestInBetVar = where(condition, cInBetVar, bestInBetVar);
        bestThresh = where(condition, tensor1d([index]), bestThresh);
    }
    return bestThresh;
}
op({ threshold_ });

/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Applies the given transform(s) to the image(s).
 *
 * @param image 4d tensor of shape `[batch, imageHeight, imageWidth, depth]`.
 * @param transforms Projective transform matrix/matrices. A tensor1d of length
 *     8 or tensor of size N x 8. If one row of transforms is [a0, a1, a2, b0,
 *     b1, b2, c0, c1], then it maps the output point (x, y) to a transformed
 *     input point (x', y') = ((a0 x + a1 y + a2) / k, (b0 x + b1 y + b2) / k),
 *     where k = c0 x + c1 y + 1. The transforms are inverted compared to the
 *     transform mapping input points to output points.
 * @param interpolation Interpolation mode.
 *     Supported values: 'nearest', 'bilinear'. Default to 'nearest'.
 * @param fillMode Points outside the boundaries of the input are filled
 *     according to the given mode, one of 'constant', 'reflect', 'wrap',
 *     'nearest'. Default to 'constant'.
 *     'reflect': (d c b a | a b c d | d c b a ) The input is extended by
 *     reflecting about the edge of the last pixel.
 *     'constant': (k k k k | a b c d | k k k k) The input is extended by
 *     filling all values beyond the edge with the same constant value k.
 *     'wrap': (a b c d | a b c d | a b c d) The input is extended by
 *     wrapping around to the opposite edge.
 *     'nearest': (a a a a | a b c d | d d d d) The input is extended by
 *     the nearest pixel.
 * @param fillValue A float represents the value to be filled outside the
 *     boundaries when fillMode is 'constant'.
 * @param Output dimension after the transform, [height, width]. If undefined,
 *     output is the same size as input image.
 *
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}
 */
function transform_(image, transforms, interpolation = 'nearest', fillMode = 'constant', fillValue = 0, outputShape) {
    const $image = convertToTensor(image, 'image', 'transform', 'float32');
    const $transforms = convertToTensor(transforms, 'transforms', 'transform', 'float32');
    assert($image.rank === 4, () => 'Error in transform: image must be rank 4,' +
        `but got rank ${$image.rank}.`);
    assert($transforms.rank === 2 &&
        ($transforms.shape[0] === $image.shape[0] ||
            $transforms.shape[0] === 1) &&
        $transforms.shape[1] === 8, () => `Error in transform: Input transform should be batch x 8 or 1 x 8`);
    assert(outputShape == null || outputShape.length === 2, () => 'Error in transform: outputShape must be [height, width] or null, ' +
        `but got ${outputShape}.`);
    const inputs = { image: $image, transforms: $transforms };
    const attrs = { interpolation, fillMode, fillValue, outputShape };
    return ENGINE.runKernel(Transform, inputs, attrs);
}
op({ transform_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Copy a tensor setting everything outside a central band in each innermost
 * matrix to zero.
 *
 * The band part is computed as follows: Assume input has `k` dimensions
 * `[I, J, K, ..., M, N]`, then the output is a tensor with the same shape where
 * `band[i, j, k, ..., m, n] = in_band(m, n) * input[i, j, k, ..., m, n]`.
 * The indicator function
 * `in_band(m, n) = (num_lower < 0 || (m-n) <= num_lower)`
 * `&& (num_upper < 0 || (n-m) <= num_upper)`
 *
 * ```js
 * const x = tf.tensor2d([[ 0,  1,  2, 3],
 *                        [-1,  0,  1, 2],
 *                        [-2, -1,  0, 1],
 *                        [-3, -2, -1, 0]]);
 * let y = tf.linalg.bandPart(x, 1, -1);
 * y.print(); // [[ 0,  1,  2, 3],
 *            //  [-1,  0,  1, 2],
 *            //  [ 0, -1,  0, 1],
 *            //  [ 0, 0 , -1, 0]]
 * let z = tf.linalg.bandPart(x, 2, 1);
 * z.print(); // [[ 0,  1,  0, 0],
 *            //  [-1,  0,  1, 0],
 *            //  [-2, -1,  0, 1],
 *            //  [ 0, -2, -1, 0]]
 * ```
 *
 * @param x Rank `k` tensor
 * @param numLower Number of subdiagonals to keep.
 *   If negative, keep entire lower triangle.
 * @param numUpper Number of subdiagonals to keep.
 *   If negative, keep entire upper triangle.
 * @returns Rank `k` tensor of the same shape as input.
 *   The extracted banded tensor.
 *
 * @doc {heading:'Operations', subheading:'Linear Algebra', namespace:'linalg'}
 */
function bandPart_(a, numLower, numUpper) {
    assert(numLower % 1 === 0, () => `bandPart(): numLower must be an integer, got ${numLower}.`);
    assert(numUpper % 1 === 0, () => `bandPart(): numUpper must be an integer, got ${numUpper}.`);
    const $a = convertToTensor(a, 'a', 'bandPart');
    assert($a.rank >= 2, () => `bandPart(): Rank must be at least 2, got ${$a.rank}.`);
    const shape = $a.shape;
    const [M, N] = $a.shape.slice(-2);
    if (!(numLower <= M)) {
        throw new Error(`bandPart(): numLower (${numLower})` +
            ` must not be greater than the number of rows (${M}).`);
    }
    if (!(numUpper <= N)) {
        throw new Error(`bandPart(): numUpper (${numUpper})` +
            ` must not be greater than the number of columns (${N}).`);
    }
    if (numLower < 0) {
        numLower = M;
    }
    if (numUpper < 0) {
        numUpper = N;
    }
    const i = reshape(range(0, M, 1, 'int32'), [-1, 1]);
    const j = range(0, N, 1, 'int32');
    const ij = sub(i, j);
    const inBand = logicalAnd(lessEqual(ij, scalar(+numLower, 'int32')), greaterEqual(ij, scalar(-numUpper, 'int32')));
    const zero = zeros([M, N], $a.dtype);
    return reshape(stack(unstack(reshape($a, [-1, M, N]))
        .map(mat => where(inBand, mat, zero))), shape);
}
op({ bandPart_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Gram-Schmidt orthogonalization.
 *
 * ```js
 * const x = tf.tensor2d([[1, 2], [3, 4]]);
 * let y = tf.linalg.gramSchmidt(x);
 * y.print();
 * console.log('Orthogonalized:');
 * y.dot(y.transpose()).print();  // should be nearly the identity matrix.
 * console.log('First row direction maintained:');
 * const data = await y.array();
 * console.log(data[0][1] / data[0][0]);  // should be nearly 2.
 * ```
 *
 * @param xs The vectors to be orthogonalized, in one of the two following
 *   formats:
 *   - An Array of `tf.Tensor1D`.
 *   - A `tf.Tensor2D`, i.e., a matrix, in which case the vectors are the rows
 *     of `xs`.
 *   In each case, all the vectors must have the same length and the length
 *   must be greater than or equal to the number of vectors.
 * @returns The orthogonalized and normalized vectors or matrix.
 *   Orthogonalization means that the vectors or the rows of the matrix
 *   are orthogonal (zero inner products). Normalization means that each
 *   vector or each row of the matrix has an L2 norm that equals `1`.
 *
 * @doc {heading:'Operations', subheading:'Linear Algebra', namespace:'linalg'}
 */
function gramSchmidt_(xs) {
    let inputIsTensor2D;
    if (Array.isArray(xs)) {
        inputIsTensor2D = false;
        assert(xs != null && xs.length > 0, () => 'Gram-Schmidt process: input must not be null, undefined, or ' +
            'empty');
        const dim = xs[0].shape[0];
        for (let i = 1; i < xs.length; ++i) {
            assert(xs[i].shape[0] === dim, () => 'Gram-Schmidt: Non-unique lengths found in the input vectors: ' +
                `(${xs[i].shape[0]} vs. ${dim})`);
        }
    }
    else {
        inputIsTensor2D = true;
        xs = split(xs, xs.shape[0], 0).map(x => squeeze(x, [0]));
    }
    assert(xs.length <= xs[0].shape[0], () => `Gram-Schmidt: Number of vectors (${xs.length}) exceeds ` +
        `number of dimensions (${xs[0].shape[0]}).`);
    const ys = [];
    const xs1d = xs;
    for (let i = 0; i < xs.length; ++i) {
        ys.push(ENGINE.tidy(() => {
            let x = xs1d[i];
            if (i > 0) {
                for (let j = 0; j < i; ++j) {
                    const proj = mul(sum(mul(ys[j], x)), ys[j]);
                    x = sub(x, proj);
                }
            }
            return div(x, norm(x, 'euclidean'));
        }));
    }
    if (inputIsTensor2D) {
        return stack(ys, 0);
    }
    else {
        return ys;
    }
}
op({ gramSchmidt_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Compute QR decomposition of m-by-n matrix using Householder transformation.
 *
 * Implementation based on
 *   [http://www.cs.cornell.edu/~bindel/class/cs6210-f09/lec18.pdf]
 * (http://www.cs.cornell.edu/~bindel/class/cs6210-f09/lec18.pdf)
 *
 * ```js
 * const a = tf.tensor2d([[1, 2], [3, 4]]);
 * let [q, r] = tf.linalg.qr(a);
 * console.log('Q');
 * q.print();
 * console.log('R');
 * r.print();
 * console.log('Orthogonalized');
 * q.dot(q.transpose()).print()  // should be nearly the identity matrix.
 * console.log('Reconstructed');
 * q.dot(r).print(); // should be nearly [[1, 2], [3, 4]];
 * ```
 *
 * @param x The `tf.Tensor` to be QR-decomposed. Must have rank >= 2. Suppose
 *   it has the shape `[..., M, N]`.
 * @param fullMatrices An optional boolean parameter. Defaults to `false`.
 *   If `true`, compute full-sized `Q`. If `false` (the default),
 *   compute only the leading N columns of `Q` and `R`.
 * @returns An `Array` of two `tf.Tensor`s: `[Q, R]`. `Q` is a unitary matrix,
 *   i.e., its columns all have unit norm and are mutually orthogonal.
 *   If `M >= N`,
 *     If `fullMatrices` is `false` (default),
 *       - `Q` has a shape of `[..., M, N]`,
 *       - `R` has a shape of `[..., N, N]`.
 *     If `fullMatrices` is `true` (default),
 *       - `Q` has a shape of `[..., M, M]`,
 *       - `R` has a shape of `[..., M, N]`.
 *   If `M < N`,
 *     - `Q` has a shape of `[..., M, M]`,
 *     - `R` has a shape of `[..., M, N]`.
 * @throws If the rank of `x` is less than 2.
 *
 * @doc {heading:'Operations',
 *       subheading:'Linear Algebra',
 *       namespace:'linalg'}
 */
function qr_(x, fullMatrices = false) {
    assert(x.rank >= 2, () => `qr() requires input tensor to have a rank >= 2, but got rank ${x.rank}`);
    if (x.rank === 2) {
        return qr2d(x, fullMatrices);
    }
    else {
        // Rank > 2.
        // TODO(cais): Below we split the input into individual 2D tensors,
        //   perform QR decomposition on them and then stack the results back
        //   together. We should explore whether this can be parallelized.
        const outerDimsProd = x.shape.slice(0, x.shape.length - 2)
            .reduce((value, prev) => value * prev);
        const x2ds = unstack(reshape(x, [
            outerDimsProd, x.shape[x.shape.length - 2],
            x.shape[x.shape.length - 1]
        ]), 0);
        const q2ds = [];
        const r2ds = [];
        x2ds.forEach(x2d => {
            const [q2d, r2d] = qr2d(x2d, fullMatrices);
            q2ds.push(q2d);
            r2ds.push(r2d);
        });
        const q = reshape(stack(q2ds, 0), x.shape);
        const r = reshape(stack(r2ds, 0), x.shape);
        return [q, r];
    }
}
function qr2d(x, fullMatrices = false) {
    return ENGINE.tidy(() => {
        assert(x.shape.length === 2, () => `qr2d() requires a 2D Tensor, but got a ${x.shape.length}D Tensor.`);
        const m = x.shape[0];
        const n = x.shape[1];
        let q = eye(m); // Orthogonal transform so far.
        let r = clone(x); // Transformed matrix so far.
        const one2D = tensor2d([[1]], [1, 1]);
        let w = clone(one2D);
        const iters = m >= n ? n : m;
        for (let j = 0; j < iters; ++j) {
            // This tidy within the for-loop ensures we clean up temporary
            // tensors as soon as they are no longer needed.
            const rTemp = r;
            const wTemp = w;
            const qTemp = q;
            [w, r, q] = ENGINE.tidy(() => {
                // Find H = I - tau * w * w', to put zeros below R(j, j).
                const rjEnd1 = slice(r, [j, j], [m - j, 1]);
                const normX = norm(rjEnd1);
                const rjj = slice(r, [j, j], [1, 1]);
                // The sign() function returns 0 on 0, which causes division by zero.
                const s = where(greater(rjj, 0), tensor2d([[-1]]), tensor2d([[1]]));
                const u1 = sub(rjj, mul(s, normX));
                const wPre = div(rjEnd1, u1);
                if (wPre.shape[0] === 1) {
                    w = clone(one2D);
                }
                else {
                    w = concat([
                        one2D,
                        slice(wPre, [1, 0], [wPre.shape[0] - 1, wPre.shape[1]])
                    ], 0);
                }
                const tau = neg(div(matMul(s, u1), normX));
                // -- R := HR, Q := QH.
                const rjEndAll = slice(r, [j, 0], [m - j, n]);
                const tauTimesW = mul(tau, w);
                const wT = transpose(w);
                if (j === 0) {
                    r = sub(rjEndAll, matMul(tauTimesW, matMul(wT, rjEndAll)));
                }
                else {
                    const rTimesTau = sub(rjEndAll, matMul(tauTimesW, matMul(wT, rjEndAll)));
                    r = concat([slice(r, [0, 0], [j, n]), rTimesTau], 0);
                }
                const tawTimesWT = transpose(tauTimesW);
                const qAllJEnd = slice(q, [0, j], [m, q.shape[1] - j]);
                if (j === 0) {
                    q = sub(qAllJEnd, matMul(matMul(qAllJEnd, w), tawTimesWT));
                }
                else {
                    const qTimesTau = sub(qAllJEnd, matMul(matMul(qAllJEnd, w), tawTimesWT));
                    q = concat([slice(q, [0, 0], [m, j]), qTimesTau], 1);
                }
                return [w, r, q];
            });
            dispose([rTemp, wTemp, qTemp]);
        }
        if (!fullMatrices && m > n) {
            q = slice(q, [0, 0], [m, n]);
            r = slice(r, [0, 0], [n, n]);
        }
        return [q, r];
    });
}
op({ qr_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var Reduction;
(function (Reduction) {
    Reduction[Reduction["NONE"] = 0] = "NONE";
    Reduction[Reduction["MEAN"] = 1] = "MEAN";
    Reduction[Reduction["SUM"] = 2] = "SUM";
    Reduction[Reduction["SUM_BY_NONZERO_WEIGHTS"] = 3] = "SUM_BY_NONZERO_WEIGHTS";
})(Reduction || (Reduction = {}));

/**
 * Computes the weighted loss between two tensors.
 *
 * @param losses Tensor of shape `[batch_size, d1, ..., dN]`.
 * @param weights Tensor whose rank is either 0, or the same rank as
 *    `losses`, and must be broadcastable to `losses` (i.e., all
 *    dimensions must be either `1`, or the same as the corresponding
 *    `losses` dimension).
 *
 * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}
 */
function computeWeightedLoss_(losses, weights, reduction = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    const $losses = convertToTensor(losses, 'losses', 'computeWeightedLoss');
    let $weights = null;
    if (weights != null) {
        $weights = convertToTensor(weights, 'weights', 'computeWeightedLoss');
    }
    const weightedLoss = ($weights == null) ? $losses : mul($losses, $weights);
    if (reduction === Reduction.NONE) {
        return weightedLoss;
    }
    if (reduction === Reduction.SUM) {
        return sum(weightedLoss);
    }
    if (reduction === Reduction.MEAN) {
        if ($weights == null) {
            return mean(weightedLoss);
        }
        else {
            const broadcastFactor = $losses.size / $weights.size;
            const result = div(sum(weightedLoss), sum($weights));
            return broadcastFactor > 1 ? div(result, scalar(broadcastFactor)) :
                result;
        }
    }
    if (reduction === Reduction.SUM_BY_NONZERO_WEIGHTS) {
        if ($weights == null) {
            return div(sum(weightedLoss), scalar($losses.size));
        }
        else {
            const broadcastedWeights = mul($weights, ones($losses.shape));
            const numNonZeros = cast(sum(notEqual(broadcastedWeights, scalar(0))), 'float32');
            return div(sum(weightedLoss), numNonZeros);
        }
    }
    throw Error(`Unknown reduction: ${reduction}`);
}
const computeWeightedLoss = op({ computeWeightedLoss_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the absolute difference loss between two tensors.
 *
 * @param labels The ground truth output tensor, same dimensions as
 *    'predictions'.
 * @param predictions The predicted outputs.
 * @param weights Tensor whose rank is either 0, or the same rank as
 *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions
 *    must be either `1`, or the same as the corresponding `losses`
 *    dimension).
 * @param reduction Type of reduction to apply to loss. Should be of type
 *    `Reduction`
 *
 * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}
 */
function absoluteDifference_(labels, predictions, weights, reduction = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    const $labels = convertToTensor(labels, 'labels', 'absoluteDifference');
    const $predictions = convertToTensor(predictions, 'predictions', 'absoluteDifference');
    let $weights = null;
    if (weights != null) {
        $weights = convertToTensor(weights, 'weights', 'absoluteDifference');
    }
    assertShapesMatch($labels.shape, $predictions.shape, 'Error in absoluteDifference: ');
    const losses = abs(sub($labels, $predictions));
    return computeWeightedLoss(losses, $weights, reduction);
}
op({ absoluteDifference_ });

/**
 * Computes the cosine distance loss between two tensors.
 *
 * @param labels The ground truth output tensor, same dimensions as
 *    'predictions'.
 * @param predictions The predicted outputs.
 * @param axis The dimension along which the cosine distance is computed.
 * @param weights Tensor whose rank is either 0, or the same rank as
 *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions
 *    must be either `1`, or the same as the corresponding `losses`
 *    dimension).
 * @param reduction Type of reduction to apply to loss. Should be of type
 *    `Reduction`
 *
 * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}
 */
function cosineDistance_(labels, predictions, axis, weights, reduction = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    const $labels = convertToTensor(labels, 'labels', 'cosineDistance');
    const $predictions = convertToTensor(predictions, 'predictions', 'cosineDistance');
    let $weights = null;
    if (weights != null) {
        $weights = convertToTensor(weights, 'weights', 'cosineDistance');
    }
    assertShapesMatch($labels.shape, $predictions.shape, 'Error in cosineDistance: ');
    const one = scalar(1);
    const losses = sub(one, sum(mul($labels, $predictions), axis, true));
    return computeWeightedLoss(losses, $weights, reduction);
}
op({ cosineDistance_ });

/**
 * Computes the Hinge loss between two tensors.
 *
 * @param labels The ground truth output tensor, same dimensions as
 *    'predictions'.
 * @param predictions The predicted outputs.
 * @param weights Tensor whose rank is either 0, or the same rank as
 *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions
 *    must be either `1`, or the same as the corresponding `losses`
 *    dimension).
 * @param reduction Type of reduction to apply to loss. Should be of type
 *    `Reduction`
 *
 * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}
 */
function hingeLoss_(labels, predictions, weights, reduction = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    let $labels = convertToTensor(labels, 'labels', 'hingeLoss');
    const $predictions = convertToTensor(predictions, 'predictions', 'hingeLoss');
    let $weights = null;
    if (weights != null) {
        $weights = convertToTensor(weights, 'weights', 'hingeLoss');
    }
    assertShapesMatch($labels.shape, $predictions.shape, 'Error in hingeLoss: ');
    const one = scalar(1);
    // Convert binary labels to (-1, 1)
    $labels = sub(mul(scalar(2), $labels), one);
    const losses = relu(sub(one, mul($labels, $predictions)));
    return computeWeightedLoss(losses, $weights, reduction);
}
op({ hingeLoss_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the Huber loss between two tensors.
 *
 * @param labels The ground truth output tensor, same dimensions as
 *    'predictions'.
 * @param predictions The predicted outputs.
 * @param weights Tensor whose rank is either 0, or the same rank as
 *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions
 *    must be either `1`, or the same as the corresponding `losses`
 *    dimension).
 * @param delta Point where Huber loss changes from quadratic to linear.
 * @param reduction Type of reduction to apply to loss. Should be of type
 *    `Reduction`.
 *
 * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}
 */
function huberLoss_(labels, predictions, weights, delta = 1.0, reduction = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    const $labels = convertToTensor(labels, 'labels', 'huberLoss');
    const $predictions = convertToTensor(predictions, 'predictions', 'huberLoss');
    let $weights = null;
    if (weights != null) {
        $weights = convertToTensor(weights, 'weights', 'huberLoss');
    }
    assertShapesMatch($labels.shape, $predictions.shape, 'Error in huberLoss: ');
    const deltaScalar = scalar(delta);
    const error = abs(sub($predictions, $labels));
    const quadratic = minimum(error, deltaScalar);
    const linear = sub(error, quadratic);
    const losses = add(mul(scalar(0.5), square(quadratic)), mul(deltaScalar, linear));
    return computeWeightedLoss(losses, $weights, reduction);
}
op({ huberLoss_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the log loss between two tensors.
 *
 * @param labels The ground truth output tensor, same dimensions as
 *    'predictions'.
 * @param predictions The predicted outputs.
 * @param weights Tensor whose rank is either 0, or the same rank as
 *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions
 *    must be either `1`, or the same as the corresponding `losses`
 *    dimension).
 * @param epsilon A small increment to avoid taking log of zero
 * @param reduction Type of reduction to apply to loss. Should be of type
 *    `Reduction`
 *
 * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}
 */
function logLoss_(labels, predictions, weights, epsilon = 1e-7, reduction = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    const $labels = convertToTensor(labels, 'labels', 'logLoss');
    const $predictions = convertToTensor(predictions, 'predictions', 'logLoss');
    let $weights = null;
    if (weights != null) {
        $weights = convertToTensor(weights, 'weights', 'logLoss');
    }
    assertShapesMatch($labels.shape, $predictions.shape, 'Error in logLoss: ');
    const one = scalar(1);
    const epsilonScalar = scalar(epsilon);
    const l1 = neg(mul($labels, log(add($predictions, epsilonScalar))));
    const l2 = mul(sub(one, $labels), log(add(sub(one, $predictions), epsilonScalar)));
    const losses = sub(l1, l2);
    return computeWeightedLoss(losses, $weights, reduction);
}
op({ logLoss_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the mean squared error between two tensors.
 *
 * @param labels The ground truth output tensor, same dimensions as
 *    'predictions'.
 * @param predictions The predicted outputs.
 * @param weights Tensor whose rank is either 0, or the same rank as
 *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions
 *    must be either `1`, or the same as the corresponding `losses`
 *    dimension).
 * @param reduction Type of reduction to apply to loss. Should be of type
 *    `Reduction`
 *
 * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}
 */
function meanSquaredError_(labels, predictions, weights, reduction = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    const $labels = convertToTensor(labels, 'labels', 'meanSquaredError');
    const $predictions = convertToTensor(predictions, 'predictions', 'meanSquaredError');
    let $weights = null;
    if (weights != null) {
        $weights = convertToTensor(weights, 'weights', 'meanSquaredError');
    }
    assertShapesMatch($labels.shape, $predictions.shape, 'Error in meanSquaredError: ');
    const losses = squaredDifference($labels, $predictions);
    return computeWeightedLoss(losses, $weights, reduction);
}
op({ meanSquaredError_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sigmoidCrossEntropyWithLogits_(labels, logits) {
    const $labels = convertToTensor(labels, 'labels', 'sigmoidCrossEntropyWithLogits');
    const $logits = convertToTensor(logits, 'logits', 'sigmoidCrossEntropyWithLogits');
    assertShapesMatch($labels.shape, $logits.shape, 'Error in sigmoidCrossEntropyWithLogits: ');
    /**
     * Implementation Details:
     *
     * For brevity, let `x = logits`, `z = labels`.  The logistic loss is
     *     z * -log(sigmoid(x)) + (1 - z) * -log(1 - sigmoid(x))
     *   = z * -log(1 / (1 + exp(-x))) + (1 - z) * -log(exp(-x) / (1 + exp(-x)))
     *   = z * log(1 + exp(-x)) + (1 - z) * (-log(exp(-x)) + log(1 + exp(-x)))
     *   = z * log(1 + exp(-x)) + (1 - z) * (x + log(1 + exp(-x))
     *   = (1 - z) * x + log(1 + exp(-x))
     *   = x - x * z + log(1 + exp(-x))
     *
     *   For x < 0, to avoid overflow in exp(-x), we reformulate the above
     *     x - x * z + log(1 + exp(-x))
     *   = log(exp(x)) - x * z + log(1 + exp(-x))
     *   = - x * z + log(1 + exp(x))
     *
     * Hence, to ensure stability and avoid overflow, the implementation uses
     * this equivalent formulation:
     *     max(x, 0) - x * z + log(1 + exp(-abs(x)))
     */
    const maxOutput = relu($logits);
    const outputXTarget = mul($logits, $labels);
    const sigmoidOutput = log1p(exp(neg(abs($logits))));
    return add(sub(maxOutput, outputXTarget), sigmoidOutput);
}
/**
 * Computes the sigmoid cross entropy loss between two tensors.
 *
 * If labelSmoothing is nonzero, smooth the labels towards 1/2:
 *
 *   newMulticlassLabels = multiclassLabels * (1 - labelSmoothing)
 *                         + 0.5 * labelSmoothing
 *
 * @param multiClassLabels The ground truth output tensor of shape
 * [batch_size, num_classes], same dimensions as 'predictions'.
 * @param logits The predicted outputs.
 * @param weights Tensor whose rank is either 0, or the same rank as
 *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions
 *    must be either `1`, or the same as the corresponding `losses`
 *    dimension).
 * @param labelSmoothing If greater than 0, then smooth the labels.
 * @param reduction Type of reduction to apply to loss. Should be of type
 *    `Reduction`
 *
 * @doc { heading: 'Training', subheading: 'Losses', namespace: 'losses' }
 */
function sigmoidCrossEntropy_(multiClassLabels, logits, weights, labelSmoothing = 0, reduction = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    let $multiClassLabels = convertToTensor(multiClassLabels, 'multiClassLabels', 'sigmoidCrossEntropy');
    const $logits = convertToTensor(logits, 'logits', 'sigmoidCrossEntropy');
    let $weights = null;
    if (weights != null) {
        $weights = convertToTensor(weights, 'weights', 'sigmoidCrossEntropy');
    }
    assertShapesMatch($multiClassLabels.shape, $logits.shape, 'Error in sigmoidCrossEntropy: ');
    if (labelSmoothing > 0) {
        const labelSmoothingScalar = scalar(labelSmoothing);
        const one = scalar(1);
        const half = scalar(0.5);
        $multiClassLabels =
            add(mul($multiClassLabels, sub(one, labelSmoothingScalar)), mul(half, labelSmoothingScalar));
    }
    const losses = sigmoidCrossEntropyWithLogits_($multiClassLabels, $logits);
    return computeWeightedLoss(losses, $weights, reduction);
}
op({ sigmoidCrossEntropy_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes softmax cross entropy between logits and labels.
 *
 * Measures the probability error in discrete classification tasks in which
 * the classes are mutually exclusive (each entry is in exactly one class).
 * For example, each CIFAR-10 image is labeled with one and only one label: an
 * image can be a dog or a truck, but not both.
 *
 * `NOTE`: While the classes are mutually exclusive, their probabilities need
 * not be. All that is required is that each row of labels is a valid
 * probability distribution. If they are not, the computation of the gradient
 * will be incorrect.
 *
 * `WARNING`: This op expects unscaled logits, since it performs a softmax on
 * logits internally for efficiency. Do not call this op with the output of
 * softmax, as it will produce incorrect results.
 *
 * logits and labels must have the same shape, e.g. [batch_size, num_classes]
 * and the same dtype.
 * @param labels The labels array.
 * @param logits The logits array.
 * @param dim The dimension softmax would be performed on. Defaults to `-1`
 *     which indicates the last dimension.
 */
function softmaxCrossEntropyWithLogits_(labels, logits, dim = -1) {
    if (dim === -1) {
        dim = logits.rank - 1;
    }
    if (dim !== logits.rank - 1) {
        throw Error(`Softmax cross entropy along a non-last dimension is not yet ` +
            `supported. Labels / logits was rank ${logits.rank} ` +
            `and dim was ${dim}`);
    }
    // Use a custom gradient for numerical stability.
    const customOp = customGrad((labels, logits, save) => {
        // Reference:
        //   1. http://cs231n.github.io/linear-classify/#softmax
        //   2. https://blog.feedly.com/tricks-of-the-trade-logsumexp/
        const keepDims = true;
        const lse = logSumExp(logits, [dim], keepDims);
        const logResult = sub(cast(logits, 'float32'), lse);
        save([labels, logResult]);
        const costVector = neg(mul(logResult, labels));
        const value = sum(costVector, [dim]);
        const gradFunc = (dy, saved) => {
            const [labels, logResult] = saved;
            const dyShape = expandShapeToKeepDim(dy.shape, [dim]);
            return [
                mul(reshape(dy, dyShape), sub(cast(labels, 'float32'), exp(logResult))),
                mul(reshape(dy, dyShape), sub(exp(logResult), cast(labels, 'float32'))),
            ];
        };
        return { value, gradFunc };
    });
    return customOp(labels, logits);
}
/**
 * Computes the softmax cross entropy loss between two tensors.
 *
 * If labelSmoothing is nonzero, smooth the labels towards 1/2:
 *
 *   newOnehotLabels = onehotLabels * (1 - labelSmoothing)
 *                         + labelSmoothing / numClasses
 *
 * @param onehotLabels One hot encoded labels
 *    [batch_size, num_classes], same dimensions as 'predictions'.
 * @param logits The predicted outputs.
 * @param weights Tensor whose rank is either 0, or 1, and must be
 *    broadcastable to `loss`  of shape [batch_size]
 * @param labelSmoothing If greater than 0, then smooth the labels.
 * @param reduction Type of reduction to apply to loss. Should be of type
 *    `Reduction`
 *
 * @doc { heading: 'Training', subheading: 'Losses', namespace: 'losses' }
 */
function softmaxCrossEntropy_(onehotLabels, logits, weights, labelSmoothing = 0, reduction = Reduction.SUM_BY_NONZERO_WEIGHTS) {
    let $onehotLabels = convertToTensor(onehotLabels, 'onehotLabels', 'softmaxCrossEntropy');
    const $logits = convertToTensor(logits, 'logits', 'softmaxCrossEntropy');
    let $weights = null;
    if (weights != null) {
        $weights = convertToTensor(weights, 'weights', 'softmaxCrossEntropy');
    }
    assertShapesMatch($onehotLabels.shape, $logits.shape, 'Error in softmaxCrossEntropy: ');
    if (labelSmoothing > 0) {
        const labelSmoothingScalar = scalar(labelSmoothing);
        const one = scalar(1);
        const numClasses = scalar($onehotLabels.shape[1]);
        $onehotLabels =
            add(mul($onehotLabels, sub(one, labelSmoothingScalar)), div(labelSmoothingScalar, numClasses));
    }
    const losses = softmaxCrossEntropyWithLogits_($onehotLabels, $logits);
    return computeWeightedLoss(losses, $weights, reduction);
}
op({ softmaxCrossEntropy_ });

/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * The input SparseTensor is represented via the map of inputs {`indices`,
 * `values`, `denseShape`}. The output SparseTensor has the same `denseShape`
 * but with indices `outputIndices` and values `outputValues`. This op inserts a
 * single entry for every row that doesn't have any values. The index is created
 * as `[row, 0, ..., 0]` and the inserted value is `defaultValue`.
 *
 * For example, suppose `spInput` has shape [5, 6] and non-empty values:
 * [0, 1]: a
 * [0, 3]: b
 * [2, 0]: c
 * [3, 1]: d
 *
 * Rows 1 and 4 are empty, so the output will be of shape [5, 6] with values:
 * [0, 1]: a
 * [0, 3]: b
 * [1, 0]: `defaultValue`
 * [2, 0]: c
 * [3, 1]: d
 * [4, 0]: `defaultValue`
 *
 * The output SparseTensor will be in row-major order and will have the same
 * shape as the input.
 *
 * This op also returns an indicator vector shaped [dense_shape[0]] such that
 * emptyRowIndicator[i] = True iff row i was an empty row.
 *
 * And a reverse index map vector shaped [indices.shape[0]] that is used during
 * backpropagation, reverseIndexMap[i] = outi s.t. indices[i, j] ==
 * outputIndices[outi, j] for all j
 *
 * ```js
 * const result = tf.sparse.sparseFillEmptyRows(
 *   [[0, 0], [1, 0], [1, 3], [1, 4], [3, 2], [3, 3]],
 *   [0, 10, 13, 14, 32, 33], [5, 6], -1);
 * console.log(result);
 * result['outputIndices'].print(); // [[0, 0], [1, 0], [1, 3], [1, 4],
 *                                  //  [2, 0], [3, 2], [3, 3], [4, 0]]
 * result['outputValues'].print(); // [0, 10, 13, 14,-1, 32, 33, -1]
 * result['emptyRowIndicator'].print(); // [false, false, true, false, true]
 * result['reverseIndexMap'].print(); // [0, 1, 2, 3, 5, 6]
 * ```
 * @param indices: 2-D. The indices of the sparse tensor.
 * @param values: 1-D. The values of the sparse tensor.
 * @param denseShape: 1-D. The shape of the sparse tensor.
 * @param defaultValue: 0-D. Default value to insert into location [row, 0, ...,
 *     0] for rows missing from the input sparse tensor.
 * @return A map with the following properties:
 *     - outputIndices
 *     - outputValues: 1-D. The values of the filled sparse tensor.
 *     - emptyRowIndicator: 1-D. Whether the dense row was missing in the input
 * sparse tensor.
 *     - reverseIndexMap: 1-D. A map from the input indices to the output
 * indices.
 * @doc {heading: 'Operations', subheading: 'Sparse'}
 */
function sparseFillEmptyRows_(indices, values, denseShape, defaultValue) {
    const $indices = convertToTensor(indices, 'indices', 'sparseFillEmptyRows', 'int32');
    const $values = convertToTensor(values, 'values', 'sparseFillEmptyRows');
    const $denseShape = convertToTensor(denseShape, 'denseShape', 'sparseFillEmptyRows', 'int32');
    const $defaultValue = convertToTensor(defaultValue, 'defaultValue', 'sparseFillEmptyRows', $values.dtype);
    if ($indices.rank !== 2) {
        throw new Error(`Indices should be Tensor2D but received shape
        ${$indices.shape}`);
    }
    if ($values.rank !== 1) {
        throw new Error(`Values should be Tensor1D but received shape ${$values.shape}`);
    }
    if ($denseShape.rank !== 1) {
        throw new Error(`Dense shape should be Tensor1D but received shape ${$denseShape.shape}`);
    }
    if ($defaultValue.rank !== 0) {
        throw new Error(`Default value should be a scalar but received shape ${$defaultValue.shape}`);
    }
    const inputs = {
        indices: $indices,
        values: $values,
        denseShape: $denseShape,
        defaultValue: $defaultValue
    };
    const result = ENGINE.runKernel(SparseFillEmptyRows, inputs);
    return {
        outputIndices: result[0],
        outputValues: result[1],
        emptyRowIndicator: result[2],
        reverseIndexMap: result[3]
    };
}
op({ sparseFillEmptyRows_ });

/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * This operation has the same semantics as reshape on the represented dense
 * tensor. The `inputIndices` are recomputed based on the requested `newShape`.
 * If one component of `newShape` is the special value -1, the size of that
 * dimension is computed so that the total dense size remains constant. At most
 * one component of `newShape` can be -1. The number of dense elements implied
 * by `newShape` must be the same as the number of dense elements originally
 * implied by `inputShape`. Reshaping does not affect the order of values in the
 * SparseTensor. If the input tensor has rank R_in and N non-empty values, and
 * `newShape` has length R_out, then `inputIndices` has shape [N, R_in],
 * `inputShape` has length R_in, `outputIndices` has shape [N, R_out], and
 * `outputShape` has length R_out.
 *
 * ```js
 * const result = tf.sparse.sparseReshape(
 *   [[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0], [1, 2, 3]],
 *   [2, 3, 6], [9, -1]);
 * console.log(result);
 * result['outputIndices'].print(); //[[0, 0], [0, 1], [1, 2], [4, 2], [8, 1]]
 * result['outputShape'].print(); // [9, 4]
 * ```
 * @param inputIndices: 2-D. N x R_in matrix with the indices of non-empty
 * values in a SparseTensor.
 * @param inputShape: 1-D. R_in Tensor1D with the input SparseTensor's dense
 * shape.
 * @param newShape: 1-D. R_out Tensor1D with the requested new dense shape.
 * @return A map with the following properties:
 *     - outputIndices: 2-D. N x R_out matrix with the updated indices of
 *       non-empty values in the output SparseTensor.
 *     - outputShape: 1-D. R_out vector with the full dense shape of the output
 *       SparseTensor. This is the same as newShape but with any -1 dimensions
 *        filled in.
 * @doc {heading: 'Operations', subheading: 'Sparse'}
 */
function sparseReshape_(inputIndices, inputShape, newShape) {
    const $inputIndices = convertToTensor(inputIndices, 'inputIndices', 'sparseReshape', 'int32');
    const $inputShape = convertToTensor(inputShape, 'inputShape', 'sparseReshape', 'int32');
    const $newShape = convertToTensor(newShape, 'newShape', 'sparseReshape', 'int32');
    if ($inputIndices.rank !== 2) {
        throw new Error(`Input indices should be Tensor2D but received shape
        ${$inputIndices.shape}`);
    }
    if ($inputShape.rank !== 1) {
        throw new Error(`Input shape should be Tensor1D but received shape ${$inputShape.shape}`);
    }
    if ($newShape.rank !== 1) {
        throw new Error(`New shape should be Tensor1D but received shape ${$newShape.shape}`);
    }
    const inputs = {
        inputIndices: $inputIndices,
        inputShape: $inputShape,
        newShape: $newShape
    };
    const result = ENGINE.runKernel(SparseReshape, inputs);
    return { outputIndices: result[0], outputShape: result[1] };
}
op({ sparseReshape_ });

/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the mean along sparse segments of a tensor.
 *
 * ```js
 * const c = tf.tensor2d([[1,2,3,4], [-1,-2,-3,-4], [6,7,8,9]]);
 * // Select two rows, one segment.
 * const result1 = tf.sparse.sparseSegmentMean(c,
 *                                           tf.tensor1d([0, 1], 'int32'),
 *                                           tf.tensor1d([0, 0], 'int32'));
 * result1.print(); // [[0, 0, 0, 0]]
 *
 * // Select two rows, two segments.
 * const result2 = tf.sparse.sparseSegmentMean(c,
 *                                             tf.tensor1d([0, 1], 'int32'),
 *                                             tf.tensor1d([0, 1], 'int32'));
 * result2.print(); // [[1, 2, 3, 4], [-1, -2, -3, -4]]
 *
 * // Select all rows, two segments.
 * const result3 = tf.sparse.sparseSegmentMean(c,
 *                                             tf.tensor1d([0, 1, 2], 'int32'),
 *                                             tf.tensor1d([0, 1, 1], 'int32'));
 * result3.print(); // [[1.0, 2.0, 3.0, 4.0], [2.5, 2.5, 2.5, 2.5]]
 * ```
 * @param data: A Tensor of at least one dimension with data that will be
 *     assembled in the output.
 * @param indices: A 1-D Tensor with indices into data. Has same rank as
 *     segmentIds.
 * @param segmentIds: A 1-D Tensor with indices into the output Tensor. Values
 *     should be sorted and can be repeated.
 * @return Has same shape as data, except for dimension 0 which has equal to
 *         the number of segments.
 *
 * @doc {heading: 'Operations', subheading: 'Sparse'}
 */
function sparseSegmentMean_(data, indices, segmentIds) {
    const $data = convertToTensor(data, 'data', 'sparseSegmentMean');
    const $indices = convertToTensor(indices, 'indices', 'sparseSegmentMean', 'int32');
    const $segmentIds = convertToTensor(segmentIds, 'segmentIds', 'sparseSegmentMean', 'int32');
    if ($data.rank < 1) {
        throw new Error(`Data should be at least 1 dimensional but received scalar`);
    }
    if ($indices.rank !== 1) {
        throw new Error(`Indices should be Tensor1D but received shape
          ${$indices.shape}`);
    }
    if ($segmentIds.rank !== 1) {
        throw new Error(`Segment ids should be Tensor1D but received shape
          ${$segmentIds.shape}`);
    }
    const inputs = {
        data: $data,
        indices: $indices,
        segmentIds: $segmentIds
    };
    return ENGINE.runKernel(SparseSegmentMean, inputs);
}
op({ sparseSegmentMean_ });

/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Computes the sum along sparse segments of a tensor.
 *
 * ```js
 * const c = tf.tensor2d([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]]);
 * // Select two rows, one segment.
 * const result1 = tf.sparse.sparseSegmentSum(c,
 *                                           tf.tensor1d([0, 1], 'int32'),
 *                                           tf.tensor1d([0, 0], 'int32'));
 * result1.print(); // [[0, 0, 0, 0]]
 *
 * // Select two rows, two segments.
 * const result2 = tf.sparse.sparseSegmentSum(c,
 *                                           tf.tensor1d([0, 1], 'int32'),
 *                                           tf.tensor1d([0, 1], 'int32'));
 * result2.print(); // [[1, 2, 3, 4], [-1, -2, -3, -4]]
 *
 * // Select all rows, two segments.
 * const result3 = tf.sparse.sparseSegmentSum(c,
 *                                           tf.tensor1d([0, 1, 2], 'int32'),
 *                                           tf.tensor1d([0, 0, 1], 'int32'));
 * result3.print(); // [[0, 0, 0, 0], [5, 6, 7, 8]]
 * ```
 * @param data: A Tensor of at least one dimension with data that will be
 *     assembled in the output.
 * @param indices: A 1-D Tensor with indices into data. Has same rank as
 *     segmentIds.
 * @param segmentIds: A 1-D Tensor with indices into the output Tensor. Values
 *     should be sorted and can be repeated.
 * @return Has same shape as data, except for dimension 0 which has equal to
 *         the number of segments.
 *
 * @doc {heading: 'Operations', subheading: 'Sparse'}
 */
function sparseSegmentSum_(data, indices, segmentIds) {
    const $data = convertToTensor(data, 'data', 'sparseSegmentSum');
    const $indices = convertToTensor(indices, 'indices', 'sparseSegmentSum', 'int32');
    const $segmentIds = convertToTensor(segmentIds, 'segmentIds', 'sparseSegmentSum', 'int32');
    if ($data.rank < 1) {
        throw new Error(`Data should be at least 1 dimensional but received scalar`);
    }
    if ($indices.rank !== 1) {
        throw new Error(`Indices should be Tensor1D but received shape
         ${$indices.shape}`);
    }
    if ($segmentIds.rank !== 1) {
        throw new Error(`Segment ids should be Tensor1D but received shape
         ${$segmentIds.shape}`);
    }
    const inputs = {
        data: $data,
        indices: $indices,
        segmentIds: $segmentIds
    };
    return ENGINE.runKernel(SparseSegmentSum, inputs);
}
op({ sparseSegmentSum_ });

/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Creates ngrams from ragged string data.
 *
 * This op accepts a ragged tensor with 1 ragged dimension containing only
 * strings and outputs a ragged tensor with 1 ragged dimension containing ngrams
 * of that string, joined along the innermost axis.
 *
 * ```js
 * const result = tf.string.stringNGrams(
 *   ['a', 'b', 'c', 'd'], tf.tensor1d([0, 2, 4], 'int32'),
 *   '|', [1, 2], 'LP', 'RP', -1, false);
 * result['nGrams'].print(); // ['a', 'b', 'LP|a', 'a|b', 'b|RP',
 *                           //  'c', 'd', 'LP|c', 'c|d', 'd|RP']
 * result['nGramsSplits'].print(); // [0, 5, 10]
 * ```
 * @param data: The values tensor of the ragged string tensor to make ngrams out
 *     of. Must be a 1D string tensor.
 * @param dataSplits: The splits tensor of the ragged string tensor to make
 *     ngrams out of.
 * @param separator: The string to append between elements of the token. Use ""
 *     for no separator.
 * @param nGramWidths: The sizes of the ngrams to create.
 * @param leftPad: The string to use to pad the left side of the ngram sequence.
 *     Only used if pad_width !== 0.
 * @param rightPad: The string to use to pad the right side of the ngram
 *     sequence. Only used if pad_width !== 0.
 * @param padWidth: The number of padding elements to add to each side of each
 *     sequence. Note that padding will never be greater than `nGramWidths`-1
 *     regardless of this value. If `padWidth`=-1, then add max(`nGramWidths`)-1
 *     elements.
 * @param preserveShortSequences: If true, then ensure that at least one ngram
 *     is generated for each input sequence. In particular, if an input sequence
 *     is shorter than min(ngramWidth) + 2*padWidth, then generate a single
 *     ngram containing the entire sequence. If false, then no ngrams are
 *     generated for these short input sequences.
 * @return A map with the following properties:
 *     - nGrams: The values tensor of the output ngrams ragged tensor.
 *     - nGramsSplits: The splits tensor of the output ngrams ragged tensor.
 *
 * @doc {heading: 'Operations', subheading: 'String'}
 */
function stringNGrams_(data, dataSplits, separator, nGramWidths, leftPad, rightPad, padWidth, preserveShortSequences) {
    const $data = convertToTensor(data, 'data', 'stringNGrams', 'string');
    if ($data.dtype !== 'string') {
        throw new Error('Data must be of datatype string');
    }
    if ($data.shape.length !== 1) {
        throw new Error(`Data must be a vector, saw: ${$data.shape}`);
    }
    const $dataSplits = convertToTensor(dataSplits, 'dataSplits', 'stringNGrams');
    if ($dataSplits.dtype !== 'int32') {
        throw new Error('Data splits must be of datatype int32');
    }
    const attrs = {
        separator,
        nGramWidths,
        leftPad,
        rightPad,
        padWidth,
        preserveShortSequences
    };
    const inputs = { data: $data, dataSplits: $dataSplits };
    const result = ENGINE.runKernel(StringNGrams, inputs, attrs);
    return { nGrams: result[0], nGramsSplits: result[1] };
}
op({ stringNGrams_ });

/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Split elements of `input` based on `delimiter` into a SparseTensor .
 *
 * Let N be the size of source (typically N will be the batch size). Split each
 * element of `input` based on `delimiter` and return a SparseTensor containing
 * the splitted tokens. Empty tokens are ignored if `skipEmpty` is set to True.
 *
 * `delimiter` can be empty, or a string of split characters. If `delimiter` is
 * an empty string, each element of `input` is split into individual
 * character strings. Otherwise every character of `delimiter` is a potential
 * split point.
 *
 * ```js
 * const result = tf.string.stringSplit(['hello world',  'a b c'], ' ');
 * result['indices'].print(); // [[0, 0], [0, 1], [1, 0], [1, 1], [1, 2]]
 * result['values'].print(); // ['hello', 'world', 'a', 'b', 'c']
 * result['shape'].print(); // [2, 3]
 * ```
 * @param input: 1-D. Strings to split.
 * @param delimiter: 0-D. Delimiter characters, or empty string.
 * @param skipEmpty: Optional. If true, skip the empty strings from the result.
 *     Defaults to true.
 * @return A map with the following properties:
 *     - indices: A dense matrix of int32 representing the indices of the sparse
 *       tensor.
 *     - values: A vector of strings corresponding to the splited values.
 *     - shape: a length-2 vector of int32 representing the shape of the sparse
 * tensor, where the first value is N and the second value is the maximum number
 * of tokens in a single input entry.
 *
 * @doc {heading: 'Operations', subheading: 'String'}
 */
function stringSplit_(input, delimiter, skipEmpty = true) {
    const $input = convertToTensor(input, 'input', 'stringSplit', 'string');
    const $delimiter = convertToTensor(delimiter, 'delimiter', 'stringSplit', 'string');
    if ($input.rank !== 1) {
        throw new Error(`Input should be Tensor1D but received shape ${$input.shape}`);
    }
    if ($delimiter.rank !== 0) {
        throw new Error(`Delimiter should be a scalar but received shape ${$delimiter.shape}`);
    }
    const attrs = { skipEmpty };
    const inputs = { input: $input, delimiter: $delimiter };
    const result = ENGINE.runKernel(StringSplit, inputs, attrs);
    return { indices: result[0], values: result[1], shape: result[2] };
}
op({ stringSplit_ });

/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Converts each string in the input Tensor to its hash mod by a number of
 * buckets.
 *
 * The hash function is deterministic on the content of the string within the
 * process and will never change. However, it is not suitable for cryptography.
 * This function may be used when CPU time is scarce and inputs are trusted or
 * unimportant. There is a risk of adversaries constructing inputs that all hash
 * to the same bucket.
 *
 * ```js
 * const result = tf.string.stringToHashBucketFast(
 *   ['Hello', 'TensorFlow', '2.x'], 3);
 * result.print(); // [0, 2, 2]
 * ```
 * @param input: The strings to assign a hash bucket.
 * @param numBuckets: The number of buckets.
 * @return A Tensor of the same shape as the input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'String'}
 */
function stringToHashBucketFast_(input, numBuckets) {
    const $input = convertToTensor(input, 'input', 'stringToHashBucketFast', 'string');
    const attrs = { numBuckets };
    if (numBuckets <= 0) {
        throw new Error(`Number of buckets must be at least 1`);
    }
    const inputs = { input: $input };
    return ENGINE.runKernel(StringToHashBucketFast, inputs, attrs);
}
op({ stringToHashBucketFast_ });

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
getGlobalTensorClass().prototype.norm = function (ord, axis, keepDims) {
    this.throwIfDisposed();
    return norm(this, ord, axis, keepDims);
};

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
getGlobalTensorClass().prototype.matMul = function (b, transposeA, transposeB) {
    this.throwIfDisposed();
    return matMul(this, b, transposeA, transposeB);
};

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Converts a `tf.Tensor` to a `tf.Tensor1D`.
 * @doc {heading: 'Tensors', subheading: 'Classes'}
 */
getGlobalTensorClass().prototype.as1D = function () {
    this.throwIfDisposed();
    return reshape(this, [this.size]);
};

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Converts a `tf.Tensor` to a `tf.Tensor2D`.
 *
 * @param rows Number of rows in `tf.Tensor2D`.
 * @param columns Number of columns in `tf.Tensor2D`.
 * @doc {heading: 'Tensors', subheading: 'Classes'}
 */
getGlobalTensorClass().prototype.as2D = function (rows, columns) {
    this.throwIfDisposed();
    return reshape(this, [rows, columns]);
};

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Casts a `tf.Tensor` to a specified dtype.
 *
 * @param dtype Data-type to cast the tensor to.
 *
 * @doc {heading: 'Tensors', subheading: 'Classes'}
 */
getGlobalTensorClass().prototype.asType = function (dtype) {
    this.throwIfDisposed();
    return cast(this, dtype);
};

class KNNClassifier extends Model {
    constructor({ k = 3 } = {}) {
        super();
        this.title = 'KNN classifier';
        this.serviceName = 'knn-classifier-models';
        this.classifier = new KNNClassifier$1();
        this.parameters = {
            k: new Stream(k, true),
        };
    }
    async train(dataset) {
        this.labels = isDataset(dataset)
            ? await dataset.distinct('y')
            : (this.labels = Array.from(new Set(await dataset.map(({ y }) => y).toArray())));
        const ds = isDataset(dataset) ? dataset.items() : dataset;
        if (this.labels.length < 1) {
            this.$training.set({ status: 'error' });
            throw new Error('Cannot train a kNN with no classes');
        }
        this.$training.set({ status: 'start', epochs: 1 });
        this.classifier.clearAllClasses();
        for await (const { x, y } of ds) {
            this.classifier.addExample(tensor$1(x), y);
        }
        this.$training.set({ status: 'success' });
    }
    async predict(x) {
        if (!this.classifier || !this.labels || this.labels.length < 1) {
            return { label: undefined, confidences: {} };
        }
        const { label, confidences } = await this.classifier.predictClass(tensor$1(x), this.parameters.k.get());
        return { label, confidences };
    }
    clear() {
        delete this.classifier;
    }
    async save(store, name, metadata, id = null) {
        const storedModel = await this.write(metadata);
        storedModel.name = name;
        return this.saveToDatastore(store, storedModel, id);
    }
    async load(store, idOrName) {
        const storedModel = await this.loadFromDatastore(store, idOrName);
        await this.read(storedModel);
        return storedModel;
    }
    async download(metadata) {
        const model = await this.write(metadata);
        saveBlob(JSON.stringify(model), `${model.name}.json`, 'text/plain');
    }
    async upload(...files) {
        const jsonFiles = files.filter((x) => x.name.includes('.json'));
        const model = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
                const obj = JSON.parse(reader.result);
                resolve(obj);
            };
            reader.onerror = reject;
            reader.readAsText(jsonFiles[0]);
        });
        await this.read(model);
        return model;
    }
    async write(metadata = {}) {
        if (!this.classifier)
            return null;
        const dataset = this.classifier.getClassifierDataset();
        const datasetObj = {};
        for (const key of Object.keys(dataset)) {
            const data = dataset[key].arraySync();
            datasetObj[key] = data;
        }
        const name = toKebabCase(this.title);
        return {
            name,
            files: [],
            format: 'knn-classifier',
            metadata: {
                labels: this.labels,
                data: datasetObj,
                // parameters: this.parametersSnapshot()
                ...metadata,
            },
        };
    }
    async read(s) {
        const dataset = s.metadata.data;
        if (!dataset)
            return;
        const tensorObj = {};
        for (const [key, d] of Object.entries(dataset)) {
            tensorObj[key] = tensor2d$1(d);
        }
        this.labels = s.metadata.labels;
        this.classifier.setClassifierDataset(tensorObj);
        this.$training.set({
            status: 'loaded',
        });
    }
}
__decorate([
    Catch
], KNNClassifier.prototype, "train", null);
__decorate([
    Catch
], KNNClassifier.prototype, "predict", null);

function knnClassifier(...args) {
    return new KNNClassifier(...args);
}

class MLPClassifier extends TFJSCustomClassifier {
    constructor({ layers = [64, 32], ...rest } = {}) {
        super(rest);
        this.title = 'MLPClassifier';
        this.parameters = {
            layers: new Stream(layers, true),
            ...this.parameters,
        };
    }
    buildModel(inputShape, outputShape) {
        this.model = sequential();
        for (const [i, units] of this.parameters.layers.get().entries()) {
            const layerParams = {
                units,
                activation: 'relu',
            };
            if (i === 0) {
                layerParams.inputDim = inputShape[0];
            }
            this.model.add(layers.dense(layerParams));
        }
        this.model.add(layers.dense({
            units: outputShape[0],
            activation: 'softmax',
        }));
        const optimizer = train.adam();
        this.model.compile({
            optimizer,
            loss: 'categoricalCrossentropy',
            metrics: ['accuracy'],
        });
    }
}

function mlpClassifier(...args) {
    return new MLPClassifier(...args);
}

class MLPRegressor extends TFJSCustomModel {
    constructor({ units = [64, 32], ...rest } = {}) {
        super(rest);
        this.title = 'MLPRegressor';
        this.parameters = {
            units: new Stream(units, true),
            ...this.parameters,
        };
    }
    async train(dataset, validationDataset) {
        this.transformDataset = (ds) => ds.map((instance) => ({
            xs: tensor$1(instance.x),
            ys: tensor$1(instance.y),
        }));
        super.train(dataset, validationDataset);
    }
    buildModel(inputShape, outputShape) {
        const units = this.parameters.units.get();
        this.model = sequential();
        this.model.add(layers.inputLayer({ inputShape }));
        for (const u of units) {
            this.model.add(layers.dense({
                units: u,
                activation: 'relu',
            }));
        }
        this.model.add(layers.dense({
            units: outputShape.length > 0 ? outputShape[0] : 1,
        }));
        const optimizer = train.adam();
        this.model.compile({
            optimizer,
            loss: 'meanSquaredError',
            metrics: [metrics.meanAbsoluteError],
        });
    }
    async predict(x) {
        if (!this.model)
            return null;
        return tidy$1(() => {
            const pred = this._predict(x).arraySync();
            return pred.length === 1 ? pred[0] : pred;
        });
    }
}

function mlpRegressor(...args) {
    return new MLPRegressor(...args);
}

/* src/components/mobile-net/mobile-net.view.svelte generated by Svelte v3.52.0 */

function create_else_block$e(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;

	return {
		c() {
			t0 = text$1("Using Mobilenet v");
			t1 = text$1(/*version*/ ctx[2]);
			t2 = text$1(" with alpha = ");
			t3 = text$1(/*alpha*/ ctx[3]);
			t4 = text$1(".");
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, t2, anchor);
			insert(target, t3, anchor);
			insert(target, t4, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*version*/ 4) set_data(t1, /*version*/ ctx[2]);
			if (dirty & /*alpha*/ 8) set_data(t3, /*alpha*/ ctx[3]);
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (detaching) detach(t2);
			if (detaching) detach(t3);
			if (detaching) detach(t4);
		}
	};
}

// (10:4) {#if $loading}
function create_if_block$k(ctx) {
	let t;

	return {
		c() {
			t = text$1(" ");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (8:0) <ViewContainer {title} loading={$loading}>
function create_default_slot$l(ctx) {
	let p;

	function select_block_type(ctx, dirty) {
		if (/*$loading*/ ctx[4]) return create_if_block$k;
		return create_else_block$e;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			p = element("p");
			if_block.c();
			attr(p, "class", "p-2 text-sm text-gray-600");
		},
		m(target, anchor) {
			insert(target, p, anchor);
			if_block.m(p, null);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(p, null);
				}
			}
		},
		d(detaching) {
			if (detaching) detach(p);
			if_block.d();
		}
	};
}

function create_fragment$w(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				loading: /*$loading*/ ctx[4],
				$$slots: { default: [create_default_slot$l] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];
			if (dirty & /*$loading*/ 16) viewcontainer_changes.loading = /*$loading*/ ctx[4];

			if (dirty & /*$$scope, $loading, alpha, version*/ 60) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$w($$self, $$props, $$invalidate) {
	let $loading,
		$$unsubscribe_loading = noop$1,
		$$subscribe_loading = () => ($$unsubscribe_loading(), $$unsubscribe_loading = subscribe(loading, $$value => $$invalidate(4, $loading = $$value)), loading);

	$$self.$$.on_destroy.push(() => $$unsubscribe_loading());
	let { title } = $$props;
	let { loading } = $$props;
	$$subscribe_loading();
	let { version } = $$props;
	let { alpha } = $$props;

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('loading' in $$props) $$subscribe_loading($$invalidate(1, loading = $$props.loading));
		if ('version' in $$props) $$invalidate(2, version = $$props.version);
		if ('alpha' in $$props) $$invalidate(3, alpha = $$props.alpha);
	};

	return [title, loading, version, alpha, $loading];
}

class Mobile_net_view extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$w, create_fragment$w, safe_not_equal, {
			title: 0,
			loading: 1,
			version: 2,
			alpha: 3
		});
	}
}

var _MobileNet_mobilenet;
class MobileNet extends Model {
    constructor({ version = 1, alpha = 1 } = {}) {
        super();
        this.title = 'mobileNet';
        this.parameters = {};
        this.serviceName = 'undefined';
        _MobileNet_mobilenet.set(this, void 0);
        this.$loading = new Stream(true, true);
        if (![1, 2].includes(version)) {
            throw new Error('Mobilenet version must be 1 or 2');
        }
        if (![0.25, 0.5, 0.75, 1.0].includes(alpha)) {
            throw new Error('Mobilenet alpha must be 0.25 | 0.50 | 0.75 | 1.0');
        }
        this.version = version;
        this.alpha = alpha;
        this.setup();
    }
    async setup() {
        const cachedModels = await io$1.listModels();
        const cachedMobilenet = Object.keys(cachedModels).filter((x) => x.includes('mobileNet'));
        try {
            __classPrivateFieldSet(this, _MobileNet_mobilenet, await load$1({
                modelUrl: `indexeddb://mobilenet-v${this.version}-${this.alpha}`,
                version: this.version,
                alpha: this.alpha,
            }), "f");
        }
        catch (error) {
            if (cachedMobilenet.length > 0) {
                await io$1.removeModel(cachedMobilenet[0]);
            }
            __classPrivateFieldSet(this, _MobileNet_mobilenet, await load$1({
                version: this.version,
                alpha: this.alpha,
            }), "f");
            await __classPrivateFieldGet(this, _MobileNet_mobilenet, "f").model.save(`indexeddb://mobilenet-v${this.version}-${this.alpha}`);
        }
        logger.info(`MobileNet v${this.version} loaded with alpha = ${this.alpha}`);
        this.$loading.set(false);
        this.start();
        return this;
    }
    async process(image) {
        if (!__classPrivateFieldGet(this, _MobileNet_mobilenet, "f"))
            return [];
        return tidy$1(() => {
            const x = __classPrivateFieldGet(this, _MobileNet_mobilenet, "f").infer(image, true).arraySync();
            return x[0];
        });
    }
    async predict(image) {
        if (!__classPrivateFieldGet(this, _MobileNet_mobilenet, "f")) {
            throw new Error('Mobilenet is not loaded');
        }
        const results = await __classPrivateFieldGet(this, _MobileNet_mobilenet, "f").classify(image, 5);
        return {
            label: results[0].className,
            confidences: results.reduce((x, y) => ({ ...x, [y.className]: y.probability }), {}),
        };
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Mobile_net_view({
            target: t,
            props: {
                title: this.title,
                loading: this.$loading,
                version: this.version,
                alpha: this.alpha,
            },
        });
    }
    // eslint-disable-next-line class-methods-use-this
    train() {
        throw new TrainingError('Model `MobileNet` cannot be trained');
    }
    // eslint-disable-next-line class-methods-use-this
    save() {
        throw new Error('MobileNet does not support saving');
    }
    // eslint-disable-next-line class-methods-use-this
    load() {
        throw new Error('MobileNet does not support loading');
    }
    // eslint-disable-next-line class-methods-use-this
    download() {
        throw new Error('MobileNet does not support downloading');
    }
    // eslint-disable-next-line class-methods-use-this
    upload() {
        throw new Error('MobileNet does not support uploading');
    }
}
_MobileNet_mobilenet = new WeakMap();
__decorate([
    Catch
    // eslint-disable-next-line class-methods-use-this
], MobileNet.prototype, "train", null);
__decorate([
    Catch
    // eslint-disable-next-line class-methods-use-this
], MobileNet.prototype, "save", null);
__decorate([
    Catch
    // eslint-disable-next-line class-methods-use-this
], MobileNet.prototype, "load", null);
__decorate([
    Catch
    // eslint-disable-next-line class-methods-use-this
], MobileNet.prototype, "download", null);
__decorate([
    Catch
    // eslint-disable-next-line class-methods-use-this
], MobileNet.prototype, "upload", null);

function mobileNet(...args) {
    return new MobileNet(...args);
}

/* src/components/model-parameters/ParamWrapper.svelte generated by Svelte v3.52.0 */

function create_else_block$d(ctx) {
	let input;
	let updating_value;
	let current;

	function input_value_binding(value) {
		/*input_value_binding*/ ctx[7](value);
	}

	let input_props = { type: "text" };

	if (/*$stream*/ ctx[2] !== void 0) {
		input_props.value = /*$stream*/ ctx[2];
	}

	input = new Input({ props: input_props });
	binding_callbacks.push(() => bind(input, 'value', input_value_binding));

	return {
		c() {
			create_component(input.$$.fragment);
		},
		m(target, anchor) {
			mount_component(input, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const input_changes = {};

			if (!updating_value && dirty & /*$stream*/ 4) {
				updating_value = true;
				input_changes.value = /*$stream*/ ctx[2];
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(input, detaching);
		}
	};
}

// (14:160) 
function create_if_block_3$3(ctx) {
	let numberarray;
	let updating_value;
	let current;

	function numberarray_value_binding(value) {
		/*numberarray_value_binding*/ ctx[6](value);
	}

	let numberarray_props = {};

	if (/*$stream*/ ctx[2] !== void 0) {
		numberarray_props.value = /*$stream*/ ctx[2];
	}

	numberarray = new NumberArray$1({ props: numberarray_props });
	binding_callbacks.push(() => bind(numberarray, 'value', numberarray_value_binding));

	return {
		c() {
			create_component(numberarray.$$.fragment);
		},
		m(target, anchor) {
			mount_component(numberarray, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const numberarray_changes = {};

			if (!updating_value && dirty & /*$stream*/ 4) {
				updating_value = true;
				numberarray_changes.value = /*$stream*/ ctx[2];
				add_flush_callback(() => updating_value = false);
			}

			numberarray.$set(numberarray_changes);
		},
		i(local) {
			if (current) return;
			transition_in(numberarray.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(numberarray.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(numberarray, detaching);
		}
	};
}

// (12:97) 
function create_if_block_2$6(ctx) {
	let number;
	let updating_value;
	let current;

	function number_value_binding(value) {
		/*number_value_binding*/ ctx[5](value);
	}

	let number_props = {};

	if (/*$stream*/ ctx[2] !== void 0) {
		number_props.value = /*$stream*/ ctx[2];
	}

	number = new Number_1({ props: number_props });
	binding_callbacks.push(() => bind(number, 'value', number_value_binding));

	return {
		c() {
			create_component(number.$$.fragment);
		},
		m(target, anchor) {
			mount_component(number, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const number_changes = {};

			if (!updating_value && dirty & /*$stream*/ 4) {
				updating_value = true;
				number_changes.value = /*$stream*/ ctx[2];
				add_flush_callback(() => updating_value = false);
			}

			number.$set(number_changes);
		},
		i(local) {
			if (current) return;
			transition_in(number.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(number.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(number, detaching);
		}
	};
}

// (10:99) 
function create_if_block_1$b(ctx) {
	let switch_1;
	let updating_checked;
	let current;

	function switch_1_checked_binding(value) {
		/*switch_1_checked_binding*/ ctx[4](value);
	}

	let switch_1_props = {};

	if (/*$stream*/ ctx[2] !== void 0) {
		switch_1_props.checked = /*$stream*/ ctx[2];
	}

	switch_1 = new Switch({ props: switch_1_props });
	binding_callbacks.push(() => bind(switch_1, 'checked', switch_1_checked_binding));

	return {
		c() {
			create_component(switch_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(switch_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_1_changes = {};

			if (!updating_checked && dirty & /*$stream*/ 4) {
				updating_checked = true;
				switch_1_changes.checked = /*$stream*/ ctx[2];
				add_flush_callback(() => updating_checked = false);
			}

			switch_1.$set(switch_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(switch_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(switch_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(switch_1, detaching);
		}
	};
}

// (8:2) {#if spec.type === 'menu' && Array.isArray(spec.options) && spec.options.length > 0}
function create_if_block$j(ctx) {
	let select;
	let updating_value;
	let current;

	function select_value_binding(value) {
		/*select_value_binding*/ ctx[3](value);
	}

	let select_props = { options: /*spec*/ ctx[1].options };

	if (/*$stream*/ ctx[2] !== void 0) {
		select_props.value = /*$stream*/ ctx[2];
	}

	select = new Select$2({ props: select_props });
	binding_callbacks.push(() => bind(select, 'value', select_value_binding));

	return {
		c() {
			create_component(select.$$.fragment);
		},
		m(target, anchor) {
			mount_component(select, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const select_changes = {};
			if (dirty & /*spec*/ 2) select_changes.options = /*spec*/ ctx[1].options;

			if (!updating_value && dirty & /*$stream*/ 4) {
				updating_value = true;
				select_changes.value = /*$stream*/ ctx[2];
				add_flush_callback(() => updating_value = false);
			}

			select.$set(select_changes);
		},
		i(local) {
			if (current) return;
			transition_in(select.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(select.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(select, detaching);
		}
	};
}

function create_fragment$v(ctx) {
	let div;
	let show_if;
	let show_if_1;
	let show_if_2;
	let show_if_3;
	let current_block_type_index;
	let if_block;
	let current;

	const if_block_creators = [
		create_if_block$j,
		create_if_block_1$b,
		create_if_block_2$6,
		create_if_block_3$3,
		create_else_block$d
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (dirty & /*spec*/ 2) show_if = null;
		if (dirty & /*spec, stream*/ 3) show_if_1 = null;
		if (dirty & /*spec, stream*/ 3) show_if_2 = null;
		if (dirty & /*spec, stream*/ 3) show_if_3 = null;
		if (show_if == null) show_if = !!(/*spec*/ ctx[1].type === 'menu' && Array.isArray(/*spec*/ ctx[1].options) && /*spec*/ ctx[1].options.length > 0);
		if (show_if) return 0;
		if (show_if_1 == null) show_if_1 = !!(/*spec*/ ctx[1].type === 'boolean' || /*spec*/ ctx[1].type === 'auto' && typeof /*stream*/ ctx[0].get() === 'boolean');
		if (show_if_1) return 1;
		if (show_if_2 == null) show_if_2 = !!(/*spec*/ ctx[1].type === 'number' || /*spec*/ ctx[1].type === 'auto' && typeof /*stream*/ ctx[0].get() === 'number');
		if (show_if_2) return 2;
		if (show_if_3 == null) show_if_3 = !!(/*spec*/ ctx[1].type === 'number array' || /*spec*/ ctx[1].type === 'auto' && Array.isArray(/*stream*/ ctx[0].get()) && /*stream*/ ctx[0].get().length && typeof /*stream*/ ctx[0].get()[0] === 'number');
		if (show_if_3) return 3;
		return 4;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			set_style(div, "flex-grow", "1");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_blocks[current_block_type_index].d();
		}
	};
}

function instance$v($$self, $$props, $$invalidate) {
	let $stream,
		$$unsubscribe_stream = noop$1,
		$$subscribe_stream = () => ($$unsubscribe_stream(), $$unsubscribe_stream = subscribe(stream, $$value => $$invalidate(2, $stream = $$value)), stream);

	$$self.$$.on_destroy.push(() => $$unsubscribe_stream());
	let { stream } = $$props;
	$$subscribe_stream();
	let { spec } = $$props;

	function select_value_binding(value) {
		$stream = value;
		stream.set($stream);
	}

	function switch_1_checked_binding(value) {
		$stream = value;
		stream.set($stream);
	}

	function number_value_binding(value) {
		$stream = value;
		stream.set($stream);
	}

	function numberarray_value_binding(value) {
		$stream = value;
		stream.set($stream);
	}

	function input_value_binding(value) {
		$stream = value;
		stream.set($stream);
	}

	$$self.$$set = $$props => {
		if ('stream' in $$props) $$subscribe_stream($$invalidate(0, stream = $$props.stream));
		if ('spec' in $$props) $$invalidate(1, spec = $$props.spec);
	};

	return [
		stream,
		spec,
		$stream,
		select_value_binding,
		switch_1_checked_binding,
		number_value_binding,
		numberarray_value_binding,
		input_value_binding
	];
}

class ParamWrapper extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$v, create_fragment$v, safe_not_equal, { stream: 0, spec: 1 });
	}
}

/* src/components/model-parameters/model-parameters.view.svelte generated by Svelte v3.52.0 */

function get_each_context$9(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i][0];
	child_ctx[5] = list[i][1];
	return child_ctx;
}

// (23:8) {:else}
function create_else_block$c(ctx) {
	let paramwrapper;
	let current;

	paramwrapper = new ParamWrapper({
			props: {
				stream: /*stream*/ ctx[5],
				spec: { type: 'auto' }
			}
		});

	return {
		c() {
			create_component(paramwrapper.$$.fragment);
		},
		m(target, anchor) {
			mount_component(paramwrapper, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const paramwrapper_changes = {};
			if (dirty & /*parameters*/ 2) paramwrapper_changes.stream = /*stream*/ ctx[5];
			paramwrapper.$set(paramwrapper_changes);
		},
		i(local) {
			if (current) return;
			transition_in(paramwrapper.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(paramwrapper.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(paramwrapper, detaching);
		}
	};
}

// (21:8) {#if key in config}
function create_if_block$i(ctx) {
	let paramwrapper;
	let current;

	paramwrapper = new ParamWrapper({
			props: {
				stream: /*stream*/ ctx[5],
				spec: /*config*/ ctx[2][/*key*/ ctx[4]]
			}
		});

	return {
		c() {
			create_component(paramwrapper.$$.fragment);
		},
		m(target, anchor) {
			mount_component(paramwrapper, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const paramwrapper_changes = {};
			if (dirty & /*parameters*/ 2) paramwrapper_changes.stream = /*stream*/ ctx[5];
			if (dirty & /*config, parameters*/ 6) paramwrapper_changes.spec = /*config*/ ctx[2][/*key*/ ctx[4]];
			paramwrapper.$set(paramwrapper_changes);
		},
		i(local) {
			if (current) return;
			transition_in(paramwrapper.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(paramwrapper.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(paramwrapper, detaching);
		}
	};
}

// (18:4) {#each Object.entries(parameters) as [key, stream]}
function create_each_block$9(ctx) {
	let div;
	let p;
	let t0_value = /*key*/ ctx[4] + "";
	let t0;
	let t1;
	let current_block_type_index;
	let if_block;
	let t2;
	let current;
	const if_block_creators = [create_if_block$i, create_else_block$c];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*key*/ ctx[4] in /*config*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div = element("div");
			p = element("p");
			t0 = text$1(t0_value);
			t1 = space();
			if_block.c();
			t2 = space();
			attr(p, "class", "w-32 my-2");
			attr(div, "class", "flex my-1 items-center");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, p);
			append(p, t0);
			append(div, t1);
			if_blocks[current_block_type_index].m(div, null);
			append(div, t2);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty & /*parameters*/ 2) && t0_value !== (t0_value = /*key*/ ctx[4] + "")) set_data(t0, t0_value);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, t2);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_blocks[current_block_type_index].d();
		}
	};
}

// (16:0) <ViewContainer {title}>
function create_default_slot$k(ctx) {
	let div;
	let current;
	let each_value = Object.entries(/*parameters*/ ctx[1]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "m-2");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*Object, parameters, config*/ 6) {
				each_value = Object.entries(/*parameters*/ ctx[1]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$9(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$9(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

function create_fragment$u(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				$$slots: { default: [create_default_slot$k] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];

			if (dirty & /*$$scope, parameters, config*/ 262) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$u($$self, $$props, $$invalidate) {
	let { title } = $$props;
	let { parameters } = $$props;
	let { config = {} } = $$props;
	let unSub = [];

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('parameters' in $$props) $$invalidate(1, parameters = $$props.parameters);
		if ('config' in $$props) $$invalidate(2, config = $$props.config);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*unSub, parameters*/ 10) {
			{
				for (const u of unSub) {
					u();
				}

				$$invalidate(3, unSub = Object.values(parameters).map(s => s.subscribe()));
			}
		}
	};

	return [title, parameters, config, unSub];
}

class Model_parameters_view extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$u, create_fragment$u, safe_not_equal, { title: 0, parameters: 1, config: 2 });
	}
}

var _ModelParameters_component;
class ModelParameters extends Component {
    constructor(m, config = {}) {
        super();
        this.title = 'modelParameters';
        _ModelParameters_component.set(this, void 0);
        __classPrivateFieldSet(this, _ModelParameters_component, m, "f");
        this.config = config;
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Model_parameters_view({
            target: t,
            props: {
                title: this.title,
                parameters: __classPrivateFieldGet(this, _ModelParameters_component, "f").parameters,
                config: this.config,
            },
        });
    }
}
_ModelParameters_component = new WeakMap();

function modelParameters(m, config = {}) {
    if (!m.parameters) {
        throw new Error('The argument is not a valid component with parameters');
    }
    return new ModelParameters(m, config);
}

/* src/components/number/number.view.svelte generated by Svelte v3.52.0 */

function create_default_slot$j(ctx) {
	let div1;
	let div0;
	let number;
	let updating_value;
	let current;

	function number_value_binding(value) {
		/*number_value_binding*/ ctx[5](value);
	}

	let number_props = { disabled: /*$disabled*/ ctx[4] };

	if (/*$value*/ ctx[3] !== void 0) {
		number_props.value = /*$value*/ ctx[3];
	}

	number = new Number_1({ props: number_props });
	binding_callbacks.push(() => bind(number, 'value', number_value_binding));

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			create_component(number.$$.fragment);
			attr(div0, "class", "md:flex md:items-center mb-2");
			attr(div1, "class", "w-full max-w-sm");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			mount_component(number, div0, null);
			current = true;
		},
		p(ctx, dirty) {
			const number_changes = {};
			if (dirty & /*$disabled*/ 16) number_changes.disabled = /*$disabled*/ ctx[4];

			if (!updating_value && dirty & /*$value*/ 8) {
				updating_value = true;
				number_changes.value = /*$value*/ ctx[3];
				add_flush_callback(() => updating_value = false);
			}

			number.$set(number_changes);
		},
		i(local) {
			if (current) return;
			transition_in(number.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(number.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(number);
		}
	};
}

function create_fragment$t(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				$$slots: { default: [create_default_slot$j] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];

			if (dirty & /*$$scope, $disabled, $value*/ 88) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$t($$self, $$props, $$invalidate) {
	let $value,
		$$unsubscribe_value = noop$1,
		$$subscribe_value = () => ($$unsubscribe_value(), $$unsubscribe_value = subscribe(value, $$value => $$invalidate(3, $value = $$value)), value);

	let $disabled,
		$$unsubscribe_disabled = noop$1,
		$$subscribe_disabled = () => ($$unsubscribe_disabled(), $$unsubscribe_disabled = subscribe(disabled, $$value => $$invalidate(4, $disabled = $$value)), disabled);

	$$self.$$.on_destroy.push(() => $$unsubscribe_value());
	$$self.$$.on_destroy.push(() => $$unsubscribe_disabled());
	let { title } = $$props;
	let { value } = $$props;
	$$subscribe_value();
	let { disabled } = $$props;
	$$subscribe_disabled();

	function number_value_binding(value$1) {
		$value = value$1;
		value.set($value);
	}

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('value' in $$props) $$subscribe_value($$invalidate(1, value = $$props.value));
		if ('disabled' in $$props) $$subscribe_disabled($$invalidate(2, disabled = $$props.disabled));
	};

	return [title, value, disabled, $value, $disabled, number_value_binding];
}

class Number_view extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$t, create_fragment$t, safe_not_equal, { title: 0, value: 1, disabled: 2 });
	}
}

class Number$1 extends Component {
    constructor(defaultValue) {
        super();
        this.title = 'number';
        this.$value = new Stream(0, true);
        this.$disabled = new Stream(false, true);
        if (defaultValue !== undefined) {
            this.$value.set(defaultValue);
        }
        this.start();
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Number_view({
            target: t,
            props: {
                title: this.title,
                value: this.$value,
                disabled: this.$disabled,
            },
        });
    }
}

function number(...args) {
    return new Number$1(...args);
}

/* src/components/number-array/number-array.view.svelte generated by Svelte v3.52.0 */

function create_default_slot$i(ctx) {
	let div1;
	let div0;
	let numberarray;
	let updating_value;
	let current;

	function numberarray_value_binding(value) {
		/*numberarray_value_binding*/ ctx[5](value);
	}

	let numberarray_props = { disabled: /*$disabled*/ ctx[4] };

	if (/*$value*/ ctx[3] !== void 0) {
		numberarray_props.value = /*$value*/ ctx[3];
	}

	numberarray = new NumberArray$1({ props: numberarray_props });
	binding_callbacks.push(() => bind(numberarray, 'value', numberarray_value_binding));

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			create_component(numberarray.$$.fragment);
			attr(div0, "class", "md:flex md:items-center mb-2");
			attr(div1, "class", "w-full max-w-sm");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			mount_component(numberarray, div0, null);
			current = true;
		},
		p(ctx, dirty) {
			const numberarray_changes = {};
			if (dirty & /*$disabled*/ 16) numberarray_changes.disabled = /*$disabled*/ ctx[4];

			if (!updating_value && dirty & /*$value*/ 8) {
				updating_value = true;
				numberarray_changes.value = /*$value*/ ctx[3];
				add_flush_callback(() => updating_value = false);
			}

			numberarray.$set(numberarray_changes);
		},
		i(local) {
			if (current) return;
			transition_in(numberarray.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(numberarray.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(numberarray);
		}
	};
}

function create_fragment$s(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				$$slots: { default: [create_default_slot$i] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];

			if (dirty & /*$$scope, $disabled, $value*/ 88) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$s($$self, $$props, $$invalidate) {
	let $value,
		$$unsubscribe_value = noop$1,
		$$subscribe_value = () => ($$unsubscribe_value(), $$unsubscribe_value = subscribe(value, $$value => $$invalidate(3, $value = $$value)), value);

	let $disabled,
		$$unsubscribe_disabled = noop$1,
		$$subscribe_disabled = () => ($$unsubscribe_disabled(), $$unsubscribe_disabled = subscribe(disabled, $$value => $$invalidate(4, $disabled = $$value)), disabled);

	$$self.$$.on_destroy.push(() => $$unsubscribe_value());
	$$self.$$.on_destroy.push(() => $$unsubscribe_disabled());
	let { title } = $$props;
	let { value } = $$props;
	$$subscribe_value();
	let { disabled } = $$props;
	$$subscribe_disabled();

	function numberarray_value_binding(value$1) {
		$value = value$1;
		value.set($value);
	}

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('value' in $$props) $$subscribe_value($$invalidate(1, value = $$props.value));
		if ('disabled' in $$props) $$subscribe_disabled($$invalidate(2, disabled = $$props.disabled));
	};

	return [title, value, disabled, $value, $disabled, numberarray_value_binding];
}

class Number_array_view extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$s, create_fragment$s, safe_not_equal, { title: 0, value: 1, disabled: 2 });
	}
}

class NumberArray extends Component {
    constructor(defaultValue) {
        super();
        this.title = 'number array';
        this.$value = new Stream([], true);
        this.$disabled = new Stream(false, true);
        if (defaultValue !== undefined) {
            this.$value.set(defaultValue);
        }
        this.start();
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Number_array_view({
            target: t,
            props: {
                title: this.title,
                value: this.$value,
                disabled: this.$disabled,
            },
        });
    }
}

function numberArray(...args) {
    return new NumberArray(...args);
}

/* src/components/onnx-model/onnx-model.view.svelte generated by Svelte v3.52.0 */

function create_else_block$b(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "No model loaded";
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (19:34) 
function create_if_block_1$a(ctx) {
	let p;
	let t0;
	let t1;
	let t2;

	return {
		c() {
			p = element("p");
			t0 = text$1("Model Loaded from ");
			t1 = text$1(/*source*/ ctx[2]);
			t2 = text$1(".");
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t0);
			append(p, t1);
			append(p, t2);
		},
		p(ctx, dirty) {
			if (dirty & /*source*/ 4) set_data(t1, /*source*/ ctx[2]);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (17:4) {#if status === 'loading'}
function create_if_block$h(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "Loading Model...";
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (15:0) <ViewContainer {title} loading={status === 'loading'}>
function create_default_slot$h(ctx) {
	let div;

	function select_block_type(ctx, dirty) {
		if (/*status*/ ctx[3] === 'loading') return create_if_block$h;
		if (/*status*/ ctx[3] === 'loaded') return create_if_block_1$a;
		return create_else_block$b;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			attr(div, "class", "p-2 text-sm text-gray-600");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_block.m(div, null);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			if_block.d();
		}
	};
}

function create_fragment$r(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				loading: /*status*/ ctx[3] === 'loading',
				$$slots: { default: [create_default_slot$h] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];
			if (dirty & /*status*/ 8) viewcontainer_changes.loading = /*status*/ ctx[3] === 'loading';

			if (dirty & /*$$scope, status, source*/ 268) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$r($$self, $$props, $$invalidate) {
	let status;
	let source;

	let $training,
		$$unsubscribe_training = noop$1,
		$$subscribe_training = () => ($$unsubscribe_training(), $$unsubscribe_training = subscribe(training, $$value => $$invalidate(7, $training = $$value)), training);

	$$self.$$.on_destroy.push(() => $$unsubscribe_training());
	var _a, _b, _c;
	let { title } = $$props;
	let { training } = $$props;
	$$subscribe_training();

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('training' in $$props) $$subscribe_training($$invalidate(1, training = $$props.training));
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$training*/ 128) {
			$$invalidate(3, status = $training.status);
		}

		if ($$self.$$.dirty & /*$training, _a, _b, _c*/ 240) {
			$$invalidate(2, source = !($$invalidate(4, _a = $training.data) === null || _a === void 0
			? void 0
			: _a.source)
			? 'unknown source'
			: $training.data.source === 'datastore'
				? `datastore at ${$$invalidate(5, _b = $training.data) === null || _b === void 0
					? void 0
					: _b.url}`
				: $training.data.source === 'url'
					? `url ${$$invalidate(6, _c = $training.data) === null || _c === void 0
						? void 0
						: _c.url}`
					: 'files');
		}
	};

	return [title, training, source, status, _a, _b, _c, $training];
}

class Onnx_model_view extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$r, create_fragment$r, safe_not_equal, { title: 0, training: 1 });
	}
}

var _OnnxModel_session;
function isInputType$1(t, tt) {
    return t === tt;
}
function isPredictionType$1(t, tt) {
    return t === tt;
}
class OnnxModel extends Model {
    constructor({ inputType, taskType, inputShape }) {
        super();
        this.title = 'onnx model';
        this.parameters = {};
        this.serviceName = 'onnx-models';
        this.$loading = new Stream(false, true);
        this.$ready = new Stream(false, true);
        this.modelName = '';
        this.lockLoading = Promise.resolve();
        _OnnxModel_session.set(this, void 0);
        this.inputType = inputType;
        this.taskType = taskType;
        this.inputShape = inputShape;
        this.start();
    }
    // eslint-disable-next-line class-methods-use-this
    train() {
        throw new TrainingError('Model `OnnxModel` cannot be trained');
    }
    async predict(input) {
        if (!__classPrivateFieldGet(this, _OnnxModel_session, "f") || !this.$ready.get()) {
            throw new Error('Model is not loaded');
        }
        const inputTensor = this.preprocess(input);
        const outputs = await __classPrivateFieldGet(this, _OnnxModel_session, "f").run({ [__classPrivateFieldGet(this, _OnnxModel_session, "f").inputNames[0]]: inputTensor });
        const result = await this.postprocess(outputs);
        return result;
    }
    async loadFromUrl(url) {
        this.$training.set({
            status: 'loading',
        });
        this.$ready.set(false);
        this.$loading.set(true);
        try {
            await this.loadModel(url, url);
            this.$training.set({
                status: 'loaded',
                data: {
                    source: 'url',
                    url,
                },
            });
            this.$loading.set(false);
            this.$ready.set(true);
        }
        catch (error) {
            this.$training.set({
                status: 'error',
            });
            this.$loading.set(false);
            throw error;
        }
    }
    async loadFromFile(file) {
        if (!file)
            return;
        this.$training.set({
            status: 'loading',
        });
        this.$ready.set(false);
        this.$loading.set(true);
        try {
            const buffer = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function onload() {
                    const arrayBuffer = this.result;
                    resolve(arrayBuffer);
                };
                reader.onerror = function onerror() {
                    reject();
                };
                reader.readAsArrayBuffer(file);
            });
            await this.loadModel(buffer, file.name);
            this.$training.set({
                status: 'loaded',
                data: {
                    source: 'file',
                },
            });
            this.$loading.set(false);
            this.$ready.set(true);
        }
        catch (error) {
            this.$training.set({
                status: 'error',
            });
            this.$loading.set(false);
            throw error;
        }
    }
    async loadModel(source, modelName) {
        this.ready = false;
        this.lockLoading = this.lockLoading
            .then(() => ort.InferenceSession.create(source))
            .then((session) => {
            __classPrivateFieldSet(this, _OnnxModel_session, session, "f");
        });
        await this.lockLoading;
        this.modelName = modelName;
        try {
            await this.warmup();
        }
        catch (error) {
            // eslint-disable-next-line no-console
            console.log('ONNX Model warmup failed', error);
        }
        this.ready = true;
    }
    preprocess(input) {
        if (isInputType$1(this.inputType, 'image')) {
            return this.preprocessImage(input);
        }
        if (isInputType$1(this.inputType, 'generic')) {
            const flatInput = input.flat().flat().flat().flat().flat();
            return new ort.Tensor('float32', Float32Array.from(flatInput), this.inputShape);
        }
        throw new Error('Invalid input data type');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    preprocessImage(img) {
        throw new Error('ONNX for Images: Not yet implemented');
        // See: https://github.com/marcellejs/marcelle/blob/dc9f5183f6d8fefdc869748d22ec81a3310e4f04/src/components/onnx-model/onnx-model.component.ts
    }
    async postprocess(outputs) {
        if (isPredictionType$1(this.taskType, 'classification')) {
            // throw new Error('Classifier is not yet implemented');
            const getLabel = this.labels
                ? (index) => this.labels[index]
                : (index) => index.toString();
            const confidences = Array.from(outputs.probabilities.data).reduce((x, y, i) => ({ ...x, [getLabel(i)]: y }), {});
            return {
                label: getLabel(outputs.label.data[0]),
                confidences,
            };
        }
        if (isPredictionType$1(this.taskType, 'generic')) {
            const res = {};
            for (const name of __classPrivateFieldGet(this, _OnnxModel_session, "f").outputNames) {
                res[name] = Array.from(outputs[name].data);
            }
            return res;
        }
        throw new Error('Invalid output data type');
    }
    async warmup() {
        const data = Float32Array.from(Array(this.inputShape.reduce((a, b) => a * b, 1)), () => Math.random());
        const warmupTensor = new ort.Tensor('float32', data, this.inputShape);
        await __classPrivateFieldGet(this, _OnnxModel_session, "f").run({ [__classPrivateFieldGet(this, _OnnxModel_session, "f").inputNames[0]]: warmupTensor });
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Onnx_model_view({
            target: t,
            props: {
                title: this.title,
                training: this.$training,
            },
        });
    }
    // eslint-disable-next-line class-methods-use-this
    save() {
        throw new Error('OnnxModel does not support saving');
    }
    // eslint-disable-next-line class-methods-use-this
    load() {
        throw new Error('OnnxModel does not support loading');
    }
    // eslint-disable-next-line class-methods-use-this
    download() {
        throw new Error('OnnxModel does not support downloading');
    }
    // eslint-disable-next-line class-methods-use-this
    upload() {
        throw new Error('OnnxModel does not support uploading');
    }
}
_OnnxModel_session = new WeakMap();
__decorate([
    Catch
    // eslint-disable-next-line class-methods-use-this
], OnnxModel.prototype, "train", null);
__decorate([
    Catch
], OnnxModel.prototype, "predict", null);
__decorate([
    Catch
], OnnxModel.prototype, "loadFromUrl", null);
__decorate([
    Catch
], OnnxModel.prototype, "loadFromFile", null);
__decorate([
    Catch
], OnnxModel.prototype, "loadModel", null);
__decorate([
    Catch
], OnnxModel.prototype, "preprocess", null);
__decorate([
    Catch
], OnnxModel.prototype, "postprocess", null);
__decorate([
    Catch
    // eslint-disable-next-line class-methods-use-this
], OnnxModel.prototype, "save", null);
__decorate([
    Catch
    // eslint-disable-next-line class-methods-use-this
], OnnxModel.prototype, "load", null);
__decorate([
    Catch
    // eslint-disable-next-line class-methods-use-this
], OnnxModel.prototype, "download", null);
__decorate([
    Catch
    // eslint-disable-next-line class-methods-use-this
], OnnxModel.prototype, "upload", null);

function onnxModel(options) {
    return new OnnxModel(options);
}

class PCA extends Model {
    constructor() {
        super(...arguments);
        this.title = 'PCA';
        this.serviceName = 'pca';
        this.parameters = {};
    }
    async train(dataset) {
        this.$training.set({ status: 'start', epochs: -1 });
        const items = isDataset(dataset) ? dataset.items() : dataset;
        const instances = await items.toArray();
        const pcaData = instances.reduce((d, { x }) => d.concat([x]), []);
        this.model = new PCA$1(pcaData);
        this.$training.set({
            status: 'success',
            data: {
                explainedVariance: this.model.getExplainedVariance(),
            },
        });
    }
    async predict(x) {
        if (!this.model)
            return null;
        return this.model.predict([x]).to2DArray()[0].slice(0, 2);
    }
    clear() {
        this.model = null;
    }
    async save(store, name, metadata, id = null) {
        const storedModel = await this.write(metadata);
        storedModel.name = name;
        return this.saveToDatastore(store, storedModel, id);
    }
    async load(store, id) {
        const storedModel = await this.loadFromDatastore(store, id);
        await this.read(storedModel);
        return storedModel;
    }
    async download(metadata) {
        const model = await this.write(metadata);
        saveBlob(JSON.stringify(model), `${model.name}.json`, 'text/plain');
    }
    async upload(...files) {
        const jsonFiles = files.filter((x) => x.name.includes('.json'));
        const model = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
                const obj = JSON.parse(reader.result);
                resolve(obj);
            };
            reader.onerror = reject;
            reader.readAsText(jsonFiles[0]);
        });
        await this.read(model);
        return model;
    }
    async write(metadata = {}) {
        var _a;
        const name = toKebabCase(this.title);
        return {
            name,
            files: [],
            format: 'ml-pca',
            metadata: {
                IPCAModel: (_a = this.model) === null || _a === void 0 ? void 0 : _a.toJSON(),
                ...metadata,
            },
        };
    }
    async read(s) {
        const m = s.metadata.IPCAModel;
        if (!m)
            return;
        this.model = PCA$1.load(m);
        this.$training.set({
            status: 'loaded',
        });
    }
}

function pca(...args) {
    return new PCA(...args);
}

const scoreThresholds = {
    MoveNet: 0.35,
    PoseNet: 0.5,
    BlazePose: 0.65,
};
const COLOR_PALETTE = [
    '#ffffff',
    '#800000',
    '#469990',
    '#e6194b',
    '#42d4f4',
    '#fabed4',
    '#aaffc3',
    '#9a6324',
    '#000075',
    '#f58231',
    '#4363d8',
    '#ffd8b1',
    '#dcbeff',
    '#808000',
    '#ffe119',
    '#911eb4',
    '#bfef45',
    '#f032e6',
    '#3cb44b',
    '#a9a9a9', // #a9a9a9 - Silver Chalice
];
class SkeletonRenderer {
    constructor(model, width) {
        this.model = model;
        this.width = width;
        this.params = {
            lineWidth: 2,
            radius: 4,
            scoreThreshold: scoreThresholds[model],
        };
        this.canvas = document.createElement('canvas');
        this.canvas.width = this.width;
        this.canvas.height = this.width;
        this.ctx = this.canvas.getContext('2d');
    }
    drawKeypoint(keypoint) {
        // If score is null, just show the keypoint.
        const score = keypoint.score != null ? keypoint.score : 1;
        // const scoreThreshold = params.STATE.modelConfig.scoreThreshold || 0;
        if (score >= this.params.scoreThreshold) {
            const circle = new Path2D();
            circle.arc(keypoint.x, keypoint.y, this.params.radius, 0, 2 * Math.PI);
            this.ctx.fill(circle);
            this.ctx.stroke(circle);
        }
    }
    /**
     * Draw the keypoints on the video.
     * @param keypoints A list of keypoints.
     */
    drawKeypoints(keypoints) {
        const keypointInd = util.getKeypointIndexBySide(this.model);
        this.ctx.fillStyle = 'Red';
        this.ctx.strokeStyle = 'White';
        this.ctx.lineWidth = this.params.lineWidth;
        for (const i of keypointInd.middle) {
            this.drawKeypoint(keypoints[i]);
        }
        this.ctx.fillStyle = 'Green';
        for (const i of keypointInd.left) {
            this.drawKeypoint(keypoints[i]);
        }
        this.ctx.fillStyle = 'Orange';
        for (const i of keypointInd.right) {
            this.drawKeypoint(keypoints[i]);
        }
    }
    /**
     * Draw the skeleton of a body on the video.
     * @param keypoints A list of keypoints.
     */
    drawSkeleton(keypoints, poseId) {
        // Each poseId is mapped to a color in the color palette.
        const color = 
        //params.STATE.modelConfig.enableTracking &&
        poseId != null ? COLOR_PALETTE[poseId % 20] : 'White';
        this.ctx.fillStyle = color;
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = this.params.lineWidth;
        util.getAdjacentPairs(this.model).forEach(([i, j]) => {
            const kp1 = keypoints[i];
            const kp2 = keypoints[j];
            // If score is null, just show the keypoint.
            const score1 = kp1.score != null ? kp1.score : 1;
            const score2 = kp2.score != null ? kp2.score : 1;
            const scoreThreshold = this.params.scoreThreshold || 0;
            if (score1 >= scoreThreshold && score2 >= scoreThreshold) {
                this.ctx.beginPath();
                this.ctx.moveTo(kp1.x, kp1.y);
                this.ctx.lineTo(kp2.x, kp2.y);
                this.ctx.stroke();
            }
        });
    }
    // drawKeypoints3D(keypoints: Pose['keypoints3D']) {
    //   const pointsData = keypoints.map((keypoint) => [-keypoint.x, -keypoint.y, -keypoint.z]);
    //   const dataset = new scatter.ScatterGL.Dataset([...pointsData, ...ANCHOR_POINTS]);
    //   const keypointInd = util.getKeypointIndexBySide(model);
    //   this.scatterGL.setPointColorer((i) => {
    //     if (keypoints[i] == null || keypoints[i].score < params.scoreThreshold) {
    //       // hide anchor points and low-confident points.
    //       return '#ffffff';
    //     }
    //     if (i === 0) {
    //       return '#ff0000' /* Red */;
    //     }
    //     if (keypointInd.left.indexOf(i) > -1) {
    //       return '#00ff00' /* Green */;
    //     }
    //     if (keypointInd.right.indexOf(i) > -1) {
    //       return '#ffa500' /* Orange */;
    //     }
    //   });
    //   if (!this.scatterGLHasInitialized) {
    //     this.scatterGL.render(dataset);
    //   } else {
    //     this.scatterGL.updateDataset(dataset);
    //   }
    //   const connections = util.getAdjacentPairs(model);
    //   const sequences = connections.map((pair) => ({ indices: pair }));
    //   this.scatterGL.setSequences(sequences);
    //   this.scatterGLHasInitialized = true;
    // }
    drawResult(pose) {
        if (pose.keypoints != null) {
            this.drawKeypoints(pose.keypoints);
            this.drawSkeleton(pose.keypoints, pose.id);
        }
        if (pose.keypoints3D != null // && params.STATE.modelConfig.render3D
        // TODO: 3D as option?
        ) {
            // drawKeypoints3D(pose.keypoints3D);
            throw new Error('Keypoints 3D is not Implemented...');
        }
    }
    drawResults(poseList) {
        for (const pose of poseList) {
            this.drawResult(pose);
        }
    }
    drawImage(img) {
        this.ctx.clearRect(0, 0, img.width, img.width);
        this.canvas.height = img.height;
        this.canvas.width = img.width;
        this.ctx.putImageData(img, 0, 0);
    }
    render(img, poseList, format = 'ImageData') {
        this.drawImage(img);
        this.drawResults(poseList);
        if (format === 'ImageData')
            return this.ctx.getImageData(0, 0, this.width, this.width);
        return this.canvas.toDataURL('image/jpeg');
    }
}

/* src/components/pose-detection/pose-detection.view.svelte generated by Svelte v3.52.0 */

function create_else_block$a(ctx) {
	let t0;
	let t1;
	let t2;

	return {
		c() {
			t0 = text$1("Using ");
			t1 = text$1(/*model*/ ctx[2]);
			t2 = text$1(" pose detector.");
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, t2, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*model*/ 4) set_data(t1, /*model*/ ctx[2]);
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (detaching) detach(t2);
		}
	};
}

// (9:4) {#if $loading}
function create_if_block$g(ctx) {
	let t;

	return {
		c() {
			t = text$1(" ");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (7:0) <ViewContainer {title} loading={$loading}>
function create_default_slot$g(ctx) {
	let p;

	function select_block_type(ctx, dirty) {
		if (/*$loading*/ ctx[3]) return create_if_block$g;
		return create_else_block$a;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			p = element("p");
			if_block.c();
			attr(p, "class", "p-2 text-sm text-gray-600");
		},
		m(target, anchor) {
			insert(target, p, anchor);
			if_block.m(p, null);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(p, null);
				}
			}
		},
		d(detaching) {
			if (detaching) detach(p);
			if_block.d();
		}
	};
}

function create_fragment$q(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				loading: /*$loading*/ ctx[3],
				$$slots: { default: [create_default_slot$g] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];
			if (dirty & /*$loading*/ 8) viewcontainer_changes.loading = /*$loading*/ ctx[3];

			if (dirty & /*$$scope, $loading, model*/ 28) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$q($$self, $$props, $$invalidate) {
	let $loading,
		$$unsubscribe_loading = noop$1,
		$$subscribe_loading = () => ($$unsubscribe_loading(), $$unsubscribe_loading = subscribe(loading, $$value => $$invalidate(3, $loading = $$value)), loading);

	$$self.$$.on_destroy.push(() => $$unsubscribe_loading());
	let { title } = $$props;
	let { loading } = $$props;
	$$subscribe_loading();
	let { model } = $$props;

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('loading' in $$props) $$subscribe_loading($$invalidate(1, loading = $$props.loading));
		if ('model' in $$props) $$invalidate(2, model = $$props.model);
	};

	return [title, loading, model, $loading];
}

class Pose_detection_view extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$q, create_fragment$q, safe_not_equal, { title: 0, loading: 1, model: 2 });
	}
}

var _PoseDetection_detector, _PoseDetection_fullRenderer, _PoseDetection_thumbnailRenderer;
class PoseDetection extends Model {
    constructor(model = 'MoveNet', modelConfig) {
        super();
        this.model = model;
        this.modelConfig = modelConfig;
        this.title = 'Pose Detection';
        this.parameters = {};
        this.serviceName = 'undefined';
        _PoseDetection_detector.set(this, void 0);
        this.$loading = new Stream(true, true);
        this.$bodyParts = new Stream('Full body', false);
        _PoseDetection_fullRenderer.set(this, void 0);
        _PoseDetection_thumbnailRenderer.set(this, void 0);
        __classPrivateFieldSet(this, _PoseDetection_fullRenderer, new SkeletonRenderer(SupportedModels[model], 224), "f");
        __classPrivateFieldSet(this, _PoseDetection_thumbnailRenderer, new SkeletonRenderer(SupportedModels[model], 60), "f");
        this.start();
        this.setup(model, modelConfig);
    }
    async setup(model, modelConfig) {
        __classPrivateFieldSet(this, _PoseDetection_detector, await createDetector(SupportedModels[model], modelConfig), "f");
        logger.info(`${model} loaded`);
        this.$loading.set(false);
        this.start();
    }
    async predict(image) {
        if (!__classPrivateFieldGet(this, _PoseDetection_detector, "f")) {
            logger.error('Movenet is not loaded');
            return [];
        }
        const results = await __classPrivateFieldGet(this, _PoseDetection_detector, "f").estimatePoses(image);
        return results;
    }
    postprocess(poses, indices) {
        const filt = indices && Array.isArray(indices) && indices.length > 0
            ? (_, i) => indices.includes(i)
            : () => true;
        return poses
            .map((pose) => {
            const nose = pose.keypoints[0];
            return pose.keypoints
                .filter(filt)
                .reduce((res, x) => [...res, (x.x - nose.x) / 100, (x.y - nose.y) / 100], []);
        })
            .reduce((res, x) => [...res, ...x], []);
    }
    thumbnail(img, result) {
        return __classPrivateFieldGet(this, _PoseDetection_thumbnailRenderer, "f").render(img, result, 'dataURL');
    }
    render(img, result) {
        return __classPrivateFieldGet(this, _PoseDetection_fullRenderer, "f").render(img, result);
    }
    // https://colab.research.google.com/drive/19txHpN8exWhstO6WVkfmYYVC6uug_oVR#scrollTo=0L6HLFd9AXmh
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Pose_detection_view({
            target: t,
            props: {
                title: this.title,
                loading: this.$loading,
                model: this.model,
            },
        });
    }
    // eslint-disable-next-line class-methods-use-this
    train() {
        throw new TrainingError('Model `MobileNet` cannot be trained');
    }
    // eslint-disable-next-line class-methods-use-this
    save() {
        throw new Error('MobileNet does not support saving');
    }
    // eslint-disable-next-line class-methods-use-this
    load() {
        throw new Error('MobileNet does not support loading');
    }
    // eslint-disable-next-line class-methods-use-this
    download() {
        throw new Error('MobileNet does not support downloading');
    }
    // eslint-disable-next-line class-methods-use-this
    upload() {
        throw new Error('MobileNet does not support uploading');
    }
}
_PoseDetection_detector = new WeakMap(), _PoseDetection_fullRenderer = new WeakMap(), _PoseDetection_thumbnailRenderer = new WeakMap();
__decorate([
    Catch
    // eslint-disable-next-line class-methods-use-this
], PoseDetection.prototype, "train", null);
__decorate([
    Catch
    // eslint-disable-next-line class-methods-use-this
], PoseDetection.prototype, "save", null);
__decorate([
    Catch
    // eslint-disable-next-line class-methods-use-this
], PoseDetection.prototype, "load", null);
__decorate([
    Catch
    // eslint-disable-next-line class-methods-use-this
], PoseDetection.prototype, "download", null);
__decorate([
    Catch
    // eslint-disable-next-line class-methods-use-this
], PoseDetection.prototype, "upload", null);

function poseDetection(...args) {
    return new PoseDetection(...args);
}

/* src/components/scatter-plot/scatter-plot.view.svelte generated by Svelte v3.52.0 */

function create_default_slot$f(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "id", "scatter-container");
			attr(div, "class", "svelte-f0tf1i");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			/*div_binding*/ ctx[4](div);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(div);
			/*div_binding*/ ctx[4](null);
		}
	};
}

function create_fragment$p(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				$$slots: { default: [create_default_slot$f] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];

			if (dirty & /*$$scope, scatterContainer*/ 66) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$p($$self, $$props, $$invalidate) {
	let { title } = $$props;
	let { embedding } = $$props;
	let { labels } = $$props;
	let scatterContainer;
	let scatterGL;

	onMount(() => {
		// scatter GL object
		const containerElement = document.getElementById('scatter-container');

		scatterGL = new ScatterGL(containerElement,
		{
				styles: {
					point: {
						scaleDefault: 1.6,
						scaleSelected: 2,
						scaleHover: 2
					}
				}
			});

		// behavior when data are changing
		embedding.subscribe(points => {
			if (points.length > 0) {
				let labs = [];

				if (labels === undefined || labels.get().length === 0) {
					labs = new Array(points.length).fill(0);
				} else {
					labs = labels.get();
				}

				const dataset = new ScatterGL.Dataset(points);
				scatterGL.render(dataset);
				const classIndices = Array.from(new Set(labs));
				const hues = [...new Array(classIndices.length)].map((_, i) => Math.floor(255 / classIndices.length * i));
				const lightTransparentColorsByLabel = hues.map(hue => `hsla(${hue}, 100%, 50%, 0.1)`);
				const heavyTransparentColorsByLabel = hues.map(hue => `hsla(${hue}, 100%, 50%, 0.75)`);
				const opaqueColorsByLabel = hues.map(hue => `hsla(${hue}, 100%, 50%, 1)`);

				scatterGL.setPointColorer((index, selectedIndices, hoverIndex) => {
					if (selectedIndices.size > 0) {
						if (!selectedIndices.has(index)) {
							return lightTransparentColorsByLabel[classIndices.indexOf(labs[index])];
						}

						return opaqueColorsByLabel[classIndices.indexOf(labs[index])];
					}

					if (index === hoverIndex) {
						return opaqueColorsByLabel[classIndices.indexOf(labs[index])];
					}

					return heavyTransparentColorsByLabel[classIndices.indexOf(labs[index])];
				});
			}
		});

		// behavior when labels are changing
		labels.subscribe(labs => {
			const classIndices = Array.from(new Set(labs));
			const hues = [...new Array(classIndices.length)].map((_, i) => Math.floor(255 / classIndices.length * i));
			const lightTransparentColorsByLabel = hues.map(hue => `hsla(${hue}, 100%, 50%, 0.1)`);
			const heavyTransparentColorsByLabel = hues.map(hue => `hsla(${hue}, 100%, 50%, 0.75)`);
			const opaqueColorsByLabel = hues.map(hue => `hsla(${hue}, 100%, 50%, 1)`);

			scatterGL.setPointColorer((index, selectedIndices, hoverIndex) => {
				if (selectedIndices.size > 0) {
					if (!selectedIndices.has(index)) {
						return lightTransparentColorsByLabel[classIndices.indexOf(labs[index])];
					}

					return opaqueColorsByLabel[classIndices.indexOf(labs[index])];
				}

				if (index === hoverIndex) {
					return opaqueColorsByLabel[classIndices.indexOf(labs[index])];
				}

				return heavyTransparentColorsByLabel[classIndices.indexOf(labs[index])];
			});
		});
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			scatterContainer = $$value;
			$$invalidate(1, scatterContainer);
		});
	}

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('embedding' in $$props) $$invalidate(2, embedding = $$props.embedding);
		if ('labels' in $$props) $$invalidate(3, labels = $$props.labels);
	};

	return [title, scatterContainer, embedding, labels, div_binding];
}

class Scatter_plot_view extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$p, create_fragment$p, safe_not_equal, { title: 0, embedding: 2, labels: 3 });
	}

	get title() {
		return this.$$.ctx[0];
	}

	set title(title) {
		this.$$set({ title });
		flush();
	}

	get embedding() {
		return this.$$.ctx[2];
	}

	set embedding(embedding) {
		this.$$set({ embedding });
		flush();
	}

	get labels() {
		return this.$$.ctx[3];
	}

	set labels(labels) {
		this.$$set({ labels });
		flush();
	}
}

class ScatterPlot extends Component {
    constructor(dataset, labels) {
        super();
        this.title = 'Scatter plot';
        this.$data = dataset.hold();
        this.$labels = labels.hold();
        this.start();
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Scatter_plot_view({
            target: t,
            props: {
                title: this.title,
                embedding: this.$data,
                labels: this.$labels,
            },
        });
    }
}

function scatterPlot(...args) {
    return new ScatterPlot(...args);
}

/* src/components/select/select.view.svelte generated by Svelte v3.52.0 */

function create_default_slot$e(ctx) {
	let select;
	let current;

	select = new Select$2({
			props: {
				options: /*$options*/ ctx[3],
				value: /*$value*/ ctx[4]
			}
		});

	select.$on("change", /*updateStream*/ ctx[5]);

	return {
		c() {
			create_component(select.$$.fragment);
		},
		m(target, anchor) {
			mount_component(select, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const select_changes = {};
			if (dirty & /*$options*/ 8) select_changes.options = /*$options*/ ctx[3];
			if (dirty & /*$value*/ 16) select_changes.value = /*$value*/ ctx[4];
			select.$set(select_changes);
		},
		i(local) {
			if (current) return;
			transition_in(select.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(select.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(select, detaching);
		}
	};
}

function create_fragment$o(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				$$slots: { default: [create_default_slot$e] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];

			if (dirty & /*$$scope, $options, $value*/ 88) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$o($$self, $$props, $$invalidate) {
	let $options,
		$$unsubscribe_options = noop$1,
		$$subscribe_options = () => ($$unsubscribe_options(), $$unsubscribe_options = subscribe(options, $$value => $$invalidate(3, $options = $$value)), options);

	let $value,
		$$unsubscribe_value = noop$1,
		$$subscribe_value = () => ($$unsubscribe_value(), $$unsubscribe_value = subscribe(value, $$value => $$invalidate(4, $value = $$value)), value);

	$$self.$$.on_destroy.push(() => $$unsubscribe_options());
	$$self.$$.on_destroy.push(() => $$unsubscribe_value());
	let { title } = $$props;
	let { options } = $$props;
	$$subscribe_options();
	let { value } = $$props;
	$$subscribe_value();

	function updateStream({ detail }) {
		value.set(detail);
	}

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('options' in $$props) $$subscribe_options($$invalidate(1, options = $$props.options));
		if ('value' in $$props) $$subscribe_value($$invalidate(2, value = $$props.value));
	};

	return [title, options, value, $options, $value, updateStream];
}

class Select_view extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$o, create_fragment$o, safe_not_equal, { title: 0, options: 1, value: 2 });
	}
}

class Select extends Component {
    constructor(options, value) {
        super();
        this.title = 'select';
        this.$options = new Stream(options, true);
        this.$value = new Stream(value !== undefined ? value : options[0], true);
        this.start();
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Select_view({
            target: t,
            props: {
                title: this.title,
                options: this.$options,
                value: this.$value,
            },
        });
    }
}

function select(...args) {
    return new Select(...args);
}

/* src/components/sketch-pad/sketch-pad.view.svelte generated by Svelte v3.52.0 */

const { document: document_1 } = globals;

function create_default_slot_1$7(ctx) {
	let t;

	return {
		c() {
			t = text$1("Clear");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (63:0) <ViewContainer {title}>
function create_default_slot$d(ctx) {
	let div1;
	let canvas;
	let t;
	let div0;
	let button;
	let current;
	let mounted;
	let dispose;

	button = new Button$1({
			props: {
				size: "small",
				type: "danger",
				$$slots: { default: [create_default_slot_1$7] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*clearDrawing*/ ctx[2]);

	return {
		c() {
			div1 = element("div");
			canvas = element("canvas");
			t = space();
			div0 = element("div");
			create_component(button.$$.fragment);
			attr(canvas, "id", "fxid");
			attr(canvas, "class", "sketchpad-container svelte-1trukpy");
			attr(canvas, "width", "300");
			attr(canvas, "height", "300");
			attr(div0, "class", "m-1");
			attr(div1, "class", "w-full flex flex-col items-center box-border");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, canvas);
			/*canvas_binding*/ ctx[8](canvas);
			append(div1, t);
			append(div1, div0);
			mount_component(button, div0, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(canvas, "mousemove", /*draw*/ ctx[3]),
					listen(canvas, "mousedown", /*startDrawing*/ ctx[4])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			/*canvas_binding*/ ctx[8](null);
			destroy_component(button);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$n(ctx) {
	let t;
	let viewcontainer;
	let current;
	let mounted;
	let dispose;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				$$slots: { default: [create_default_slot$d] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			t = space();
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			insert(target, t, anchor);
			mount_component(viewcontainer, target, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(document_1.body, "mouseup", /*stopDrawing*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];

			if (dirty & /*$$scope, canvasElement*/ 16386) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(t);
			destroy_component(viewcontainer, detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$n($$self, $$props, $$invalidate) {
	let { title } = $$props;
	let { strokeStart } = $$props;
	let { strokeEnd } = $$props;
	let canvasElement;
	let isDrawing = false;
	let offset = { left: 0, top: 0 };
	let previous = { x: 0, y: 0 };
	let ctx;
	const dispatch = createEventDispatcher();

	function clearDrawing() {
		ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
		ctx.fillStyle = 'white';
		ctx.fillRect(0, 0, canvasElement.width, canvasElement.height);
		isDrawing = false;
	}

	onMount(async () => {
		await tick();
		await tick();
		ctx = canvasElement.getContext('2d');
		clearDrawing();
		dispatch('canvasElement', canvasElement);
	});

	function draw(e) {
		const x = e.clientX - offset.left;
		const y = e.clientY - offset.top;

		if (isDrawing) {
			ctx.beginPath();
			ctx.strokeStyle = 'black';
			ctx.lineWidth = 10;
			ctx.lineJoin = 'round';
			ctx.moveTo(previous.x, previous.y);
			ctx.lineTo(x, y);
			ctx.closePath();
			ctx.stroke();
		}

		previous.x = x;
		previous.y = y;
	}

	function startDrawing(e) {
		const rect = canvasElement.getBoundingClientRect();

		offset = {
			top: rect.top + document.body.scrollTop,
			left: rect.left + document.body.scrollLeft
		};

		draw(e);
		strokeStart.set();
		isDrawing = true;
	}

	function stopDrawing() {
		if (isDrawing) {
			strokeEnd.set();
		}

		isDrawing = false;
	}

	function canvas_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			canvasElement = $$value;
			$$invalidate(1, canvasElement);
		});
	}

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('strokeStart' in $$props) $$invalidate(6, strokeStart = $$props.strokeStart);
		if ('strokeEnd' in $$props) $$invalidate(7, strokeEnd = $$props.strokeEnd);
	};

	return [
		title,
		canvasElement,
		clearDrawing,
		draw,
		startDrawing,
		stopDrawing,
		strokeStart,
		strokeEnd,
		canvas_binding
	];
}

class Sketch_pad_view extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$n, create_fragment$n, safe_not_equal, { title: 0, strokeStart: 6, strokeEnd: 7 });
	}
}

var _SketchPad_thumbnailWidth, _SketchPad_thumbnailCanvas, _SketchPad_thumbnailCtx, _SketchPad_sketchCtx;
class SketchPad extends Component {
    constructor() {
        super();
        this.title = 'sketchPad';
        this.$images = new Stream(never());
        this.$thumbnails = new Stream(never());
        this.$strokeStart = new Stream(never());
        this.$strokeEnd = new Stream(never());
        _SketchPad_thumbnailWidth.set(this, 60);
        _SketchPad_thumbnailCanvas.set(this, void 0);
        _SketchPad_thumbnailCtx.set(this, void 0);
        _SketchPad_sketchCtx.set(this, void 0);
        this.setupCapture();
        this.$strokeEnd.subscribe(() => {
            this.capture();
        });
        this.start();
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Sketch_pad_view({
            target: t,
            props: {
                title: this.title,
                strokeStart: this.$strokeStart,
                strokeEnd: this.$strokeEnd,
            },
        });
        this.$$.app.$on('canvasElement', (e) => {
            this.sketchElement = e.detail;
            __classPrivateFieldSet(this, _SketchPad_sketchCtx, this.sketchElement.getContext('2d'), "f");
        });
    }
    setupCapture() {
        __classPrivateFieldSet(this, _SketchPad_thumbnailCanvas, document.createElement('canvas'), "f");
        __classPrivateFieldGet(this, _SketchPad_thumbnailCanvas, "f").width = __classPrivateFieldGet(this, _SketchPad_thumbnailWidth, "f");
        __classPrivateFieldGet(this, _SketchPad_thumbnailCanvas, "f").height = __classPrivateFieldGet(this, _SketchPad_thumbnailWidth, "f");
        __classPrivateFieldSet(this, _SketchPad_thumbnailCtx, __classPrivateFieldGet(this, _SketchPad_thumbnailCanvas, "f").getContext('2d'), "f");
    }
    capture() {
        const t = this.captureThumbnail();
        this.$thumbnails.set(t);
        this.$images.set(this.captureImage());
    }
    captureThumbnail() {
        __classPrivateFieldGet(this, _SketchPad_thumbnailCtx, "f").drawImage(this.sketchElement, 0, 0, __classPrivateFieldGet(this, _SketchPad_thumbnailCanvas, "f").width, __classPrivateFieldGet(this, _SketchPad_thumbnailCanvas, "f").height);
        return __classPrivateFieldGet(this, _SketchPad_thumbnailCanvas, "f").toDataURL('image/jpeg');
    }
    captureImage() {
        return __classPrivateFieldGet(this, _SketchPad_sketchCtx, "f").getImageData(0, 0, this.sketchElement.width, this.sketchElement.height);
    }
}
_SketchPad_thumbnailWidth = new WeakMap(), _SketchPad_thumbnailCanvas = new WeakMap(), _SketchPad_thumbnailCtx = new WeakMap(), _SketchPad_sketchCtx = new WeakMap();

function sketchPad(...args) {
    return new SketchPad(...args);
}

function is_date(obj) {
    return Object.prototype.toString.call(obj) === '[object Date]';
}

function tick_spring(ctx, last_value, current_value, target_value) {
    if (typeof current_value === 'number' || is_date(current_value)) {
        // @ts-ignore
        const delta = target_value - current_value;
        // @ts-ignore
        const velocity = (current_value - last_value) / (ctx.dt || 1 / 60); // guard div by 0
        const spring = ctx.opts.stiffness * delta;
        const damper = ctx.opts.damping * velocity;
        const acceleration = (spring - damper) * ctx.inv_mass;
        const d = (velocity + acceleration) * ctx.dt;
        if (Math.abs(d) < ctx.opts.precision && Math.abs(delta) < ctx.opts.precision) {
            return target_value; // settled
        }
        else {
            ctx.settled = false; // signal loop to keep ticking
            // @ts-ignore
            return is_date(current_value) ?
                new Date(current_value.getTime() + d) : current_value + d;
        }
    }
    else if (Array.isArray(current_value)) {
        // @ts-ignore
        return current_value.map((_, i) => tick_spring(ctx, last_value[i], current_value[i], target_value[i]));
    }
    else if (typeof current_value === 'object') {
        const next_value = {};
        for (const k in current_value) {
            // @ts-ignore
            next_value[k] = tick_spring(ctx, last_value[k], current_value[k], target_value[k]);
        }
        // @ts-ignore
        return next_value;
    }
    else {
        throw new Error(`Cannot spring ${typeof current_value} values`);
    }
}
function spring(value, opts = {}) {
    const store = writable(value);
    const { stiffness = 0.15, damping = 0.8, precision = 0.01 } = opts;
    let last_time;
    let task;
    let current_token;
    let last_value = value;
    let target_value = value;
    let inv_mass = 1;
    let inv_mass_recovery_rate = 0;
    let cancel_task = false;
    function set(new_value, opts = {}) {
        target_value = new_value;
        const token = current_token = {};
        if (value == null || opts.hard || (spring.stiffness >= 1 && spring.damping >= 1)) {
            cancel_task = true; // cancel any running animation
            last_time = now$1();
            last_value = new_value;
            store.set(value = target_value);
            return Promise.resolve();
        }
        else if (opts.soft) {
            const rate = opts.soft === true ? .5 : +opts.soft;
            inv_mass_recovery_rate = 1 / (rate * 60);
            inv_mass = 0; // infinite mass, unaffected by spring forces
        }
        if (!task) {
            last_time = now$1();
            cancel_task = false;
            task = loop(now => {
                if (cancel_task) {
                    cancel_task = false;
                    task = null;
                    return false;
                }
                inv_mass = Math.min(inv_mass + inv_mass_recovery_rate, 1);
                const ctx = {
                    inv_mass,
                    opts: spring,
                    settled: true,
                    dt: (now - last_time) * 60 / 1000
                };
                const next_value = tick_spring(ctx, last_value, value, target_value);
                last_time = now;
                last_value = value;
                store.set(value = next_value);
                if (ctx.settled) {
                    task = null;
                }
                return !ctx.settled;
            });
        }
        return new Promise(fulfil => {
            task.promise.then(() => {
                if (token === current_token)
                    fulfil();
            });
        });
    }
    const spring = {
        set,
        update: (fn, opts) => set(fn(target_value, value), opts),
        subscribe: store.subscribe,
        stiffness,
        damping,
        precision
    };
    return spring;
}

/* ../../node_modules/.pnpm/svelte-range-slider-pips@2.0.3/node_modules/svelte-range-slider-pips/src/RangePips.svelte generated by Svelte v3.52.0 */

function get_each_context$8(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[28] = list[i];
	child_ctx[30] = i;
	return child_ctx;
}

// (176:2) {#if ( all && first !== false ) || first }
function create_if_block_9(ctx) {
	let span;
	let span_style_value;
	let mounted;
	let dispose;
	let if_block = (/*all*/ ctx[6] === 'label' || /*first*/ ctx[7] === 'label') && create_if_block_10(ctx);

	return {
		c() {
			span = element("span");
			if (if_block) if_block.c();
			attr(span, "class", "pip first");
			attr(span, "style", span_style_value = "" + (/*orientationStart*/ ctx[14] + ": 0%;"));
			toggle_class(span, "selected", /*isSelected*/ ctx[18](/*min*/ ctx[0]));
			toggle_class(span, "in-range", /*inRange*/ ctx[17](/*min*/ ctx[0]));
		},
		m(target, anchor) {
			insert(target, span, anchor);
			if (if_block) if_block.m(span, null);

			if (!mounted) {
				dispose = [
					listen(span, "click", function () {
						if (is_function(/*labelClick*/ ctx[21](/*min*/ ctx[0]))) /*labelClick*/ ctx[21](/*min*/ ctx[0]).apply(this, arguments);
					}),
					listen(span, "touchend", prevent_default(function () {
						if (is_function(/*labelClick*/ ctx[21](/*min*/ ctx[0]))) /*labelClick*/ ctx[21](/*min*/ ctx[0]).apply(this, arguments);
					}))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*all*/ ctx[6] === 'label' || /*first*/ ctx[7] === 'label') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_10(ctx);
					if_block.c();
					if_block.m(span, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*orientationStart*/ 16384 && span_style_value !== (span_style_value = "" + (/*orientationStart*/ ctx[14] + ": 0%;"))) {
				attr(span, "style", span_style_value);
			}

			if (dirty & /*isSelected, min*/ 262145) {
				toggle_class(span, "selected", /*isSelected*/ ctx[18](/*min*/ ctx[0]));
			}

			if (dirty & /*inRange, min*/ 131073) {
				toggle_class(span, "in-range", /*inRange*/ ctx[17](/*min*/ ctx[0]));
			}
		},
		d(detaching) {
			if (detaching) detach(span);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (185:6) {#if all === 'label' || first === 'label'}
function create_if_block_10(ctx) {
	let span;
	let t_value = /*formatter*/ ctx[12](/*fixFloat*/ ctx[16](/*min*/ ctx[0]), 0, 0) + "";
	let t;
	let if_block0 = /*prefix*/ ctx[10] && create_if_block_12(ctx);
	let if_block1 = /*suffix*/ ctx[11] && create_if_block_11(ctx);

	return {
		c() {
			span = element("span");
			if (if_block0) if_block0.c();
			t = text$1(t_value);
			if (if_block1) if_block1.c();
			attr(span, "class", "pipVal");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			if (if_block0) if_block0.m(span, null);
			append(span, t);
			if (if_block1) if_block1.m(span, null);
		},
		p(ctx, dirty) {
			if (/*prefix*/ ctx[10]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_12(ctx);
					if_block0.c();
					if_block0.m(span, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*formatter, fixFloat, min*/ 69633 && t_value !== (t_value = /*formatter*/ ctx[12](/*fixFloat*/ ctx[16](/*min*/ ctx[0]), 0, 0) + "")) set_data(t, t_value);

			if (/*suffix*/ ctx[11]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_11(ctx);
					if_block1.c();
					if_block1.m(span, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) detach(span);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

// (187:10) {#if prefix}
function create_if_block_12(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text$1(/*prefix*/ ctx[10]);
			attr(span, "class", "pipVal-prefix");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*prefix*/ 1024) set_data(t, /*prefix*/ ctx[10]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (187:100) {#if suffix}
function create_if_block_11(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text$1(/*suffix*/ ctx[11]);
			attr(span, "class", "pipVal-suffix");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*suffix*/ 2048) set_data(t, /*suffix*/ ctx[11]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (193:2) {#if ( all && rest !== false ) || rest}
function create_if_block_4$1(ctx) {
	let each_1_anchor;
	let each_value = Array(/*pipCount*/ ctx[20] + 1);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*orientationStart, percentOf, pipVal, isSelected, inRange, labelClick, suffix, formatter, prefix, all, rest, min, max, pipCount*/ 4120131) {
				each_value = Array(/*pipCount*/ ctx[20] + 1);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$8(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$8(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (195:6) {#if pipVal(i) !== min && pipVal(i) !== max}
function create_if_block_5(ctx) {
	let span;
	let t;
	let span_style_value;
	let mounted;
	let dispose;
	let if_block = (/*all*/ ctx[6] === 'label' || /*rest*/ ctx[9] === 'label') && create_if_block_6(ctx);

	return {
		c() {
			span = element("span");
			if (if_block) if_block.c();
			t = space();
			attr(span, "class", "pip");
			attr(span, "style", span_style_value = "" + (/*orientationStart*/ ctx[14] + ": " + /*percentOf*/ ctx[15](/*pipVal*/ ctx[19](/*i*/ ctx[30])) + "%;"));
			toggle_class(span, "selected", /*isSelected*/ ctx[18](/*pipVal*/ ctx[19](/*i*/ ctx[30])));
			toggle_class(span, "in-range", /*inRange*/ ctx[17](/*pipVal*/ ctx[19](/*i*/ ctx[30])));
		},
		m(target, anchor) {
			insert(target, span, anchor);
			if (if_block) if_block.m(span, null);
			append(span, t);

			if (!mounted) {
				dispose = [
					listen(span, "click", function () {
						if (is_function(/*labelClick*/ ctx[21](/*pipVal*/ ctx[19](/*i*/ ctx[30])))) /*labelClick*/ ctx[21](/*pipVal*/ ctx[19](/*i*/ ctx[30])).apply(this, arguments);
					}),
					listen(span, "touchend", prevent_default(function () {
						if (is_function(/*labelClick*/ ctx[21](/*pipVal*/ ctx[19](/*i*/ ctx[30])))) /*labelClick*/ ctx[21](/*pipVal*/ ctx[19](/*i*/ ctx[30])).apply(this, arguments);
					}))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*all*/ ctx[6] === 'label' || /*rest*/ ctx[9] === 'label') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_6(ctx);
					if_block.c();
					if_block.m(span, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*orientationStart, percentOf, pipVal*/ 573440 && span_style_value !== (span_style_value = "" + (/*orientationStart*/ ctx[14] + ": " + /*percentOf*/ ctx[15](/*pipVal*/ ctx[19](/*i*/ ctx[30])) + "%;"))) {
				attr(span, "style", span_style_value);
			}

			if (dirty & /*isSelected, pipVal*/ 786432) {
				toggle_class(span, "selected", /*isSelected*/ ctx[18](/*pipVal*/ ctx[19](/*i*/ ctx[30])));
			}

			if (dirty & /*inRange, pipVal*/ 655360) {
				toggle_class(span, "in-range", /*inRange*/ ctx[17](/*pipVal*/ ctx[19](/*i*/ ctx[30])));
			}
		},
		d(detaching) {
			if (detaching) detach(span);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (204:10) {#if all === 'label' || rest === 'label'}
function create_if_block_6(ctx) {
	let span;
	let t_value = /*formatter*/ ctx[12](/*pipVal*/ ctx[19](/*i*/ ctx[30]), /*i*/ ctx[30], /*percentOf*/ ctx[15](/*pipVal*/ ctx[19](/*i*/ ctx[30]))) + "";
	let t;
	let if_block0 = /*prefix*/ ctx[10] && create_if_block_8(ctx);
	let if_block1 = /*suffix*/ ctx[11] && create_if_block_7(ctx);

	return {
		c() {
			span = element("span");
			if (if_block0) if_block0.c();
			t = text$1(t_value);
			if (if_block1) if_block1.c();
			attr(span, "class", "pipVal");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			if (if_block0) if_block0.m(span, null);
			append(span, t);
			if (if_block1) if_block1.m(span, null);
		},
		p(ctx, dirty) {
			if (/*prefix*/ ctx[10]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_8(ctx);
					if_block0.c();
					if_block0.m(span, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*formatter, pipVal, percentOf*/ 561152 && t_value !== (t_value = /*formatter*/ ctx[12](/*pipVal*/ ctx[19](/*i*/ ctx[30]), /*i*/ ctx[30], /*percentOf*/ ctx[15](/*pipVal*/ ctx[19](/*i*/ ctx[30]))) + "")) set_data(t, t_value);

			if (/*suffix*/ ctx[11]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_7(ctx);
					if_block1.c();
					if_block1.m(span, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) detach(span);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

// (206:14) {#if prefix}
function create_if_block_8(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text$1(/*prefix*/ ctx[10]);
			attr(span, "class", "pipVal-prefix");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*prefix*/ 1024) set_data(t, /*prefix*/ ctx[10]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (206:119) {#if suffix}
function create_if_block_7(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text$1(/*suffix*/ ctx[11]);
			attr(span, "class", "pipVal-suffix");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*suffix*/ 2048) set_data(t, /*suffix*/ ctx[11]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (194:4) {#each Array(pipCount + 1) as _, i}
function create_each_block$8(ctx) {
	let show_if = /*pipVal*/ ctx[19](/*i*/ ctx[30]) !== /*min*/ ctx[0] && /*pipVal*/ ctx[19](/*i*/ ctx[30]) !== /*max*/ ctx[1];
	let if_block_anchor;
	let if_block = show_if && create_if_block_5(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*pipVal, min, max*/ 524291) show_if = /*pipVal*/ ctx[19](/*i*/ ctx[30]) !== /*min*/ ctx[0] && /*pipVal*/ ctx[19](/*i*/ ctx[30]) !== /*max*/ ctx[1];

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_5(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (214:2) {#if ( all && last !== false ) || last}
function create_if_block$f(ctx) {
	let span;
	let span_style_value;
	let mounted;
	let dispose;
	let if_block = (/*all*/ ctx[6] === 'label' || /*last*/ ctx[8] === 'label') && create_if_block_1$9(ctx);

	return {
		c() {
			span = element("span");
			if (if_block) if_block.c();
			attr(span, "class", "pip last");
			attr(span, "style", span_style_value = "" + (/*orientationStart*/ ctx[14] + ": 100%;"));
			toggle_class(span, "selected", /*isSelected*/ ctx[18](/*max*/ ctx[1]));
			toggle_class(span, "in-range", /*inRange*/ ctx[17](/*max*/ ctx[1]));
		},
		m(target, anchor) {
			insert(target, span, anchor);
			if (if_block) if_block.m(span, null);

			if (!mounted) {
				dispose = [
					listen(span, "click", function () {
						if (is_function(/*labelClick*/ ctx[21](/*max*/ ctx[1]))) /*labelClick*/ ctx[21](/*max*/ ctx[1]).apply(this, arguments);
					}),
					listen(span, "touchend", prevent_default(function () {
						if (is_function(/*labelClick*/ ctx[21](/*max*/ ctx[1]))) /*labelClick*/ ctx[21](/*max*/ ctx[1]).apply(this, arguments);
					}))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*all*/ ctx[6] === 'label' || /*last*/ ctx[8] === 'label') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$9(ctx);
					if_block.c();
					if_block.m(span, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*orientationStart*/ 16384 && span_style_value !== (span_style_value = "" + (/*orientationStart*/ ctx[14] + ": 100%;"))) {
				attr(span, "style", span_style_value);
			}

			if (dirty & /*isSelected, max*/ 262146) {
				toggle_class(span, "selected", /*isSelected*/ ctx[18](/*max*/ ctx[1]));
			}

			if (dirty & /*inRange, max*/ 131074) {
				toggle_class(span, "in-range", /*inRange*/ ctx[17](/*max*/ ctx[1]));
			}
		},
		d(detaching) {
			if (detaching) detach(span);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (223:6) {#if all === 'label' || last === 'label'}
function create_if_block_1$9(ctx) {
	let span;
	let t_value = /*formatter*/ ctx[12](/*fixFloat*/ ctx[16](/*max*/ ctx[1]), /*pipCount*/ ctx[20], 100) + "";
	let t;
	let if_block0 = /*prefix*/ ctx[10] && create_if_block_3$2(ctx);
	let if_block1 = /*suffix*/ ctx[11] && create_if_block_2$5(ctx);

	return {
		c() {
			span = element("span");
			if (if_block0) if_block0.c();
			t = text$1(t_value);
			if (if_block1) if_block1.c();
			attr(span, "class", "pipVal");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			if (if_block0) if_block0.m(span, null);
			append(span, t);
			if (if_block1) if_block1.m(span, null);
		},
		p(ctx, dirty) {
			if (/*prefix*/ ctx[10]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3$2(ctx);
					if_block0.c();
					if_block0.m(span, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*formatter, fixFloat, max, pipCount*/ 1118210 && t_value !== (t_value = /*formatter*/ ctx[12](/*fixFloat*/ ctx[16](/*max*/ ctx[1]), /*pipCount*/ ctx[20], 100) + "")) set_data(t, t_value);

			if (/*suffix*/ ctx[11]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2$5(ctx);
					if_block1.c();
					if_block1.m(span, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) detach(span);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

// (225:10) {#if prefix}
function create_if_block_3$2(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text$1(/*prefix*/ ctx[10]);
			attr(span, "class", "pipVal-prefix");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*prefix*/ 1024) set_data(t, /*prefix*/ ctx[10]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (225:109) {#if suffix}
function create_if_block_2$5(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text$1(/*suffix*/ ctx[11]);
			attr(span, "class", "pipVal-suffix");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*suffix*/ 2048) set_data(t, /*suffix*/ ctx[11]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

function create_fragment$m(ctx) {
	let div;
	let t0;
	let t1;
	let if_block0 = (/*all*/ ctx[6] && /*first*/ ctx[7] !== false || /*first*/ ctx[7]) && create_if_block_9(ctx);
	let if_block1 = (/*all*/ ctx[6] && /*rest*/ ctx[9] !== false || /*rest*/ ctx[9]) && create_if_block_4$1(ctx);
	let if_block2 = (/*all*/ ctx[6] && /*last*/ ctx[8] !== false || /*last*/ ctx[8]) && create_if_block$f(ctx);

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			attr(div, "class", "rangePips");
			toggle_class(div, "disabled", /*disabled*/ ctx[5]);
			toggle_class(div, "hoverable", /*hoverable*/ ctx[4]);
			toggle_class(div, "vertical", /*vertical*/ ctx[2]);
			toggle_class(div, "reversed", /*reversed*/ ctx[3]);
			toggle_class(div, "focus", /*focus*/ ctx[13]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append(div, t0);
			if (if_block1) if_block1.m(div, null);
			append(div, t1);
			if (if_block2) if_block2.m(div, null);
		},
		p(ctx, [dirty]) {
			if (/*all*/ ctx[6] && /*first*/ ctx[7] !== false || /*first*/ ctx[7]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_9(ctx);
					if_block0.c();
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*all*/ ctx[6] && /*rest*/ ctx[9] !== false || /*rest*/ ctx[9]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_4$1(ctx);
					if_block1.c();
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*all*/ ctx[6] && /*last*/ ctx[8] !== false || /*last*/ ctx[8]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block$f(ctx);
					if_block2.c();
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (dirty & /*disabled*/ 32) {
				toggle_class(div, "disabled", /*disabled*/ ctx[5]);
			}

			if (dirty & /*hoverable*/ 16) {
				toggle_class(div, "hoverable", /*hoverable*/ ctx[4]);
			}

			if (dirty & /*vertical*/ 4) {
				toggle_class(div, "vertical", /*vertical*/ ctx[2]);
			}

			if (dirty & /*reversed*/ 8) {
				toggle_class(div, "reversed", /*reversed*/ ctx[3]);
			}

			if (dirty & /*focus*/ 8192) {
				toggle_class(div, "focus", /*focus*/ ctx[13]);
			}
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
		}
	};
}

function instance$m($$self, $$props, $$invalidate) {
	let pipStep;
	let pipCount;
	let pipVal;
	let isSelected;
	let inRange;
	let { range = false } = $$props;
	let { min = 0 } = $$props;
	let { max = 100 } = $$props;
	let { step = 1 } = $$props;
	let { values = [(max + min) / 2] } = $$props;
	let { vertical = false } = $$props;
	let { reversed = false } = $$props;
	let { hoverable = true } = $$props;
	let { disabled = false } = $$props;
	let { pipstep = undefined } = $$props;
	let { all = true } = $$props;
	let { first = undefined } = $$props;
	let { last = undefined } = $$props;
	let { rest = undefined } = $$props;
	let { prefix = "" } = $$props;
	let { suffix = "" } = $$props;
	let { formatter = (v, i) => v } = $$props;
	let { focus = undefined } = $$props;
	let { orientationStart = undefined } = $$props;
	let { percentOf = undefined } = $$props;
	let { moveHandle = undefined } = $$props;
	let { fixFloat = undefined } = $$props;

	function labelClick(val) {
		if (!disabled) {
			moveHandle(undefined, val);
		}
	}

	$$self.$$set = $$props => {
		if ('range' in $$props) $$invalidate(22, range = $$props.range);
		if ('min' in $$props) $$invalidate(0, min = $$props.min);
		if ('max' in $$props) $$invalidate(1, max = $$props.max);
		if ('step' in $$props) $$invalidate(23, step = $$props.step);
		if ('values' in $$props) $$invalidate(24, values = $$props.values);
		if ('vertical' in $$props) $$invalidate(2, vertical = $$props.vertical);
		if ('reversed' in $$props) $$invalidate(3, reversed = $$props.reversed);
		if ('hoverable' in $$props) $$invalidate(4, hoverable = $$props.hoverable);
		if ('disabled' in $$props) $$invalidate(5, disabled = $$props.disabled);
		if ('pipstep' in $$props) $$invalidate(25, pipstep = $$props.pipstep);
		if ('all' in $$props) $$invalidate(6, all = $$props.all);
		if ('first' in $$props) $$invalidate(7, first = $$props.first);
		if ('last' in $$props) $$invalidate(8, last = $$props.last);
		if ('rest' in $$props) $$invalidate(9, rest = $$props.rest);
		if ('prefix' in $$props) $$invalidate(10, prefix = $$props.prefix);
		if ('suffix' in $$props) $$invalidate(11, suffix = $$props.suffix);
		if ('formatter' in $$props) $$invalidate(12, formatter = $$props.formatter);
		if ('focus' in $$props) $$invalidate(13, focus = $$props.focus);
		if ('orientationStart' in $$props) $$invalidate(14, orientationStart = $$props.orientationStart);
		if ('percentOf' in $$props) $$invalidate(15, percentOf = $$props.percentOf);
		if ('moveHandle' in $$props) $$invalidate(26, moveHandle = $$props.moveHandle);
		if ('fixFloat' in $$props) $$invalidate(16, fixFloat = $$props.fixFloat);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*pipstep, max, min, step, vertical*/ 41943047) {
			$$invalidate(27, pipStep = pipstep || ((max - min) / step >= (vertical ? 50 : 100)
			? (max - min) / (vertical ? 10 : 20)
			: 1));
		}

		if ($$self.$$.dirty & /*max, min, step, pipStep*/ 142606339) {
			$$invalidate(20, pipCount = parseInt((max - min) / (step * pipStep), 10));
		}

		if ($$self.$$.dirty & /*fixFloat, min, step, pipStep*/ 142671873) {
			$$invalidate(19, pipVal = function (val) {
				return fixFloat(min + val * step * pipStep);
			});
		}

		if ($$self.$$.dirty & /*values, fixFloat*/ 16842752) {
			$$invalidate(18, isSelected = function (val) {
				return values.some(v => fixFloat(v) === fixFloat(val));
			});
		}

		if ($$self.$$.dirty & /*range, values*/ 20971520) {
			$$invalidate(17, inRange = function (val) {
				if (range === "min") {
					return values[0] > val;
				} else if (range === "max") {
					return values[0] < val;
				} else if (range) {
					return values[0] < val && values[1] > val;
				}
			});
		}
	};

	return [
		min,
		max,
		vertical,
		reversed,
		hoverable,
		disabled,
		all,
		first,
		last,
		rest,
		prefix,
		suffix,
		formatter,
		focus,
		orientationStart,
		percentOf,
		fixFloat,
		inRange,
		isSelected,
		pipVal,
		pipCount,
		labelClick,
		range,
		step,
		values,
		pipstep,
		moveHandle,
		pipStep
	];
}

class RangePips extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$m, create_fragment$m, safe_not_equal, {
			range: 22,
			min: 0,
			max: 1,
			step: 23,
			values: 24,
			vertical: 2,
			reversed: 3,
			hoverable: 4,
			disabled: 5,
			pipstep: 25,
			all: 6,
			first: 7,
			last: 8,
			rest: 9,
			prefix: 10,
			suffix: 11,
			formatter: 12,
			focus: 13,
			orientationStart: 14,
			percentOf: 15,
			moveHandle: 26,
			fixFloat: 16
		});
	}
}

/* ../../node_modules/.pnpm/svelte-range-slider-pips@2.0.3/node_modules/svelte-range-slider-pips/src/RangeSlider.svelte generated by Svelte v3.52.0 */

function get_each_context$7(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[64] = list[i];
	child_ctx[66] = i;
	return child_ctx;
}

// (823:6) {#if float}
function create_if_block_2$4(ctx) {
	let span;
	let t_value = /*handleFormatter*/ ctx[21](/*value*/ ctx[64], /*index*/ ctx[66], /*percentOf*/ ctx[23](/*value*/ ctx[64])) + "";
	let t;
	let if_block0 = /*prefix*/ ctx[18] && create_if_block_4(ctx);
	let if_block1 = /*suffix*/ ctx[19] && create_if_block_3$1(ctx);

	return {
		c() {
			span = element("span");
			if (if_block0) if_block0.c();
			t = text$1(t_value);
			if (if_block1) if_block1.c();
			attr(span, "class", "rangeFloat");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			if (if_block0) if_block0.m(span, null);
			append(span, t);
			if (if_block1) if_block1.m(span, null);
		},
		p(ctx, dirty) {
			if (/*prefix*/ ctx[18]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					if_block0.m(span, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*handleFormatter, values, percentOf*/ 10485761 && t_value !== (t_value = /*handleFormatter*/ ctx[21](/*value*/ ctx[64], /*index*/ ctx[66], /*percentOf*/ ctx[23](/*value*/ ctx[64])) + "")) set_data(t, t_value);

			if (/*suffix*/ ctx[19]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_3$1(ctx);
					if_block1.c();
					if_block1.m(span, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) detach(span);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

// (825:10) {#if prefix}
function create_if_block_4(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text$1(/*prefix*/ ctx[18]);
			attr(span, "class", "rangeFloat-prefix");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*prefix*/ 262144) set_data(t, /*prefix*/ ctx[18]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (825:121) {#if suffix}
function create_if_block_3$1(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text$1(/*suffix*/ ctx[19]);
			attr(span, "class", "rangeFloat-suffix");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*suffix*/ 524288) set_data(t, /*suffix*/ ctx[19]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (802:2) {#each values as value, index}
function create_each_block$7(ctx) {
	let span1;
	let span0;
	let t;
	let span1_style_value;
	let span1_aria_valuemin_value;
	let span1_aria_valuemax_value;
	let span1_aria_valuenow_value;
	let span1_aria_valuetext_value;
	let span1_aria_orientation_value;
	let span1_tabindex_value;
	let mounted;
	let dispose;
	let if_block = /*float*/ ctx[7] && create_if_block_2$4(ctx);

	return {
		c() {
			span1 = element("span");
			span0 = element("span");
			t = space();
			if (if_block) if_block.c();
			attr(span0, "class", "rangeNub");
			attr(span1, "role", "slider");
			attr(span1, "class", "rangeHandle");
			attr(span1, "data-handle", /*index*/ ctx[66]);
			attr(span1, "style", span1_style_value = "" + (/*orientationStart*/ ctx[28] + ": " + /*$springPositions*/ ctx[29][/*index*/ ctx[66]] + "%; z-index: " + (/*activeHandle*/ ctx[26] === /*index*/ ctx[66] ? 3 : 2) + ";"));

			attr(span1, "aria-valuemin", span1_aria_valuemin_value = /*range*/ ctx[2] === true && /*index*/ ctx[66] === 1
			? /*values*/ ctx[0][0]
			: /*min*/ ctx[3]);

			attr(span1, "aria-valuemax", span1_aria_valuemax_value = /*range*/ ctx[2] === true && /*index*/ ctx[66] === 0
			? /*values*/ ctx[0][1]
			: /*max*/ ctx[4]);

			attr(span1, "aria-valuenow", span1_aria_valuenow_value = /*value*/ ctx[64]);
			attr(span1, "aria-valuetext", span1_aria_valuetext_value = "" + (/*prefix*/ ctx[18] + /*handleFormatter*/ ctx[21](/*value*/ ctx[64], /*index*/ ctx[66], /*percentOf*/ ctx[23](/*value*/ ctx[64])) + /*suffix*/ ctx[19]));
			attr(span1, "aria-orientation", span1_aria_orientation_value = /*vertical*/ ctx[6] ? 'vertical' : 'horizontal');
			attr(span1, "aria-disabled", /*disabled*/ ctx[10]);
			attr(span1, "disabled", /*disabled*/ ctx[10]);
			attr(span1, "tabindex", span1_tabindex_value = /*disabled*/ ctx[10] ? -1 : 0);
			toggle_class(span1, "active", /*focus*/ ctx[24] && /*activeHandle*/ ctx[26] === /*index*/ ctx[66]);
			toggle_class(span1, "press", /*handlePressed*/ ctx[25] && /*activeHandle*/ ctx[26] === /*index*/ ctx[66]);
		},
		m(target, anchor) {
			insert(target, span1, anchor);
			append(span1, span0);
			append(span1, t);
			if (if_block) if_block.m(span1, null);

			if (!mounted) {
				dispose = [
					listen(span1, "blur", /*sliderBlurHandle*/ ctx[34]),
					listen(span1, "focus", /*sliderFocusHandle*/ ctx[35]),
					listen(span1, "keydown", /*sliderKeydown*/ ctx[36])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*float*/ ctx[7]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_2$4(ctx);
					if_block.c();
					if_block.m(span1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*orientationStart, $springPositions, activeHandle*/ 872415232 && span1_style_value !== (span1_style_value = "" + (/*orientationStart*/ ctx[28] + ": " + /*$springPositions*/ ctx[29][/*index*/ ctx[66]] + "%; z-index: " + (/*activeHandle*/ ctx[26] === /*index*/ ctx[66] ? 3 : 2) + ";"))) {
				attr(span1, "style", span1_style_value);
			}

			if (dirty[0] & /*range, values, min*/ 13 && span1_aria_valuemin_value !== (span1_aria_valuemin_value = /*range*/ ctx[2] === true && /*index*/ ctx[66] === 1
			? /*values*/ ctx[0][0]
			: /*min*/ ctx[3])) {
				attr(span1, "aria-valuemin", span1_aria_valuemin_value);
			}

			if (dirty[0] & /*range, values, max*/ 21 && span1_aria_valuemax_value !== (span1_aria_valuemax_value = /*range*/ ctx[2] === true && /*index*/ ctx[66] === 0
			? /*values*/ ctx[0][1]
			: /*max*/ ctx[4])) {
				attr(span1, "aria-valuemax", span1_aria_valuemax_value);
			}

			if (dirty[0] & /*values*/ 1 && span1_aria_valuenow_value !== (span1_aria_valuenow_value = /*value*/ ctx[64])) {
				attr(span1, "aria-valuenow", span1_aria_valuenow_value);
			}

			if (dirty[0] & /*prefix, handleFormatter, values, percentOf, suffix*/ 11272193 && span1_aria_valuetext_value !== (span1_aria_valuetext_value = "" + (/*prefix*/ ctx[18] + /*handleFormatter*/ ctx[21](/*value*/ ctx[64], /*index*/ ctx[66], /*percentOf*/ ctx[23](/*value*/ ctx[64])) + /*suffix*/ ctx[19]))) {
				attr(span1, "aria-valuetext", span1_aria_valuetext_value);
			}

			if (dirty[0] & /*vertical*/ 64 && span1_aria_orientation_value !== (span1_aria_orientation_value = /*vertical*/ ctx[6] ? 'vertical' : 'horizontal')) {
				attr(span1, "aria-orientation", span1_aria_orientation_value);
			}

			if (dirty[0] & /*disabled*/ 1024) {
				attr(span1, "aria-disabled", /*disabled*/ ctx[10]);
			}

			if (dirty[0] & /*disabled*/ 1024) {
				attr(span1, "disabled", /*disabled*/ ctx[10]);
			}

			if (dirty[0] & /*disabled*/ 1024 && span1_tabindex_value !== (span1_tabindex_value = /*disabled*/ ctx[10] ? -1 : 0)) {
				attr(span1, "tabindex", span1_tabindex_value);
			}

			if (dirty[0] & /*focus, activeHandle*/ 83886080) {
				toggle_class(span1, "active", /*focus*/ ctx[24] && /*activeHandle*/ ctx[26] === /*index*/ ctx[66]);
			}

			if (dirty[0] & /*handlePressed, activeHandle*/ 100663296) {
				toggle_class(span1, "press", /*handlePressed*/ ctx[25] && /*activeHandle*/ ctx[26] === /*index*/ ctx[66]);
			}
		},
		d(detaching) {
			if (detaching) detach(span1);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (830:2) {#if range}
function create_if_block_1$8(ctx) {
	let span;
	let span_style_value;

	return {
		c() {
			span = element("span");
			attr(span, "class", "rangeBar");
			attr(span, "style", span_style_value = "" + (/*orientationStart*/ ctx[28] + ": " + /*rangeStart*/ ctx[32](/*$springPositions*/ ctx[29]) + "%; " + /*orientationEnd*/ ctx[27] + ": " + /*rangeEnd*/ ctx[33](/*$springPositions*/ ctx[29]) + "%;"));
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*orientationStart, $springPositions, orientationEnd*/ 939524096 && span_style_value !== (span_style_value = "" + (/*orientationStart*/ ctx[28] + ": " + /*rangeStart*/ ctx[32](/*$springPositions*/ ctx[29]) + "%; " + /*orientationEnd*/ ctx[27] + ": " + /*rangeEnd*/ ctx[33](/*$springPositions*/ ctx[29]) + "%;"))) {
				attr(span, "style", span_style_value);
			}
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (836:2) {#if pips}
function create_if_block$e(ctx) {
	let rangepips;
	let current;

	rangepips = new RangePips({
			props: {
				values: /*values*/ ctx[0],
				min: /*min*/ ctx[3],
				max: /*max*/ ctx[4],
				step: /*step*/ ctx[5],
				range: /*range*/ ctx[2],
				vertical: /*vertical*/ ctx[6],
				reversed: /*reversed*/ ctx[8],
				orientationStart: /*orientationStart*/ ctx[28],
				hoverable: /*hoverable*/ ctx[9],
				disabled: /*disabled*/ ctx[10],
				all: /*all*/ ctx[13],
				first: /*first*/ ctx[14],
				last: /*last*/ ctx[15],
				rest: /*rest*/ ctx[16],
				pipstep: /*pipstep*/ ctx[12],
				prefix: /*prefix*/ ctx[18],
				suffix: /*suffix*/ ctx[19],
				formatter: /*formatter*/ ctx[20],
				focus: /*focus*/ ctx[24],
				percentOf: /*percentOf*/ ctx[23],
				moveHandle: /*moveHandle*/ ctx[31],
				fixFloat: /*fixFloat*/ ctx[30]
			}
		});

	return {
		c() {
			create_component(rangepips.$$.fragment);
		},
		m(target, anchor) {
			mount_component(rangepips, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const rangepips_changes = {};
			if (dirty[0] & /*values*/ 1) rangepips_changes.values = /*values*/ ctx[0];
			if (dirty[0] & /*min*/ 8) rangepips_changes.min = /*min*/ ctx[3];
			if (dirty[0] & /*max*/ 16) rangepips_changes.max = /*max*/ ctx[4];
			if (dirty[0] & /*step*/ 32) rangepips_changes.step = /*step*/ ctx[5];
			if (dirty[0] & /*range*/ 4) rangepips_changes.range = /*range*/ ctx[2];
			if (dirty[0] & /*vertical*/ 64) rangepips_changes.vertical = /*vertical*/ ctx[6];
			if (dirty[0] & /*reversed*/ 256) rangepips_changes.reversed = /*reversed*/ ctx[8];
			if (dirty[0] & /*orientationStart*/ 268435456) rangepips_changes.orientationStart = /*orientationStart*/ ctx[28];
			if (dirty[0] & /*hoverable*/ 512) rangepips_changes.hoverable = /*hoverable*/ ctx[9];
			if (dirty[0] & /*disabled*/ 1024) rangepips_changes.disabled = /*disabled*/ ctx[10];
			if (dirty[0] & /*all*/ 8192) rangepips_changes.all = /*all*/ ctx[13];
			if (dirty[0] & /*first*/ 16384) rangepips_changes.first = /*first*/ ctx[14];
			if (dirty[0] & /*last*/ 32768) rangepips_changes.last = /*last*/ ctx[15];
			if (dirty[0] & /*rest*/ 65536) rangepips_changes.rest = /*rest*/ ctx[16];
			if (dirty[0] & /*pipstep*/ 4096) rangepips_changes.pipstep = /*pipstep*/ ctx[12];
			if (dirty[0] & /*prefix*/ 262144) rangepips_changes.prefix = /*prefix*/ ctx[18];
			if (dirty[0] & /*suffix*/ 524288) rangepips_changes.suffix = /*suffix*/ ctx[19];
			if (dirty[0] & /*formatter*/ 1048576) rangepips_changes.formatter = /*formatter*/ ctx[20];
			if (dirty[0] & /*focus*/ 16777216) rangepips_changes.focus = /*focus*/ ctx[24];
			if (dirty[0] & /*percentOf*/ 8388608) rangepips_changes.percentOf = /*percentOf*/ ctx[23];
			rangepips.$set(rangepips_changes);
		},
		i(local) {
			if (current) return;
			transition_in(rangepips.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(rangepips.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(rangepips, detaching);
		}
	};
}

function create_fragment$l(ctx) {
	let div;
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	let each_value = /*values*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
	}

	let if_block0 = /*range*/ ctx[2] && create_if_block_1$8(ctx);
	let if_block1 = /*pips*/ ctx[11] && create_if_block$e(ctx);

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			attr(div, "id", /*id*/ ctx[17]);
			attr(div, "class", "rangeSlider");
			toggle_class(div, "range", /*range*/ ctx[2]);
			toggle_class(div, "disabled", /*disabled*/ ctx[10]);
			toggle_class(div, "hoverable", /*hoverable*/ ctx[9]);
			toggle_class(div, "vertical", /*vertical*/ ctx[6]);
			toggle_class(div, "reversed", /*reversed*/ ctx[8]);
			toggle_class(div, "focus", /*focus*/ ctx[24]);
			toggle_class(div, "min", /*range*/ ctx[2] === 'min');
			toggle_class(div, "max", /*range*/ ctx[2] === 'max');
			toggle_class(div, "pips", /*pips*/ ctx[11]);
			toggle_class(div, "pip-labels", /*all*/ ctx[13] === 'label' || /*first*/ ctx[14] === 'label' || /*last*/ ctx[15] === 'label' || /*rest*/ ctx[16] === 'label');
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append(div, t0);
			if (if_block0) if_block0.m(div, null);
			append(div, t1);
			if (if_block1) if_block1.m(div, null);
			/*div_binding*/ ctx[50](div);
			current = true;

			if (!mounted) {
				dispose = [
					listen(window, "mousedown", /*bodyInteractStart*/ ctx[39]),
					listen(window, "touchstart", /*bodyInteractStart*/ ctx[39]),
					listen(window, "mousemove", /*bodyInteract*/ ctx[40]),
					listen(window, "touchmove", /*bodyInteract*/ ctx[40]),
					listen(window, "mouseup", /*bodyMouseUp*/ ctx[41]),
					listen(window, "touchend", /*bodyTouchEnd*/ ctx[42]),
					listen(window, "keydown", /*bodyKeyDown*/ ctx[43]),
					listen(div, "mousedown", /*sliderInteractStart*/ ctx[37]),
					listen(div, "mouseup", /*sliderInteractEnd*/ ctx[38]),
					listen(div, "touchstart", prevent_default(/*sliderInteractStart*/ ctx[37])),
					listen(div, "touchend", prevent_default(/*sliderInteractEnd*/ ctx[38]))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*orientationStart, $springPositions, activeHandle, range, values, min, max, prefix, handleFormatter, percentOf, suffix, vertical, disabled, focus, handlePressed, float*/ 934020317 | dirty[1] & /*sliderBlurHandle, sliderFocusHandle, sliderKeydown*/ 56) {
				each_value = /*values*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$7(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$7(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, t0);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (/*range*/ ctx[2]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$8(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*pips*/ ctx[11]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*pips*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$e(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*id*/ 131072) {
				attr(div, "id", /*id*/ ctx[17]);
			}

			if (!current || dirty[0] & /*range*/ 4) {
				toggle_class(div, "range", /*range*/ ctx[2]);
			}

			if (!current || dirty[0] & /*disabled*/ 1024) {
				toggle_class(div, "disabled", /*disabled*/ ctx[10]);
			}

			if (!current || dirty[0] & /*hoverable*/ 512) {
				toggle_class(div, "hoverable", /*hoverable*/ ctx[9]);
			}

			if (!current || dirty[0] & /*vertical*/ 64) {
				toggle_class(div, "vertical", /*vertical*/ ctx[6]);
			}

			if (!current || dirty[0] & /*reversed*/ 256) {
				toggle_class(div, "reversed", /*reversed*/ ctx[8]);
			}

			if (!current || dirty[0] & /*focus*/ 16777216) {
				toggle_class(div, "focus", /*focus*/ ctx[24]);
			}

			if (!current || dirty[0] & /*range*/ 4) {
				toggle_class(div, "min", /*range*/ ctx[2] === 'min');
			}

			if (!current || dirty[0] & /*range*/ 4) {
				toggle_class(div, "max", /*range*/ ctx[2] === 'max');
			}

			if (!current || dirty[0] & /*pips*/ 2048) {
				toggle_class(div, "pips", /*pips*/ ctx[11]);
			}

			if (!current || dirty[0] & /*all, first, last, rest*/ 122880) {
				toggle_class(div, "pip-labels", /*all*/ ctx[13] === 'label' || /*first*/ ctx[14] === 'label' || /*last*/ ctx[15] === 'label' || /*rest*/ ctx[16] === 'label');
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			/*div_binding*/ ctx[50](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function index(el) {
	if (!el) return -1;
	var i = 0;

	while (el = el.previousElementSibling) {
		i++;
	}

	return i;
}

/**
 * normalise a mouse or touch event to return the
 * client (x/y) object for that event
 * @param {event} e a mouse/touch event to normalise
 * @returns {object} normalised event client object (x,y)
 **/
function normalisedClient(e) {
	if (e.type.includes("touch")) {
		return e.touches[0];
	} else {
		return e;
	}
}

function instance$l($$self, $$props, $$invalidate) {
	let percentOf;
	let clampValue;
	let alignValueToStep;
	let orientationStart;
	let orientationEnd;

	let $springPositions,
		$$unsubscribe_springPositions = noop$1,
		$$subscribe_springPositions = () => ($$unsubscribe_springPositions(), $$unsubscribe_springPositions = subscribe(springPositions, $$value => $$invalidate(29, $springPositions = $$value)), springPositions);

	$$self.$$.on_destroy.push(() => $$unsubscribe_springPositions());
	let { slider = undefined } = $$props;
	let { range = false } = $$props;
	let { pushy = false } = $$props;
	let { min = 0 } = $$props;
	let { max = 100 } = $$props;
	let { step = 1 } = $$props;
	let { values = [(max + min) / 2] } = $$props;
	let { vertical = false } = $$props;
	let { float = false } = $$props;
	let { reversed = false } = $$props;
	let { hoverable = true } = $$props;
	let { disabled = false } = $$props;
	let { pips = false } = $$props;
	let { pipstep = undefined } = $$props;
	let { all = undefined } = $$props;
	let { first = undefined } = $$props;
	let { last = undefined } = $$props;
	let { rest = undefined } = $$props;
	let { id = undefined } = $$props;
	let { prefix = "" } = $$props;
	let { suffix = "" } = $$props;
	let { formatter = (v, i, p) => v } = $$props;
	let { handleFormatter = formatter } = $$props;
	let { precision = 2 } = $$props;
	let { springValues = { stiffness: 0.15, damping: 0.4 } } = $$props;

	// prepare dispatched events
	const dispatch = createEventDispatcher();

	// state management
	let valueLength = 0;

	let focus = false;
	let handleActivated = false;
	let handlePressed = false;
	let keyboardActive = false;
	let activeHandle = values.length - 1;
	let startValue;
	let previousValue;

	// copy the initial values in to a spring function which
	// will update every time the values array is modified
	let springPositions;

	const fixFloat = v => parseFloat(v.toFixed(precision));

	/**
 * check if an element is a handle on the slider
 * @param {object} el dom object reference we want to check
 * @returns {boolean}
 **/
	function targetIsHandle(el) {
		const handles = slider.querySelectorAll(".handle");
		const isHandle = Array.prototype.includes.call(handles, el);
		const isChild = Array.prototype.some.call(handles, e => e.contains(el));
		return isHandle || isChild;
	}

	/**
 * trim the values array based on whether the property
 * for 'range' is 'min', 'max', or truthy. This is because we
 * do not want more than one handle for a min/max range, and we do
 * not want more than two handles for a true range.
 * @param {array} values the input values for the rangeSlider
 * @return {array} the range array for creating a rangeSlider
 **/
	function trimRange(values) {
		if (range === "min" || range === "max") {
			return values.slice(0, 1);
		} else if (range) {
			return values.slice(0, 2);
		} else {
			return values;
		}
	}

	/**
 * helper to return the slider dimensions for finding
 * the closest handle to user interaction
 * @return {object} the range slider DOM client rect
 **/
	function getSliderDimensions() {
		return slider.getBoundingClientRect();
	}

	/**
 * helper to return closest handle to user interaction
 * @param {object} clientPos the client{x,y} positions to check against
 * @return {number} the index of the closest handle to clientPos
 **/
	function getClosestHandle(clientPos) {
		// first make sure we have the latest dimensions
		// of the slider, as it may have changed size
		const dims = getSliderDimensions();

		// calculate the interaction position, percent and value
		let handlePos = 0;

		let handlePercent = 0;
		let handleVal = 0;

		if (vertical) {
			handlePos = clientPos.clientY - dims.top;
			handlePercent = handlePos / dims.height * 100;
			handlePercent = reversed ? handlePercent : 100 - handlePercent;
		} else {
			handlePos = clientPos.clientX - dims.left;
			handlePercent = handlePos / dims.width * 100;
			handlePercent = reversed ? 100 - handlePercent : handlePercent;
		}

		handleVal = (max - min) / 100 * handlePercent + min;
		let closest;

		// if we have a range, and the handles are at the same
		// position, we want a simple check if the interaction
		// value is greater than return the second handle
		if (range === true && values[0] === values[1]) {
			if (handleVal > values[1]) {
				return 1;
			} else {
				return 0;
			}
		} else // we sort the handles values, and return the first one closest
		// to the interaction value
		{
			closest = values.indexOf([...values].sort((a, b) => Math.abs(handleVal - a) - Math.abs(handleVal - b))[0]); // if there are multiple handles, and not a range, then
		}

		return closest;
	}

	/**
 * take the interaction position on the slider, convert
 * it to a value on the range, and then send that value
 * through to the moveHandle() method to set the active
 * handle's position
 * @param {object} clientPos the client{x,y} of the interaction
 **/
	function handleInteract(clientPos) {
		// first make sure we have the latest dimensions
		// of the slider, as it may have changed size
		const dims = getSliderDimensions();

		// calculate the interaction position, percent and value
		let handlePos = 0;

		let handlePercent = 0;
		let handleVal = 0;

		if (vertical) {
			handlePos = clientPos.clientY - dims.top;
			handlePercent = handlePos / dims.height * 100;
			handlePercent = reversed ? handlePercent : 100 - handlePercent;
		} else {
			handlePos = clientPos.clientX - dims.left;
			handlePercent = handlePos / dims.width * 100;
			handlePercent = reversed ? 100 - handlePercent : handlePercent;
		}

		handleVal = (max - min) / 100 * handlePercent + min;

		// move handle to the value
		moveHandle(activeHandle, handleVal);
	}

	/**
 * move a handle to a specific value, respecting the clamp/align rules
 * @param {number} index the index of the handle we want to move
 * @param {number} value the value to move the handle to
 * @return {number} the value that was moved to (after alignment/clamping)
 **/
	function moveHandle(index, value) {
		// align & clamp the value so we're not doing extra
		// calculation on an out-of-range value down below
		value = alignValueToStep(value);

		// use the active handle if handle index is not provided
		if (typeof index === 'undefined') {
			index = activeHandle;
		}

		// if this is a range slider perform special checks
		if (range) {
			// restrict the handles of a range-slider from
			// going past one-another unless "pushy" is true
			if (index === 0 && value > values[1]) {
				if (pushy) {
					$$invalidate(0, values[1] = value, values);
				} else {
					value = values[1];
				}
			} else if (index === 1 && value < values[0]) {
				if (pushy) {
					$$invalidate(0, values[0] = value, values);
				} else {
					value = values[0];
				}
			}
		}

		// if the value has changed, update it
		if (values[index] !== value) {
			$$invalidate(0, values[index] = value, values);
		}

		// fire the change event when the handle moves,
		// and store the previous value for the next time
		if (previousValue !== value) {
			eChange();
			previousValue = value;
		}

		return value;
	}

	/**
 * helper to find the beginning range value for use with css style
 * @param {array} values the input values for the rangeSlider
 * @return {number} the beginning of the range
 **/
	function rangeStart(values) {
		if (range === "min") {
			return 0;
		} else {
			return values[0];
		}
	}

	/**
 * helper to find the ending range value for use with css style
 * @param {array} values the input values for the rangeSlider
 * @return {number} the end of the range
 **/
	function rangeEnd(values) {
		if (range === "max") {
			return 0;
		} else if (range === "min") {
			return 100 - values[0];
		} else {
			return 100 - values[1];
		}
	}

	/**
 * when the user has unfocussed (blurred) from the
 * slider, deactivate all handles
 * @param {event} e the event from browser
 **/
	function sliderBlurHandle(e) {
		if (keyboardActive) {
			$$invalidate(24, focus = false);
			handleActivated = false;
			$$invalidate(25, handlePressed = false);
		}
	}

	/**
 * when the user focusses the handle of a slider
 * set it to be active
 * @param {event} e the event from browser
 **/
	function sliderFocusHandle(e) {
		if (!disabled) {
			$$invalidate(26, activeHandle = index(e.target));
			$$invalidate(24, focus = true);
		}
	}

	/**
 * handle the keyboard accessible features by checking the
 * input type, and modfier key then moving handle by appropriate amount
 * @param {event} e the event from browser
 **/
	function sliderKeydown(e) {
		if (!disabled) {
			const handle = index(e.target);
			let jump = e.ctrlKey || e.metaKey || e.shiftKey ? step * 10 : step;
			let prevent = false;

			switch (e.key) {
				case "PageDown":
					jump *= 10;
				case "ArrowRight":
				case "ArrowUp":
					moveHandle(handle, values[handle] + jump);
					prevent = true;
					break;
				case "PageUp":
					jump *= 10;
				case "ArrowLeft":
				case "ArrowDown":
					moveHandle(handle, values[handle] - jump);
					prevent = true;
					break;
				case "Home":
					moveHandle(handle, min);
					prevent = true;
					break;
				case "End":
					moveHandle(handle, max);
					prevent = true;
					break;
			}

			if (prevent) {
				e.preventDefault();
				e.stopPropagation();
			}
		}
	}

	/**
 * function to run when the user touches
 * down on the slider element anywhere
 * @param {event} e the event from browser
 **/
	function sliderInteractStart(e) {
		if (!disabled) {
			const el = e.target;
			const clientPos = normalisedClient(e);

			// set the closest handle as active
			$$invalidate(24, focus = true);

			handleActivated = true;
			$$invalidate(25, handlePressed = true);
			$$invalidate(26, activeHandle = getClosestHandle(clientPos));

			// fire the start event
			startValue = previousValue = alignValueToStep(values[activeHandle]);

			eStart();

			// for touch devices we want the handle to instantly
			// move to the position touched for more responsive feeling
			if (e.type === "touchstart" && !el.matches(".pipVal")) {
				handleInteract(clientPos);
			}
		}
	}

	/**
 * function to run when the user stops touching
 * down on the slider element anywhere
 * @param {event} e the event from browser
 **/
	function sliderInteractEnd(e) {
		// fire the stop event for touch devices
		if (e.type === "touchend") {
			eStop();
		}

		$$invalidate(25, handlePressed = false);
	}

	/**
 * unfocus the slider if the user clicked off of
 * it, somewhere else on the screen
 * @param {event} e the event from browser
 **/
	function bodyInteractStart(e) {
		keyboardActive = false;

		if (focus && e.target !== slider && !slider.contains(e.target)) {
			$$invalidate(24, focus = false);
		}
	}

	/**
 * send the clientX through to handle the interaction
 * whenever the user moves acros screen while active
 * @param {event} e the event from browser
 **/
	function bodyInteract(e) {
		if (!disabled) {
			if (handleActivated) {
				handleInteract(normalisedClient(e));
			}
		}
	}

	/**
 * if user triggers mouseup on the body while
 * a handle is active (without moving) then we
 * trigger an interact event there
 * @param {event} e the event from browser
 **/
	function bodyMouseUp(e) {
		if (!disabled) {
			const el = e.target;

			// this only works if a handle is active, which can
			// only happen if there was sliderInteractStart triggered
			// on the slider, already
			if (handleActivated) {
				if (el === slider || slider.contains(el)) {
					$$invalidate(24, focus = true);

					// don't trigger interact if the target is a handle (no need) or
					// if the target is a label (we want to move to that value from rangePips)
					if (!targetIsHandle(el) && !el.matches(".pipVal")) {
						handleInteract(normalisedClient(e));
					}
				}

				// fire the stop event for mouse device
				// when the body is triggered with an active handle
				eStop();
			}
		}

		handleActivated = false;
		$$invalidate(25, handlePressed = false);
	}

	/**
 * if user triggers touchend on the body then we
 * defocus the slider completely
 * @param {event} e the event from browser
 **/
	function bodyTouchEnd(e) {
		handleActivated = false;
		$$invalidate(25, handlePressed = false);
	}

	function bodyKeyDown(e) {
		if (!disabled) {
			if (e.target === slider || slider.contains(e.target)) {
				keyboardActive = true;
			}
		}
	}

	function eStart() {
		!disabled && dispatch("start", {
			activeHandle,
			value: startValue,
			values: values.map(v => alignValueToStep(v))
		});
	}

	function eStop() {
		!disabled && dispatch("stop", {
			activeHandle,
			startValue,
			value: values[activeHandle],
			values: values.map(v => alignValueToStep(v))
		});
	}

	function eChange() {
		!disabled && dispatch("change", {
			activeHandle,
			startValue,
			previousValue: typeof previousValue === "undefined"
			? startValue
			: previousValue,
			value: values[activeHandle],
			values: values.map(v => alignValueToStep(v))
		});
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			slider = $$value;
			$$invalidate(1, slider);
		});
	}

	$$self.$$set = $$props => {
		if ('slider' in $$props) $$invalidate(1, slider = $$props.slider);
		if ('range' in $$props) $$invalidate(2, range = $$props.range);
		if ('pushy' in $$props) $$invalidate(44, pushy = $$props.pushy);
		if ('min' in $$props) $$invalidate(3, min = $$props.min);
		if ('max' in $$props) $$invalidate(4, max = $$props.max);
		if ('step' in $$props) $$invalidate(5, step = $$props.step);
		if ('values' in $$props) $$invalidate(0, values = $$props.values);
		if ('vertical' in $$props) $$invalidate(6, vertical = $$props.vertical);
		if ('float' in $$props) $$invalidate(7, float = $$props.float);
		if ('reversed' in $$props) $$invalidate(8, reversed = $$props.reversed);
		if ('hoverable' in $$props) $$invalidate(9, hoverable = $$props.hoverable);
		if ('disabled' in $$props) $$invalidate(10, disabled = $$props.disabled);
		if ('pips' in $$props) $$invalidate(11, pips = $$props.pips);
		if ('pipstep' in $$props) $$invalidate(12, pipstep = $$props.pipstep);
		if ('all' in $$props) $$invalidate(13, all = $$props.all);
		if ('first' in $$props) $$invalidate(14, first = $$props.first);
		if ('last' in $$props) $$invalidate(15, last = $$props.last);
		if ('rest' in $$props) $$invalidate(16, rest = $$props.rest);
		if ('id' in $$props) $$invalidate(17, id = $$props.id);
		if ('prefix' in $$props) $$invalidate(18, prefix = $$props.prefix);
		if ('suffix' in $$props) $$invalidate(19, suffix = $$props.suffix);
		if ('formatter' in $$props) $$invalidate(20, formatter = $$props.formatter);
		if ('handleFormatter' in $$props) $$invalidate(21, handleFormatter = $$props.handleFormatter);
		if ('precision' in $$props) $$invalidate(45, precision = $$props.precision);
		if ('springValues' in $$props) $$invalidate(46, springValues = $$props.springValues);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*min, max*/ 24) {
			/**
 * clamp a value from the range so that it always
 * falls within the min/max values
 * @param {number} val the value to clamp
 * @return {number} the value after it's been clamped
 **/
			$$invalidate(49, clampValue = function (val) {
				// return the min/max if outside of that range
				return val <= min ? min : val >= max ? max : val;
			});
		}

		if ($$self.$$.dirty[0] & /*min, max, step*/ 56 | $$self.$$.dirty[1] & /*clampValue*/ 262144) {
			/**
 * align the value with the steps so that it
 * always sits on the closest (above/below) step
 * @param {number} val the value to align
 * @return {number} the value after it's been aligned
 **/
			$$invalidate(48, alignValueToStep = function (val) {
				// sanity check for performance
				if (val <= min) {
					return fixFloat(min);
				} else if (val >= max) {
					return fixFloat(max);
				}

				// find the middle-point between steps
				// and see if the value is closer to the
				// next step, or previous step
				let remainder = (val - min) % step;

				let aligned = val - remainder;

				if (Math.abs(remainder) * 2 >= step) {
					aligned += remainder > 0 ? step : -step;
				}

				// make sure the value is within acceptable limits
				aligned = clampValue(aligned);

				// make sure the returned value is set to the precision desired
				// this is also because javascript often returns weird floats
				// when dealing with odd numbers and percentages
				return fixFloat(aligned);
			});
		}

		if ($$self.$$.dirty[0] & /*min, max*/ 24) {
			/**
 * take in a value, and then calculate that value's percentage
 * of the overall range (min-max);
 * @param {number} val the value we're getting percent for
 * @return {number} the percentage value
 **/
			$$invalidate(23, percentOf = function (val) {
				let perc = (val - min) / (max - min) * 100;

				if (isNaN(perc) || perc <= 0) {
					return 0;
				} else if (perc >= 100) {
					return 100;
				} else {
					return fixFloat(perc);
				}
			});
		}

		if ($$self.$$.dirty[0] & /*values, max, min, percentOf, springPositions*/ 12582937 | $$self.$$.dirty[1] & /*alignValueToStep, valueLength, springValues*/ 229376) {
			{
				// check that "values" is an array, or set it as array
				// to prevent any errors in springs, or range trimming
				if (!Array.isArray(values)) {
					$$invalidate(0, values = [(max + min) / 2]);
					console.error("'values' prop should be an Array (https://github.com/simeydotme/svelte-range-slider-pips#slider-props)");
				}

				// trim the range so it remains as a min/max (only 2 handles)
				// and also align the handles to the steps
				$$invalidate(0, values = trimRange(values.map(v => alignValueToStep(v))));

				// check if the valueLength (length of values[]) has changed,
				// because if so we need to re-seed the spring function with the
				// new values array.
				if (valueLength !== values.length) {
					// set the initial spring values when the slider initialises,
					// or when values array length has changed
					$$subscribe_springPositions($$invalidate(22, springPositions = spring(values.map(v => percentOf(v)), springValues)));
				} else {
					// update the value of the spring function for animated handles
					// whenever the values has updated
					springPositions.set(values.map(v => percentOf(v)));
				}

				// set the valueLength for the next check
				$$invalidate(47, valueLength = values.length);
			}
		}

		if ($$self.$$.dirty[0] & /*vertical, reversed*/ 320) {
			/**
 * the orientation of the handles/pips based on the
 * input values of vertical and reversed
 **/
			$$invalidate(28, orientationStart = vertical
			? reversed ? 'top' : 'bottom'
			: reversed ? 'right' : 'left');
		}

		if ($$self.$$.dirty[0] & /*vertical, reversed*/ 320) {
			$$invalidate(27, orientationEnd = vertical
			? reversed ? 'bottom' : 'top'
			: reversed ? 'left' : 'right');
		}
	};

	return [
		values,
		slider,
		range,
		min,
		max,
		step,
		vertical,
		float,
		reversed,
		hoverable,
		disabled,
		pips,
		pipstep,
		all,
		first,
		last,
		rest,
		id,
		prefix,
		suffix,
		formatter,
		handleFormatter,
		springPositions,
		percentOf,
		focus,
		handlePressed,
		activeHandle,
		orientationEnd,
		orientationStart,
		$springPositions,
		fixFloat,
		moveHandle,
		rangeStart,
		rangeEnd,
		sliderBlurHandle,
		sliderFocusHandle,
		sliderKeydown,
		sliderInteractStart,
		sliderInteractEnd,
		bodyInteractStart,
		bodyInteract,
		bodyMouseUp,
		bodyTouchEnd,
		bodyKeyDown,
		pushy,
		precision,
		springValues,
		valueLength,
		alignValueToStep,
		clampValue,
		div_binding
	];
}

class RangeSlider extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$l,
			create_fragment$l,
			safe_not_equal,
			{
				slider: 1,
				range: 2,
				pushy: 44,
				min: 3,
				max: 4,
				step: 5,
				values: 0,
				vertical: 6,
				float: 7,
				reversed: 8,
				hoverable: 9,
				disabled: 10,
				pips: 11,
				pipstep: 12,
				all: 13,
				first: 14,
				last: 15,
				rest: 16,
				id: 17,
				prefix: 18,
				suffix: 19,
				formatter: 20,
				handleFormatter: 21,
				precision: 45,
				springValues: 46
			},
			null,
			[-1, -1, -1]
		);
	}
}

/* src/components/slider/slider.view.svelte generated by Svelte v3.52.0 */

function create_else_block$9(ctx) {
	let rangeslider;
	let current;

	rangeslider = new RangeSlider({
			props: {
				values: /*$values*/ ctx[12],
				min: /*$min*/ ctx[13],
				max: /*$max*/ ctx[14],
				step: /*$step*/ ctx[15],
				range: /*range*/ ctx[5],
				float: /*float*/ ctx[6],
				vertical: /*vertical*/ ctx[7],
				pips: /*pips*/ ctx[8],
				pipstep: /*pipstep*/ ctx[9],
				formatter: /*formatter*/ ctx[10],
				all: "label",
				springValues: { stiffness: 0.2, damping: 0.8 }
			}
		});

	rangeslider.$on("stop", /*dispatchValues*/ ctx[16]);

	return {
		c() {
			create_component(rangeslider.$$.fragment);
		},
		m(target, anchor) {
			mount_component(rangeslider, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const rangeslider_changes = {};
			if (dirty & /*$values*/ 4096) rangeslider_changes.values = /*$values*/ ctx[12];
			if (dirty & /*$min*/ 8192) rangeslider_changes.min = /*$min*/ ctx[13];
			if (dirty & /*$max*/ 16384) rangeslider_changes.max = /*$max*/ ctx[14];
			if (dirty & /*$step*/ 32768) rangeslider_changes.step = /*$step*/ ctx[15];
			if (dirty & /*range*/ 32) rangeslider_changes.range = /*range*/ ctx[5];
			if (dirty & /*float*/ 64) rangeslider_changes.float = /*float*/ ctx[6];
			if (dirty & /*vertical*/ 128) rangeslider_changes.vertical = /*vertical*/ ctx[7];
			if (dirty & /*pips*/ 256) rangeslider_changes.pips = /*pips*/ ctx[8];
			if (dirty & /*pipstep*/ 512) rangeslider_changes.pipstep = /*pipstep*/ ctx[9];
			if (dirty & /*formatter*/ 1024) rangeslider_changes.formatter = /*formatter*/ ctx[10];
			rangeslider.$set(rangeslider_changes);
		},
		i(local) {
			if (current) return;
			transition_in(rangeslider.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(rangeslider.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(rangeslider, detaching);
		}
	};
}

// (21:2) {#if continuous}
function create_if_block$d(ctx) {
	let rangeslider;
	let updating_values;
	let current;

	function rangeslider_values_binding(value) {
		/*rangeslider_values_binding*/ ctx[17](value);
	}

	let rangeslider_props = {
		min: /*$min*/ ctx[13],
		max: /*$max*/ ctx[14],
		step: /*$step*/ ctx[15],
		range: /*range*/ ctx[5],
		float: /*float*/ ctx[6],
		vertical: /*vertical*/ ctx[7],
		pips: /*pips*/ ctx[8],
		pipstep: /*pipstep*/ ctx[9],
		formatter: /*formatter*/ ctx[10],
		all: "label",
		springValues: { stiffness: 0.2, damping: 0.8 }
	};

	if (/*$values*/ ctx[12] !== void 0) {
		rangeslider_props.values = /*$values*/ ctx[12];
	}

	rangeslider = new RangeSlider({ props: rangeslider_props });
	binding_callbacks.push(() => bind(rangeslider, 'values', rangeslider_values_binding));

	return {
		c() {
			create_component(rangeslider.$$.fragment);
		},
		m(target, anchor) {
			mount_component(rangeslider, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const rangeslider_changes = {};
			if (dirty & /*$min*/ 8192) rangeslider_changes.min = /*$min*/ ctx[13];
			if (dirty & /*$max*/ 16384) rangeslider_changes.max = /*$max*/ ctx[14];
			if (dirty & /*$step*/ 32768) rangeslider_changes.step = /*$step*/ ctx[15];
			if (dirty & /*range*/ 32) rangeslider_changes.range = /*range*/ ctx[5];
			if (dirty & /*float*/ 64) rangeslider_changes.float = /*float*/ ctx[6];
			if (dirty & /*vertical*/ 128) rangeslider_changes.vertical = /*vertical*/ ctx[7];
			if (dirty & /*pips*/ 256) rangeslider_changes.pips = /*pips*/ ctx[8];
			if (dirty & /*pipstep*/ 512) rangeslider_changes.pipstep = /*pipstep*/ ctx[9];
			if (dirty & /*formatter*/ 1024) rangeslider_changes.formatter = /*formatter*/ ctx[10];

			if (!updating_values && dirty & /*$values*/ 4096) {
				updating_values = true;
				rangeslider_changes.values = /*$values*/ ctx[12];
				add_flush_callback(() => updating_values = false);
			}

			rangeslider.$set(rangeslider_changes);
		},
		i(local) {
			if (current) return;
			transition_in(rangeslider.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(rangeslider.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(rangeslider, detaching);
		}
	};
}

// (20:0) <ViewContainer {title}>
function create_default_slot$c(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$d, create_else_block$9];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*continuous*/ ctx[11]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$k(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				$$slots: { default: [create_default_slot$c] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];

			if (dirty & /*$$scope, $min, $max, $step, range, float, vertical, pips, pipstep, formatter, $values, continuous*/ 327648) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$k($$self, $$props, $$invalidate) {
	let $values,
		$$unsubscribe_values = noop$1,
		$$subscribe_values = () => ($$unsubscribe_values(), $$unsubscribe_values = subscribe(values, $$value => $$invalidate(12, $values = $$value)), values);

	let $min,
		$$unsubscribe_min = noop$1,
		$$subscribe_min = () => ($$unsubscribe_min(), $$unsubscribe_min = subscribe(min, $$value => $$invalidate(13, $min = $$value)), min);

	let $max,
		$$unsubscribe_max = noop$1,
		$$subscribe_max = () => ($$unsubscribe_max(), $$unsubscribe_max = subscribe(max, $$value => $$invalidate(14, $max = $$value)), max);

	let $step,
		$$unsubscribe_step = noop$1,
		$$subscribe_step = () => ($$unsubscribe_step(), $$unsubscribe_step = subscribe(step, $$value => $$invalidate(15, $step = $$value)), step);

	$$self.$$.on_destroy.push(() => $$unsubscribe_values());
	$$self.$$.on_destroy.push(() => $$unsubscribe_min());
	$$self.$$.on_destroy.push(() => $$unsubscribe_max());
	$$self.$$.on_destroy.push(() => $$unsubscribe_step());
	let { title } = $$props;
	let { values } = $$props;
	$$subscribe_values();
	let { min } = $$props;
	$$subscribe_min();
	let { max } = $$props;
	$$subscribe_max();
	let { step } = $$props;
	$$subscribe_step();
	let { range } = $$props;
	let { float } = $$props;
	let { vertical } = $$props;
	let { pips } = $$props;
	let { pipstep } = $$props;
	let { formatter } = $$props;
	let { continuous } = $$props;

	function dispatchValues({ detail }) {
		values.set(detail.values);
	}

	function rangeslider_values_binding(value) {
		$values = value;
		values.set($values);
	}

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('values' in $$props) $$subscribe_values($$invalidate(1, values = $$props.values));
		if ('min' in $$props) $$subscribe_min($$invalidate(2, min = $$props.min));
		if ('max' in $$props) $$subscribe_max($$invalidate(3, max = $$props.max));
		if ('step' in $$props) $$subscribe_step($$invalidate(4, step = $$props.step));
		if ('range' in $$props) $$invalidate(5, range = $$props.range);
		if ('float' in $$props) $$invalidate(6, float = $$props.float);
		if ('vertical' in $$props) $$invalidate(7, vertical = $$props.vertical);
		if ('pips' in $$props) $$invalidate(8, pips = $$props.pips);
		if ('pipstep' in $$props) $$invalidate(9, pipstep = $$props.pipstep);
		if ('formatter' in $$props) $$invalidate(10, formatter = $$props.formatter);
		if ('continuous' in $$props) $$invalidate(11, continuous = $$props.continuous);
	};

	return [
		title,
		values,
		min,
		max,
		step,
		range,
		float,
		vertical,
		pips,
		pipstep,
		formatter,
		continuous,
		$values,
		$min,
		$max,
		$step,
		dispatchValues,
		rangeslider_values_binding
	];
}

class Slider_view extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$k, create_fragment$k, safe_not_equal, {
			title: 0,
			values: 1,
			min: 2,
			max: 3,
			step: 4,
			range: 5,
			float: 6,
			vertical: 7,
			pips: 8,
			pipstep: 9,
			formatter: 10,
			continuous: 11
		});
	}
}

function round(value, exp) {
    if (typeof exp === 'undefined' || +exp === 0)
        return Math.round(value);
    let v = +value;
    const e = +exp;
    if (isNaN(v) || !(typeof e === 'number' && e % 1 === 0))
        return NaN;
    // Shift
    let vv = v.toString().split('e');
    v = Math.round(+(vv[0] + 'e' + (vv[1] ? +vv[1] + e : e)));
    // Shift back
    vv = v.toString().split('e');
    return +(vv[0] + 'e' + (vv[1] ? +vv[1] - e : -e));
}
class Slider extends Component {
    constructor({ values = [0.2], min = 0, max = 1, step = 0.01, range = 'min', float = true, vertical = false, pips = false, pipstep = undefined, formatter = (x) => round(x, 3), continuous = true, } = {}) {
        super();
        this.title = 'slider';
        this.$values = new Stream(values, true);
        this.$min = new Stream(min, true);
        this.$max = new Stream(max, true);
        this.$step = new Stream(step, true);
        this.range = range;
        this.float = float;
        this.vertical = vertical;
        this.pips = pips;
        this.pipstep = pipstep !== undefined ? pipstep : Math.floor((max - min) / (10 * step));
        this.formatter = formatter;
        this.continuous = continuous;
        this.start();
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Slider_view({
            target: t,
            props: {
                title: this.title,
                values: this.$values,
                min: this.$min,
                max: this.$max,
                step: this.$step,
                range: this.range,
                float: this.float,
                vertical: this.vertical,
                pips: this.pips,
                pipstep: this.pipstep,
                formatter: this.formatter,
                continuous: this.continuous,
            },
        });
    }
}

function slider(...args) {
    return new Slider(...args);
}

/* src/components/text-area/text-area.view.svelte generated by Svelte v3.52.0 */

function create_default_slot$b(ctx) {
	let div;
	let textarea;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			textarea = element("textarea");
			attr(textarea, "class", "w-full px-3 py-1.5 text-base font-normal text-gray-700 bg-white bg-clip-padding border border-solid border-gray-300 rounded transition ease-in-out m-0 focus:text-gray-700 focus:bg-white focus:border-blue-600 focus:outline-none svelte-1nngj94");
			attr(textarea, "placeholder", /*placeholder*/ ctx[2]);
			textarea.disabled = /*$disabled*/ ctx[4];
			attr(div, "class", "w-full svelte-1nngj94");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, textarea);
			set_input_value(textarea, /*$value*/ ctx[5]);

			if (!mounted) {
				dispose = listen(textarea, "input", /*textarea_input_handler*/ ctx[6]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*placeholder*/ 4) {
				attr(textarea, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (dirty & /*$disabled*/ 16) {
				textarea.disabled = /*$disabled*/ ctx[4];
			}

			if (dirty & /*$value*/ 32) {
				set_input_value(textarea, /*$value*/ ctx[5]);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$j(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				$$slots: { default: [create_default_slot$b] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];

			if (dirty & /*$$scope, placeholder, $disabled, $value*/ 180) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$j($$self, $$props, $$invalidate) {
	let $disabled,
		$$unsubscribe_disabled = noop$1,
		$$subscribe_disabled = () => ($$unsubscribe_disabled(), $$unsubscribe_disabled = subscribe(disabled, $$value => $$invalidate(4, $disabled = $$value)), disabled);

	let $value,
		$$unsubscribe_value = noop$1,
		$$subscribe_value = () => ($$unsubscribe_value(), $$unsubscribe_value = subscribe(value, $$value => $$invalidate(5, $value = $$value)), value);

	$$self.$$.on_destroy.push(() => $$unsubscribe_disabled());
	$$self.$$.on_destroy.push(() => $$unsubscribe_value());
	let { title } = $$props;
	let { value } = $$props;
	$$subscribe_value();
	let { placeholder } = $$props;
	let { disabled } = $$props;
	$$subscribe_disabled();

	function textarea_input_handler() {
		$value = this.value;
		value.set($value);
	}

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('value' in $$props) $$subscribe_value($$invalidate(1, value = $$props.value));
		if ('placeholder' in $$props) $$invalidate(2, placeholder = $$props.placeholder);
		if ('disabled' in $$props) $$subscribe_disabled($$invalidate(3, disabled = $$props.disabled));
	};

	return [title, value, placeholder, disabled, $disabled, $value, textarea_input_handler];
}

class Text_area_view extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$j, create_fragment$j, safe_not_equal, {
			title: 0,
			value: 1,
			placeholder: 2,
			disabled: 3
		});
	}
}

class TextArea extends Component {
    constructor(defaultValue = '', placeholder = '') {
        super();
        this.title = 'text area';
        this.$disabled = new Stream(false, true);
        this.$value = new Stream(defaultValue, true);
        this.placeholder = placeholder;
        this.start();
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Text_area_view({
            target: t,
            props: {
                title: this.title,
                value: this.$value,
                placeholder: this.placeholder,
                disabled: this.$disabled,
            },
        });
    }
}

function textArea(...args) {
    return new TextArea(...args);
}

/* src/components/text-input/text-input.view.svelte generated by Svelte v3.52.0 */

function create_default_slot$a(ctx) {
	let div1;
	let div0;
	let input;
	let updating_value;
	let current;

	function input_value_binding(value) {
		/*input_value_binding*/ ctx[5](value);
	}

	let input_props = {
		type: "text",
		placeholder: "Enter a label..",
		disabled: /*$disabled*/ ctx[4]
	};

	if (/*$value*/ ctx[3] !== void 0) {
		input_props.value = /*$value*/ ctx[3];
	}

	input = new Input({ props: input_props });
	binding_callbacks.push(() => bind(input, 'value', input_value_binding));

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			create_component(input.$$.fragment);
			attr(div0, "class", "md:flex md:items-center mb-2");
			attr(div1, "class", "w-full max-w-sm");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			mount_component(input, div0, null);
			current = true;
		},
		p(ctx, dirty) {
			const input_changes = {};
			if (dirty & /*$disabled*/ 16) input_changes.disabled = /*$disabled*/ ctx[4];

			if (!updating_value && dirty & /*$value*/ 8) {
				updating_value = true;
				input_changes.value = /*$value*/ ctx[3];
				add_flush_callback(() => updating_value = false);
			}

			input.$set(input_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(input);
		}
	};
}

function create_fragment$i(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				$$slots: { default: [create_default_slot$a] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];

			if (dirty & /*$$scope, $disabled, $value*/ 88) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$i($$self, $$props, $$invalidate) {
	let $value,
		$$unsubscribe_value = noop$1,
		$$subscribe_value = () => ($$unsubscribe_value(), $$unsubscribe_value = subscribe(value, $$value => $$invalidate(3, $value = $$value)), value);

	let $disabled,
		$$unsubscribe_disabled = noop$1,
		$$subscribe_disabled = () => ($$unsubscribe_disabled(), $$unsubscribe_disabled = subscribe(disabled, $$value => $$invalidate(4, $disabled = $$value)), disabled);

	$$self.$$.on_destroy.push(() => $$unsubscribe_value());
	$$self.$$.on_destroy.push(() => $$unsubscribe_disabled());
	let { title } = $$props;
	let { value } = $$props;
	$$subscribe_value();
	let { disabled } = $$props;
	$$subscribe_disabled();

	function input_value_binding(value$1) {
		$value = value$1;
		value.set($value);
	}

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('value' in $$props) $$subscribe_value($$invalidate(1, value = $$props.value));
		if ('disabled' in $$props) $$subscribe_disabled($$invalidate(2, disabled = $$props.disabled));
	};

	return [title, value, disabled, $value, $disabled, input_value_binding];
}

class Text_input_view extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$i, create_fragment$i, safe_not_equal, { title: 0, value: 1, disabled: 2 });
	}
}

class TextInput extends Component {
    constructor(defaultValue) {
        super();
        this.title = 'text input';
        this.$value = new Stream('', true);
        this.$disabled = new Stream(false, true);
        if (defaultValue !== undefined) {
            this.$value.set(defaultValue);
        }
        this.start();
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Text_input_view({
            target: t,
            props: {
                title: this.title,
                value: this.$value,
                disabled: this.$disabled,
            },
        });
    }
}

function textInput(...args) {
    return new TextInput(...args);
}
/** @deprecated */
function textField() {
    const e = new Error('textField has been renamed to textInput');
    e.name = 'Deprecation Notice';
    throwError(e);
    return textInput();
}

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
getGlobalTensorClass().prototype.mul = function (b) {
    this.throwIfDisposed();
    return mul(this, b);
};

/* src/components/tfjs-model/tfjs-model.view.svelte generated by Svelte v3.52.0 */

function create_else_block$8(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "No model loaded";
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (19:34) 
function create_if_block_1$7(ctx) {
	let p;
	let t0;
	let t1;
	let t2;

	return {
		c() {
			p = element("p");
			t0 = text$1("Model Loaded from ");
			t1 = text$1(/*source*/ ctx[2]);
			t2 = text$1(".");
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t0);
			append(p, t1);
			append(p, t2);
		},
		p(ctx, dirty) {
			if (dirty & /*source*/ 4) set_data(t1, /*source*/ ctx[2]);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (17:4) {#if status === 'loading'}
function create_if_block$c(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			p.textContent = "Loading Model...";
		},
		m(target, anchor) {
			insert(target, p, anchor);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (15:0) <ViewContainer {title} loading={status === 'loading'}>
function create_default_slot$9(ctx) {
	let div;

	function select_block_type(ctx, dirty) {
		if (/*status*/ ctx[3] === 'loading') return create_if_block$c;
		if (/*status*/ ctx[3] === 'loaded') return create_if_block_1$7;
		return create_else_block$8;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			attr(div, "class", "p-2 text-sm text-gray-600");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_block.m(div, null);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			if_block.d();
		}
	};
}

function create_fragment$h(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				loading: /*status*/ ctx[3] === 'loading',
				$$slots: { default: [create_default_slot$9] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];
			if (dirty & /*status*/ 8) viewcontainer_changes.loading = /*status*/ ctx[3] === 'loading';

			if (dirty & /*$$scope, status, source*/ 268) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$h($$self, $$props, $$invalidate) {
	let status;
	let source;

	let $training,
		$$unsubscribe_training = noop$1,
		$$subscribe_training = () => ($$unsubscribe_training(), $$unsubscribe_training = subscribe(training, $$value => $$invalidate(7, $training = $$value)), training);

	$$self.$$.on_destroy.push(() => $$unsubscribe_training());
	var _a, _b, _c;
	let { title } = $$props;
	let { training } = $$props;
	$$subscribe_training();

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('training' in $$props) $$subscribe_training($$invalidate(1, training = $$props.training));
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$training*/ 128) {
			$$invalidate(3, status = $training.status);
		}

		if ($$self.$$.dirty & /*$training, _a, _b, _c*/ 240) {
			$$invalidate(2, source = !($$invalidate(4, _a = $training.data) === null || _a === void 0
			? void 0
			: _a.source)
			? 'unknown source'
			: $training.data.source === 'datastore'
				? `datastore at ${$$invalidate(5, _b = $training.data) === null || _b === void 0
					? void 0
					: _b.url}`
				: $training.data.source === 'url'
					? `url ${$$invalidate(6, _c = $training.data) === null || _c === void 0
						? void 0
						: _c.url}`
					: 'files');
		}
	};

	return [title, training, source, status, _a, _b, _c, $training];
}

class Tfjs_model_view extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$h, create_fragment$h, safe_not_equal, { title: 0, training: 1 });
	}
}

function isInputType(t, tt) {
    return t === tt;
}
function isPredictionType(t, tt) {
    return t === tt;
}
class TFJSModel extends TFJSBaseModel {
    constructor({ inputType, taskType, segmentationOptions = { applyArgmax: false, output: 'image' }, }) {
        super();
        this.title = 'tfjs model';
        this.parameters = {};
        this.segmentationOptions = { applyArgmax: false, output: 'image', ...segmentationOptions };
        this.inputType = inputType;
        this.taskType = taskType;
        this.$training.subscribe(({ status }) => {
            if (status === 'loaded') {
                this.inputShape = this.model.inputs[0].shape.map((x) => (x && x > 0 ? x : 1));
            }
        });
    }
    // eslint-disable-next-line class-methods-use-this
    train() {
        throw new TrainingError('Model `TfModel` cannot be trained');
    }
    async predict(input) {
        if (!this.model || this.$training.get().status !== 'loaded') {
            throw new Error('Model is not loaded');
        }
        const outputs = tidy$1(() => {
            const inputTensor = this.preprocess(input);
            return this.model.predict(inputTensor.expandDims(0)).gather(0);
        });
        const result = await this.postprocess(outputs);
        outputs.dispose();
        return result;
    }
    preprocess(input) {
        if (isInputType(this.inputType, 'image')) {
            return this.preprocessImage(input);
        }
        if (isInputType(this.inputType, 'generic')) {
            return tensor$1(input);
        }
        throw new Error('Invalid input data type');
    }
    preprocessImage(img) {
        return image.resizeBilinear(browser.fromPixels(img), [
            this.inputShape[1],
            this.inputShape[2],
        ]);
    }
    async postprocess(outputs) {
        if (isPredictionType(this.taskType, 'classification')) {
            // throw new Error('Classifier is not yet implemented');
            const getLabel = this.labels
                ? (index) => this.labels[index]
                : (index) => index.toString();
            const likeliest = tidy$1(() => outputs.argMax().dataSync()[0]);
            const confidences = outputs
                .arraySync()
                .reduce((x, y, i) => ({ ...x, [getLabel(i)]: y }), {});
            return {
                label: getLabel(likeliest),
                confidences,
            };
        }
        if (isPredictionType(this.taskType, 'segmentation')) {
            const [width, height] = outputs.shape;
            const processedOutputs = this.segmentationOptions.applyArgmax
                ? tidy$1(() => outputs.argMax(-1).mul(0.5))
                : outputs;
            const mask = this.segmentationOptions.output === 'image'
                ? new ImageData(await browser.toPixels(processedOutputs), width, height)
                : await processedOutputs.array();
            if (this.segmentationOptions.applyArgmax) {
                processedOutputs.dispose();
            }
            return mask;
        }
        if (isPredictionType(this.taskType, 'generic')) {
            return outputs.array();
        }
        throw new Error('Invalid output data type');
    }
    async loadFromFiles(files) {
        this.$training.set({
            status: 'loading',
        });
        try {
            const jsonFiles = files.filter((x) => x.name.includes('.json'));
            const weightFiles = files.filter((x) => x.name.includes('.bin'));
            if (jsonFiles.length !== 1) {
                const e = new Error('The provided files are not compatible with this model');
                e.name = 'File upload error';
                throw e;
            }
            this.$training.set({ status: 'loading' });
            if (files.length) {
                const jsonData = await readJSONFile(jsonFiles[0]);
                this.loadFn = jsonData.format === 'graph-model' ? loadGraphModel : loadLayersModel;
                this.model = await this.loadFn(browserFiles([jsonFiles[0], ...weightFiles]));
                await this.warmup();
                this.$training.set({
                    status: 'loaded',
                    data: {
                        source: 'file',
                    },
                });
            }
        }
        catch (error) {
            this.$training.set({
                status: 'error',
            });
            throw error;
        }
    }
    async loadFromUrl(url) {
        this.$training.set({
            status: 'loading',
        });
        try {
            const modelJson = await fetch(url).then((res) => res.json());
            this.loadFn = modelJson.format === 'graph-model' ? loadGraphModel : loadLayersModel;
            this.model = await this.loadFn(http(url));
            await this.warmup();
            this.$training.set({
                status: 'loaded',
                data: {
                    source: 'url',
                    url,
                },
            });
        }
        catch (error) {
            // eslint-disable-next-line no-console
            console.log('[tf-model] Loading error', error);
            this.$training.set({
                status: 'error',
            });
            throw error;
        }
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Tfjs_model_view({
            target: t,
            props: {
                title: this.title,
                training: this.$training,
            },
        });
    }
}
__decorate([
    Catch
    // eslint-disable-next-line class-methods-use-this
], TFJSModel.prototype, "train", null);
__decorate([
    Catch
], TFJSModel.prototype, "predict", null);
__decorate([
    Catch
], TFJSModel.prototype, "preprocess", null);
__decorate([
    Catch
], TFJSModel.prototype, "preprocessImage", null);
__decorate([
    Catch
], TFJSModel.prototype, "postprocess", null);
__decorate([
    Catch
], TFJSModel.prototype, "loadFromFiles", null);
__decorate([
    Catch
], TFJSModel.prototype, "loadFromUrl", null);

function tfjsModel(options) {
    return new TFJSModel(options);
}

/* src/components/toggle/toggle.view.svelte generated by Svelte v3.52.0 */

function create_default_slot$8(ctx) {
	let switch_1;
	let updating_checked;
	let current;

	function switch_1_checked_binding(value) {
		/*switch_1_checked_binding*/ ctx[7](value);
	}

	let switch_1_props = {
		disabled: /*$disabled*/ ctx[5],
		text: /*$text*/ ctx[6]
	};

	if (/*$checked*/ ctx[4] !== void 0) {
		switch_1_props.checked = /*$checked*/ ctx[4];
	}

	switch_1 = new Switch({ props: switch_1_props });
	binding_callbacks.push(() => bind(switch_1, 'checked', switch_1_checked_binding));

	return {
		c() {
			create_component(switch_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(switch_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_1_changes = {};
			if (dirty & /*$disabled*/ 32) switch_1_changes.disabled = /*$disabled*/ ctx[5];
			if (dirty & /*$text*/ 64) switch_1_changes.text = /*$text*/ ctx[6];

			if (!updating_checked && dirty & /*$checked*/ 16) {
				updating_checked = true;
				switch_1_changes.checked = /*$checked*/ ctx[4];
				add_flush_callback(() => updating_checked = false);
			}

			switch_1.$set(switch_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(switch_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(switch_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(switch_1, detaching);
		}
	};
}

function create_fragment$g(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				$$slots: { default: [create_default_slot$8] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];

			if (dirty & /*$$scope, $disabled, $text, $checked*/ 368) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$g($$self, $$props, $$invalidate) {
	let $checked,
		$$unsubscribe_checked = noop$1,
		$$subscribe_checked = () => ($$unsubscribe_checked(), $$unsubscribe_checked = subscribe(checked, $$value => $$invalidate(4, $checked = $$value)), checked);

	let $disabled,
		$$unsubscribe_disabled = noop$1,
		$$subscribe_disabled = () => ($$unsubscribe_disabled(), $$unsubscribe_disabled = subscribe(disabled, $$value => $$invalidate(5, $disabled = $$value)), disabled);

	let $text,
		$$unsubscribe_text = noop$1,
		$$subscribe_text = () => ($$unsubscribe_text(), $$unsubscribe_text = subscribe(text, $$value => $$invalidate(6, $text = $$value)), text);

	$$self.$$.on_destroy.push(() => $$unsubscribe_checked());
	$$self.$$.on_destroy.push(() => $$unsubscribe_disabled());
	$$self.$$.on_destroy.push(() => $$unsubscribe_text());
	let { title } = $$props;
	let { text } = $$props;
	$$subscribe_text();
	let { checked } = $$props;
	$$subscribe_checked();
	let { disabled } = $$props;
	$$subscribe_disabled();

	function switch_1_checked_binding(value) {
		$checked = value;
		checked.set($checked);
	}

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('text' in $$props) $$subscribe_text($$invalidate(1, text = $$props.text));
		if ('checked' in $$props) $$subscribe_checked($$invalidate(2, checked = $$props.checked));
		if ('disabled' in $$props) $$subscribe_disabled($$invalidate(3, disabled = $$props.disabled));
	};

	return [
		title,
		text,
		checked,
		disabled,
		$checked,
		$disabled,
		$text,
		switch_1_checked_binding
	];
}

class Toggle_view extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$g, create_fragment$g, safe_not_equal, {
			title: 0,
			text: 1,
			checked: 2,
			disabled: 3
		});
	}
}

class Toggle extends Component {
    constructor(text = 'toggle me') {
        super();
        this.title = 'toggle';
        this.$checked = new Stream(false, true);
        this.$disabled = new Stream(false, true);
        this.$text = new Stream(text, true);
        this.start();
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Toggle_view({
            target: t,
            props: {
                title: this.title,
                text: this.$text,
                checked: this.$checked,
                disabled: this.$disabled,
            },
        });
    }
}

function toggle(...args) {
    return new Toggle(...args);
}

const preventConcurrentCalls = (propertyName) => function preventConcurrentCallsDecorator(target, propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    // eslint-disable-next-line no-param-reassign
    descriptor.value = function checkMethod(...args) {
        const res = this[propertyName].then(() => originalMethod.apply(this, args));
        this[propertyName] = res;
        return res;
    };
    return descriptor;
};

/* src/components/training-history/RunMeta.svelte generated by Svelte v3.52.0 */

function create_else_block$7(ctx) {
	let div;

	return {
		c() {
			div = element("div");

			div.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7l4-4m0 0l4 4m-4-4v18"></path></svg> 
    <p>Select one or several runs to display information</p>`;

			attr(div, "class", "empty svelte-yj1ygt");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop$1,
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (11:0) {#if runs.length > 0}
function create_if_block$b(ctx) {
	let table;
	let current;

	table = new Table({
			props: {
				columns: [{ name: 'field' }, .../*columns*/ ctx[2]],
				provider: /*provider*/ ctx[1],
				selectable: false
			}
		});

	return {
		c() {
			create_component(table.$$.fragment);
		},
		m(target, anchor) {
			mount_component(table, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const table_changes = {};
			if (dirty & /*columns*/ 4) table_changes.columns = [{ name: 'field' }, .../*columns*/ ctx[2]];
			if (dirty & /*provider*/ 2) table_changes.provider = /*provider*/ ctx[1];
			table.$set(table_changes);
		},
		i(local) {
			if (current) return;
			transition_in(table.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(table.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(table, detaching);
		}
	};
}

function create_fragment$f(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$b, create_else_block$7];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*runs*/ ctx[0].length > 0) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$f($$self, $$props, $$invalidate) {
	let columns;
	let rows;
	let data;
	let provider;
	let { runs } = $$props;

	$$self.$$set = $$props => {
		if ('runs' in $$props) $$invalidate(0, runs = $$props.runs);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*runs*/ 1) {
			$$invalidate(2, columns = runs.map((_, i) => ({ name: `Run ${i + 1}` })));
		}

		if ($$self.$$.dirty & /*runs*/ 1) {
			$$invalidate(4, rows = runs.length > 0
			? Object.keys(runs[0]).filter(x => x !== 'logs')
			: []);
		}

		if ($$self.$$.dirty & /*rows, runs*/ 17) {
			$$invalidate(3, data = rows.map(field => runs.map((x, i) => ({ [`Run ${i + 1}`]: x[field] })).reduce((o, x) => ({ ...o, ...x }), { field })));
		}

		if ($$self.$$.dirty & /*data*/ 8) {
			$$invalidate(1, provider = new TableArrayProvider({ data }));
		}
	};

	return [runs, provider, columns, data, rows];
}

class RunMeta extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$f, create_fragment$f, safe_not_equal, { runs: 0 });
	}
}

/* src/components/training-plot/training-plot.view.svelte generated by Svelte v3.52.0 */

function get_each_context$6(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	child_ctx[6] = list;
	child_ctx[7] = i;
	return child_ctx;
}

// (23:2) {#each Object.values(charts) as chart, i}
function create_each_block$6(ctx) {
	let div;
	let i = /*i*/ ctx[7];
	const assign_div = () => /*div_binding*/ ctx[3](div, i);
	const unassign_div = () => /*div_binding*/ ctx[3](null, i);

	return {
		c() {
			div = element("div");
			attr(div, "class", "card inner-card xl:flex-1 svelte-1o4ebpu");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			assign_div();
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (i !== /*i*/ ctx[7]) {
				unassign_div();
				i = /*i*/ ctx[7];
				assign_div();
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			unassign_div();
		}
	};
}

function create_fragment$e(ctx) {
	let div;
	let each_value = Object.values(/*charts*/ ctx[0]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "grid grid-cols-1 gap-1");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			/*div_binding_1*/ ctx[4](div);
		},
		p(ctx, [dirty]) {
			if (dirty & /*refs, charts*/ 5) {
				each_value = Object.values(/*charts*/ ctx[0]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$6(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$6(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
			/*div_binding_1*/ ctx[4](null);
		}
	};
}

function instance$e($$self, $$props, $$invalidate) {
	let { charts } = $$props;
	let container;
	let refs = [];

	onMount(async () => {
		await tick();
		await tick();

		if (Object.keys(charts).length > 1 && container.clientWidth > 700) {
			$$invalidate(1, container.style.gridTemplateColumns = 'repeat(2, minmax(0, 1fr))', container);
		}

		for (const [i, chart] of Object.values(charts).entries()) {
			chart.mount(refs[i]);
		}
	});

	onDestroy(() => {
		for (const chart of Object.values(charts)) {
			chart.destroy();
		}
	});

	function div_binding($$value, i) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			refs[i] = $$value;
			$$invalidate(2, refs);
		});
	}

	function div_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			container = $$value;
			$$invalidate(1, container);
		});
	}

	$$self.$$set = $$props => {
		if ('charts' in $$props) $$invalidate(0, charts = $$props.charts);
	};

	return [charts, container, refs, div_binding, div_binding_1];
}

class Training_plot_view extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$e, create_fragment$e, safe_not_equal, { charts: 0 });
	}
}

class TrainingPlot extends Component {
    constructor(model, logs = {
        loss: ['loss', 'lossVal'],
        accuracy: ['acc', 'accVal'],
    }) {
        super();
        this.model = model;
        this.title = 'training plot';
        this.charts = {};
        if (!model) {
            const e = new Error('[training plot] No model was provided');
            e.name = 'Component Compatibility Error';
            throwError(e);
        }
        if (!model.$training) {
            const e = new Error('[training plot] The provided model is incompatible with the training plot component, missing `$training` stream');
            e.name = 'Component Compatibility Error';
            throwError(e);
        }
        let processedLogs = logs;
        if (typeof logs === 'string') {
            processedLogs = [logs];
        }
        if (Array.isArray(processedLogs)) {
            processedLogs = processedLogs.reduce((x, y) => ({ ...x, [y]: y }), {});
        }
        const streams = {};
        for (const [key, val] of Object.entries(processedLogs)) {
            const x = Array.isArray(val) ? val : [val];
            this.charts[key] = genericChart({
                preset: 'line-fast',
                options: {
                    xlabel: 'Epoch',
                    ylabel: key,
                },
            });
            for (const y of x) {
                if (!Object.keys(streams).includes(y)) {
                    streams[y] = new Stream([], true);
                }
                this.charts[key].addSeries(streams[y], y);
            }
            this.charts[key].title = key;
        }
        function resetCharts() {
            for (const stream of Object.values(streams)) {
                stream.set([]);
            }
        }
        model.$training.subscribe((x) => {
            if (x.status === 'start') {
                resetCharts();
            }
            else if (x.data) {
                for (const [key, val] of Object.entries(x.data)) {
                    if (!Object.keys(streams).includes(key))
                        return;
                    if (Array.isArray(val)) {
                        streams[key].set(val.map((y, j) => ({ x: j + 1, y })));
                    }
                    else {
                        streams[key].set(streams[key].get().concat([{ x: streams[key].get().length + 1, y: val }]));
                    }
                }
            }
        });
        this.start();
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Training_plot_view({
            target: t,
            props: {
                charts: this.charts,
            },
        });
    }
}

function trainingPlot(...args) {
    return new TrainingPlot(...args);
}

/* src/components/training-history/RunGraphs.svelte generated by Svelte v3.52.0 */

function create_else_block$6(ctx) {
	let div;

	return {
		c() {
			div = element("div");

			div.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7l4-4m0 0l4 4m-4-4v18"></path></svg> 
    <p>Select one or several runs to display information</p>`;

			attr(div, "class", "empty svelte-yj1ygt");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (36:0) {#if logs.length > 0}
function create_if_block$a(ctx) {
	let div;

	return {
		c() {
			div = element("div");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			/*div_binding*/ ctx[7](div);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(div);
			/*div_binding*/ ctx[7](null);
		}
	};
}

function create_fragment$d(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*logs*/ ctx[0].length > 0) return create_if_block$a;
		return create_else_block$6;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$d($$self, $$props, $$invalidate) {
	let indexedLogs;
	let logSpec;
	let { names } = $$props;
	let { logs } = $$props;
	let chartElt;
	let logKeys;
	let chart;

	onDestroy(() => {
		if (chart) {
			chart.destroy();
		}
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			chartElt = $$value;
			$$invalidate(1, chartElt);
		});
	}

	$$self.$$set = $$props => {
		if ('names' in $$props) $$invalidate(2, names = $$props.names);
		if ('logs' in $$props) $$invalidate(0, logs = $$props.logs);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*logs, logKeys*/ 9) {
			{
				$$invalidate(3, logKeys = Array.from(new Set(logs.map(Object.keys).flat())));
				logKeys.sort();
			}
		}

		if ($$self.$$.dirty & /*logs, names*/ 5) {
			$$invalidate(6, indexedLogs = logs.map((x, i) => Object.entries(x).reduce((a, [key, val]) => ({ ...a, [`${key} (${names[i]})`]: val }), {})).reduce((a, b) => ({ ...a, ...b }), {}));
		}

		if ($$self.$$.dirty & /*logKeys, indexedLogs*/ 72) {
			$$invalidate(5, logSpec = logKeys.reduce(
				(res, key) => ({
					...res,
					[key]: Object.keys(indexedLogs).filter(k => k.startsWith(`${key} (`))
				}),
				{}
			));
		}

		if ($$self.$$.dirty & /*chart, indexedLogs, logSpec, chartElt*/ 114) {
			{
				if (chart) {
					chart.destroy();
				}

				$$invalidate(4, chart = trainingPlot(
					{
						$training: new Stream({ status: 'success', data: indexedLogs }, true)
					},
					logSpec
				));

				chart.mount(chartElt);
			}
		}
	};

	return [logs, chartElt, names, logKeys, chart, logSpec, indexedLogs, div_binding];
}

class RunGraphs extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$d, create_fragment$d, safe_not_equal, { names: 2, logs: 0 });
	}
}

/* src/components/training-history/training-history.view.svelte generated by Svelte v3.52.0 */

function get_each_context$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[13] = list[i];
	child_ctx[15] = i;
	return child_ctx;
}

// (73:6) <Tab>
function create_default_slot_10(ctx) {
	let t;

	return {
		c() {
			t = text$1("Graphs");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (74:6) <Tab>
function create_default_slot_9(ctx) {
	let t;

	return {
		c() {
			t = text$1("Metadata");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (75:6) <Tab>
function create_default_slot_8(ctx) {
	let t;

	return {
		c() {
			t = text$1("Parameters");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (76:6) <Tab>
function create_default_slot_7(ctx) {
	let t;

	return {
		c() {
			t = text$1("Model Summary");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (72:4) <TabList>
function create_default_slot_6(ctx) {
	let tab0;
	let t0;
	let tab1;
	let t1;
	let tab2;
	let t2;
	let tab3;
	let current;

	tab0 = new Tab({
			props: {
				$$slots: { default: [create_default_slot_10] },
				$$scope: { ctx }
			}
		});

	tab1 = new Tab({
			props: {
				$$slots: { default: [create_default_slot_9] },
				$$scope: { ctx }
			}
		});

	tab2 = new Tab({
			props: {
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			}
		});

	tab3 = new Tab({
			props: {
				$$slots: { default: [create_default_slot_7] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(tab0.$$.fragment);
			t0 = space();
			create_component(tab1.$$.fragment);
			t1 = space();
			create_component(tab2.$$.fragment);
			t2 = space();
			create_component(tab3.$$.fragment);
		},
		m(target, anchor) {
			mount_component(tab0, target, anchor);
			insert(target, t0, anchor);
			mount_component(tab1, target, anchor);
			insert(target, t1, anchor);
			mount_component(tab2, target, anchor);
			insert(target, t2, anchor);
			mount_component(tab3, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const tab0_changes = {};

			if (dirty & /*$$scope*/ 65536) {
				tab0_changes.$$scope = { dirty, ctx };
			}

			tab0.$set(tab0_changes);
			const tab1_changes = {};

			if (dirty & /*$$scope*/ 65536) {
				tab1_changes.$$scope = { dirty, ctx };
			}

			tab1.$set(tab1_changes);
			const tab2_changes = {};

			if (dirty & /*$$scope*/ 65536) {
				tab2_changes.$$scope = { dirty, ctx };
			}

			tab2.$set(tab2_changes);
			const tab3_changes = {};

			if (dirty & /*$$scope*/ 65536) {
				tab3_changes.$$scope = { dirty, ctx };
			}

			tab3.$set(tab3_changes);
		},
		i(local) {
			if (current) return;
			transition_in(tab0.$$.fragment, local);
			transition_in(tab1.$$.fragment, local);
			transition_in(tab2.$$.fragment, local);
			transition_in(tab3.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tab0.$$.fragment, local);
			transition_out(tab1.$$.fragment, local);
			transition_out(tab2.$$.fragment, local);
			transition_out(tab3.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(tab0, detaching);
			if (detaching) detach(t0);
			destroy_component(tab1, detaching);
			if (detaching) detach(t1);
			destroy_component(tab2, detaching);
			if (detaching) detach(t2);
			destroy_component(tab3, detaching);
		}
	};
}

// (79:4) <TabPanel>
function create_default_slot_5(ctx) {
	let rungraphs;
	let current;

	rungraphs = new RunGraphs({
			props: {
				logs: /*$selection*/ ctx[4].map(func_1),
				names: /*$selection*/ ctx[4].map(func_2)
			}
		});

	return {
		c() {
			create_component(rungraphs.$$.fragment);
		},
		m(target, anchor) {
			mount_component(rungraphs, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const rungraphs_changes = {};
			if (dirty & /*$selection*/ 16) rungraphs_changes.logs = /*$selection*/ ctx[4].map(func_1);
			if (dirty & /*$selection*/ 16) rungraphs_changes.names = /*$selection*/ ctx[4].map(func_2);
			rungraphs.$set(rungraphs_changes);
		},
		i(local) {
			if (current) return;
			transition_in(rungraphs.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(rungraphs.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(rungraphs, detaching);
		}
	};
}

// (83:4) <TabPanel>
function create_default_slot_4(ctx) {
	let runmeta;
	let current;
	runmeta = new RunMeta({ props: { runs: /*$selection*/ ctx[4] } });

	return {
		c() {
			create_component(runmeta.$$.fragment);
		},
		m(target, anchor) {
			mount_component(runmeta, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const runmeta_changes = {};
			if (dirty & /*$selection*/ 16) runmeta_changes.runs = /*$selection*/ ctx[4];
			runmeta.$set(runmeta_changes);
		},
		i(local) {
			if (current) return;
			transition_in(runmeta.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(runmeta.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(runmeta, detaching);
		}
	};
}

// (87:4) <TabPanel>
function create_default_slot_3(ctx) {
	let runmeta;
	let current;

	runmeta = new RunMeta({
			props: { runs: /*$selection*/ ctx[4].map(func_3) }
		});

	return {
		c() {
			create_component(runmeta.$$.fragment);
		},
		m(target, anchor) {
			mount_component(runmeta, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const runmeta_changes = {};
			if (dirty & /*$selection*/ 16) runmeta_changes.runs = /*$selection*/ ctx[4].map(func_3);
			runmeta.$set(runmeta_changes);
		},
		i(local) {
			if (current) return;
			transition_in(runmeta.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(runmeta.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(runmeta, detaching);
		}
	};
}

// (93:8) {#each $selection.map((x) => x.model?.summary || 'No summary available') as summary, i}
function create_each_block$5(ctx) {
	let div1;
	let h2;
	let t0;
	let t1_value = /*i*/ ctx[15] + 1 + "";
	let t1;
	let t2;
	let div0;
	let pre;
	let t3_value = /*summary*/ ctx[13] + "";
	let t3;
	let br;
	let t4;

	return {
		c() {
			div1 = element("div");
			h2 = element("h2");
			t0 = text$1("Model ");
			t1 = text$1(t1_value);
			t2 = space();
			div0 = element("div");
			pre = element("pre");
			t3 = text$1(t3_value);
			br = element("br");
			t4 = space();
			attr(div0, "class", "summary svelte-y4izzs");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, h2);
			append(h2, t0);
			append(h2, t1);
			append(div1, t2);
			append(div1, div0);
			append(div0, pre);
			append(pre, t3);
			append(pre, br);
			append(div1, t4);
		},
		p(ctx, dirty) {
			if (dirty & /*$selection*/ 16 && t3_value !== (t3_value = /*summary*/ ctx[13] + "")) set_data(t3, t3_value);
		},
		d(detaching) {
			if (detaching) detach(div1);
		}
	};
}

// (91:4) <TabPanel>
function create_default_slot_2$3(ctx) {
	let div;
	let each_value = /*$selection*/ ctx[4].map(func_4);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "summaries svelte-y4izzs");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, dirty) {
			if (dirty & /*$selection*/ 16) {
				each_value = /*$selection*/ ctx[4].map(func_4);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$5(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$5(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (71:2) <Tabs>
function create_default_slot_1$6(ctx) {
	let tablist;
	let t0;
	let tabpanel0;
	let t1;
	let tabpanel1;
	let t2;
	let tabpanel2;
	let t3;
	let tabpanel3;
	let current;

	tablist = new TabList({
			props: {
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			}
		});

	tabpanel0 = new TabPanel({
			props: {
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			}
		});

	tabpanel1 = new TabPanel({
			props: {
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			}
		});

	tabpanel2 = new TabPanel({
			props: {
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			}
		});

	tabpanel3 = new TabPanel({
			props: {
				$$slots: { default: [create_default_slot_2$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(tablist.$$.fragment);
			t0 = space();
			create_component(tabpanel0.$$.fragment);
			t1 = space();
			create_component(tabpanel1.$$.fragment);
			t2 = space();
			create_component(tabpanel2.$$.fragment);
			t3 = space();
			create_component(tabpanel3.$$.fragment);
		},
		m(target, anchor) {
			mount_component(tablist, target, anchor);
			insert(target, t0, anchor);
			mount_component(tabpanel0, target, anchor);
			insert(target, t1, anchor);
			mount_component(tabpanel1, target, anchor);
			insert(target, t2, anchor);
			mount_component(tabpanel2, target, anchor);
			insert(target, t3, anchor);
			mount_component(tabpanel3, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const tablist_changes = {};

			if (dirty & /*$$scope*/ 65536) {
				tablist_changes.$$scope = { dirty, ctx };
			}

			tablist.$set(tablist_changes);
			const tabpanel0_changes = {};

			if (dirty & /*$$scope, $selection*/ 65552) {
				tabpanel0_changes.$$scope = { dirty, ctx };
			}

			tabpanel0.$set(tabpanel0_changes);
			const tabpanel1_changes = {};

			if (dirty & /*$$scope, $selection*/ 65552) {
				tabpanel1_changes.$$scope = { dirty, ctx };
			}

			tabpanel1.$set(tabpanel1_changes);
			const tabpanel2_changes = {};

			if (dirty & /*$$scope, $selection*/ 65552) {
				tabpanel2_changes.$$scope = { dirty, ctx };
			}

			tabpanel2.$set(tabpanel2_changes);
			const tabpanel3_changes = {};

			if (dirty & /*$$scope, $selection*/ 65552) {
				tabpanel3_changes.$$scope = { dirty, ctx };
			}

			tabpanel3.$set(tabpanel3_changes);
		},
		i(local) {
			if (current) return;
			transition_in(tablist.$$.fragment, local);
			transition_in(tabpanel0.$$.fragment, local);
			transition_in(tabpanel1.$$.fragment, local);
			transition_in(tabpanel2.$$.fragment, local);
			transition_in(tabpanel3.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tablist.$$.fragment, local);
			transition_out(tabpanel0.$$.fragment, local);
			transition_out(tabpanel1.$$.fragment, local);
			transition_out(tabpanel2.$$.fragment, local);
			transition_out(tabpanel3.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(tablist, detaching);
			if (detaching) detach(t0);
			destroy_component(tabpanel0, detaching);
			if (detaching) detach(t1);
			destroy_component(tabpanel1, detaching);
			if (detaching) detach(t2);
			destroy_component(tabpanel2, detaching);
			if (detaching) detach(t3);
			destroy_component(tabpanel3, detaching);
		}
	};
}

// (56:0) <ViewContainer {title}>
function create_default_slot$7(ctx) {
	let table;
	let updating_selection;
	let t0;
	let br;
	let t1;
	let tabs;
	let current;

	function table_selection_binding(value) {
		/*table_selection_binding*/ ctx[10](value);
	}

	let table_props = {
		columns: /*columns*/ ctx[7],
		provider: /*provider*/ ctx[6],
		actions: [.../*actions*/ ctx[1].map(func), { name: 'delete', confirm: true }]
	};

	if (/*$selection*/ ctx[4] !== void 0) {
		table_props.selection = /*$selection*/ ctx[4];
	}

	table = new Table({ props: table_props });
	binding_callbacks.push(() => bind(table, 'selection', table_selection_binding));
	/*table_binding*/ ctx[11](table);
	table.$on("select", /*select_handler*/ ctx[12]);

	tabs = new Tabs({
			props: {
				$$slots: { default: [create_default_slot_1$6] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(table.$$.fragment);
			t0 = space();
			br = element("br");
			t1 = space();
			create_component(tabs.$$.fragment);
		},
		m(target, anchor) {
			mount_component(table, target, anchor);
			insert(target, t0, anchor);
			insert(target, br, anchor);
			insert(target, t1, anchor);
			mount_component(tabs, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const table_changes = {};
			if (dirty & /*actions*/ 2) table_changes.actions = [.../*actions*/ ctx[1].map(func), { name: 'delete', confirm: true }];

			if (!updating_selection && dirty & /*$selection*/ 16) {
				updating_selection = true;
				table_changes.selection = /*$selection*/ ctx[4];
				add_flush_callback(() => updating_selection = false);
			}

			table.$set(table_changes);
			const tabs_changes = {};

			if (dirty & /*$$scope, $selection*/ 65552) {
				tabs_changes.$$scope = { dirty, ctx };
			}

			tabs.$set(tabs_changes);
		},
		i(local) {
			if (current) return;
			transition_in(table.$$.fragment, local);
			transition_in(tabs.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(table.$$.fragment, local);
			transition_out(tabs.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			/*table_binding*/ ctx[11](null);
			destroy_component(table, detaching);
			if (detaching) detach(t0);
			if (detaching) detach(br);
			if (detaching) detach(t1);
			destroy_component(tabs, detaching);
		}
	};
}

function create_fragment$c(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				$$slots: { default: [create_default_slot$7] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];

			if (dirty & /*$$scope, $selection, actions, mainTable*/ 65562) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

const func = name => typeof name === 'string' ? { name } : name;
const func_1 = x => x.logs;
const func_2 = x => x.name;
const func_3 = x => x.params;
const func_4 = x => x.model?.summary || 'No summary available';

function instance$c($$self, $$props, $$invalidate) {
	let $selection,
		$$unsubscribe_selection = noop$1,
		$$subscribe_selection = () => ($$unsubscribe_selection(), $$unsubscribe_selection = subscribe(selection, $$value => $$invalidate(4, $selection = $$value)), selection);

	$$self.$$.on_destroy.push(() => $$unsubscribe_selection());
	let { title } = $$props;
	let { service } = $$props;
	let { metrics } = $$props;
	let { actions } = $$props;
	let { selection } = $$props;
	$$subscribe_selection();
	const dispatch = createEventDispatcher();

	const provider = new TableServiceProvider({
			service,
			transform: {
				...metrics.reduce(
					(res, metricName) => ({
						...res,
						[metricName]: x => {
							if (metricName in x.logs) {
								return x.logs[metricName][x.logs[metricName].length - 1];
							}

							return 'metrics not found';
						}
					}),
					{}
				),
				...actions.reduce(
					(res, action) => ({
						...res,
						[typeof action === 'string' ? action : action.name]: () => typeof action === 'string' ? action : action.name
					}),
					{}
				)
			}
		});

	provider.data.subscribe(() => {
		selection.set([]);
	});

	const columns = [
		{ name: 'name', sortable: true },
		{
			name: 'start',
			sortable: true,
			type: 'date'
		},
		...metrics.map(metricName => ({ name: metricName })),
		{ name: 'epochs' },
		{ name: 'status' },
		...actions.map(action => ({
			name: typeof action === 'string' ? action : action.name,
			type: 'action'
		}))
	];

	let mainTable;

	onMount(async () => {
		await tick();
		await tick();

		for (const action of actions) {
			const name = typeof action === 'string' ? action : action.name;

			mainTable.$on(name, ({ detail }) => {
				dispatch(name, detail);
			});
		}
	});

	function table_selection_binding(value) {
		$selection = value;
		selection.set($selection);
	}

	function table_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			mainTable = $$value;
			$$invalidate(3, mainTable);
		});
	}

	const select_handler = ({ detail }) => dispatch('load', detail);

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('service' in $$props) $$invalidate(8, service = $$props.service);
		if ('metrics' in $$props) $$invalidate(9, metrics = $$props.metrics);
		if ('actions' in $$props) $$invalidate(1, actions = $$props.actions);
		if ('selection' in $$props) $$subscribe_selection($$invalidate(2, selection = $$props.selection));
	};

	return [
		title,
		actions,
		selection,
		mainTable,
		$selection,
		dispatch,
		provider,
		columns,
		service,
		metrics,
		table_selection_binding,
		table_binding,
		select_handler
	];
}

class Training_history_view extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$c, create_fragment$c, safe_not_equal, {
			title: 0,
			service: 8,
			metrics: 9,
			actions: 1,
			selection: 2
		});
	}
}

function appendLogs(logs, d) {
    const l = { ...logs };
    for (const [key, val] of Object.entries(d)) {
        l[key] = (l[key] || []).concat([val]);
    }
    return l;
}
const defaultOptions = {
    metrics: ['accuracy', 'accuracyVal', 'loss', 'lossVal'],
    actions: [],
};
class TrainingHistory extends Component {
    constructor(dataStore, options = {}) {
        super();
        this.dataStore = dataStore;
        this.title = 'Training History';
        this.$selection = new Stream([], true);
        this.$actions = new Stream(null).skip(1);
        this.ready = Promise.resolve();
        this.stopTracking = noop;
        this.lock = Promise.resolve();
        this.options = { ...defaultOptions, ...options };
        this.lock = this.lock.then(noop);
        this.start();
        this.ready = this.ready
            .then(() => this.dataStore.connect())
            .then(() => {
            this.runService = this.dataStore.service('runs');
        })
            .catch(() => {
            logger.log('[dataset] dataStore connection failed');
        });
    }
    track(model, basename = 'anonymous') {
        this.ready
            .then(() => {
            this.stopTracking();
            this.model = model;
            this.modelName = basename;
            return this.runService.find({
                query: {
                    basename,
                    $sort: {
                        createdAt: -1,
                    },
                    $select: ['name'],
                    $limit: 1,
                },
            });
        })
            .then(({ data: foundRuns }) => {
            if (foundRuns.length > 0) {
                return parseInt(foundRuns[0].name.split(`${basename}-`)[1]) + 1;
            }
            return 1;
        })
            .then((nextIndex) => {
            this.nextIndex = nextIndex;
            this.crtRun = null;
            this.stopTracking = this.model
                ? this.model.$training.subscribe(this.trackTrainingStream)
                : noop;
        });
        return this;
    }
    async trackTrainingStream(x) {
        if (x.status === 'start') {
            this.crtRun = await this.runService.create({
                name: `${this.modelName}-${this.nextIndex++}`,
                basename: this.modelName,
                start: new Date(Date.now()).toISOString(),
                source: 'js',
                status: x.status,
                epochs: x.epochs,
                params: Object.entries(this.model.parameters)
                    .map(([key, s]) => ({ [key]: s.get() }))
                    .reduce((o, y) => ({ ...o, ...y }), {}),
                logs: {},
            });
        }
        else if (x.status === 'epoch') {
            this.runService.patch(this.crtRun.id, {
                status: x.status,
                epoch: x.epoch,
                logs: appendLogs(this.crtRun.logs, x.data),
            });
        }
        else if (x.status === 'success') {
            const modelId = await this.model.save(this.dataStore, this.modelName, {});
            this.runService.patch(this.crtRun.id, {
                status: x.status,
                epoch: x.epoch,
                logs: x.data,
                checkpoints: (this.crtRun.checkpoints || []).concat([
                    {
                        id: modelId,
                        name: `${this.crtRun.name}@final`,
                        service: this.model.serviceName,
                    },
                ]),
            });
        }
        else if (x.status === 'error') {
            this.runService.patch(this.crtRun.id, {
                status: x.status,
            });
        }
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.ready.then(() => {
            this.$$.app = new Training_history_view({
                target: t,
                props: {
                    title: this.title,
                    service: this.runService,
                    metrics: this.options.metrics,
                    actions: this.options.actions,
                    selection: this.$selection,
                },
            });
            for (const action of this.options.actions) {
                const name = typeof action === 'string' ? action : action.name;
                this.$$.app.$on(name, ({ detail }) => {
                    this.$actions.set({ name, data: detail });
                });
            }
        });
    }
}
__decorate([
    preventConcurrentCalls('lock')
], TrainingHistory.prototype, "trackTrainingStream", null);

function trainingHistory(...args) {
    return new TrainingHistory(...args);
}

/**
 * A Multi-layer Perceptron for regression with two hidden layers
 */
class Umap extends Model {
    constructor({ nComponents = 2, nNeighbors = 15, minDist = 0.1, spread = 1, supervised = false, } = {}) {
        super();
        this.title = 'UMAP';
        this.serviceName = 'umap';
        this.parameters = {
            nComponents: new Stream(nComponents, true),
            nNeighbors: new Stream(nNeighbors, true),
            minDist: new Stream(minDist, true),
            spread: new Stream(spread, true),
            supervised: new Stream(supervised, true),
        };
    }
    async train(dataset) {
        this.$training.set({ status: 'start', epochs: -1 });
        const items = isDataset(dataset) ? dataset.items() : dataset;
        const instances = await items.toArray();
        const umapData = instances.reduce((d, { x }) => d.concat([x]), []);
        this.model = new UMAP({ nComponents: this.parameters.nComponents.get() });
        if (this.parameters.supervised.get()) {
            const labels = instances.map((x) => x.y);
            this.model.setSupervisedProjection(labels);
        }
        const nEpochs = this.model.initializeFit(umapData);
        this.$training.set({ status: 'start', epochs: nEpochs });
        for (let i = 0; i < nEpochs; i++) {
            this.model.step();
            this.$training.set({
                status: 'epoch',
                epoch: i + 1,
                epochs: nEpochs,
                data: { embedding: this.model.getEmbedding() },
            });
        }
        this.$training.set({
            status: 'success',
            data: { embedding: this.model.getEmbedding() },
        });
    }
    async predict(x) {
        if (!this.model)
            return null;
        return this.model.transform([x])[0];
    }
    // eslint-disable-next-line class-methods-use-this
    save() {
        throw new Error('Umap does not support saving');
    }
    // eslint-disable-next-line class-methods-use-this
    load() {
        throw new Error('Umap does not support loading');
    }
    // eslint-disable-next-line class-methods-use-this
    download() {
        throw new Error('Umap does not support downloading');
    }
    // eslint-disable-next-line class-methods-use-this
    upload() {
        throw new Error('Umap does not support uploading');
    }
}

function umap(...args) {
    return new Umap(...args);
}

/* src/components/webcam/webcam.view.svelte generated by Svelte v3.52.0 */

function create_if_block$9(ctx) {
	let spinner;
	let current;
	spinner = new Spinner({});

	return {
		c() {
			create_component(spinner.$$.fragment);
		},
		m(target, anchor) {
			mount_component(spinner, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(spinner.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(spinner.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(spinner, detaching);
		}
	};
}

// (28:0) <ViewContainer {title}>
function create_default_slot$6(ctx) {
	let div3;
	let div1;
	let div0;
	let switch_1;
	let updating_checked;
	let t0;
	let div2;
	let t1;
	let video;
	let div2_resize_listener;
	let current;

	function switch_1_checked_binding(value) {
		/*switch_1_checked_binding*/ ctx[10](value);
	}

	let switch_1_props = { text: "activate video" };

	if (/*$active*/ ctx[7] !== void 0) {
		switch_1_props.checked = /*$active*/ ctx[7];
	}

	switch_1 = new Switch({ props: switch_1_props });
	binding_callbacks.push(() => bind(switch_1, 'checked', switch_1_checked_binding));
	let if_block = /*$active*/ ctx[7] && !/*$ready*/ ctx[8] && create_if_block$9();

	return {
		c() {
			div3 = element("div");
			div1 = element("div");
			div0 = element("div");
			create_component(switch_1.$$.fragment);
			t0 = space();
			div2 = element("div");
			if (if_block) if_block.c();
			t1 = space();
			video = element("video");
			set_style(div1, "margin-left", "10px");
			attr(video, "id", "webcam-video");
			attr(video, "class", "max-w-none svelte-18llgdn");

			set_style(video, "width", /*width*/ ctx[1] > /*height*/ ctx[2]
			? `${/*webcamContainerWidth*/ ctx[6]}px`
			: 'auto');

			set_style(video, "height", /*width*/ ctx[1] > /*height*/ ctx[2]
			? 'auto'
			: `${/*webcamContainerWidth*/ ctx[6] * /*height*/ ctx[2] / /*width*/ ctx[1]}px`);

			video.autoplay = true;
			video.muted = true;
			video.playsInline = true;
			attr(div2, "class", "webcam-container svelte-18llgdn");
			set_style(div2, "flex-direction", /*width*/ ctx[1] > /*height*/ ctx[2] ? 'column' : 'row');
			set_style(div2, "height", /*webcamContainerWidth*/ ctx[6] * /*height*/ ctx[2] / /*width*/ ctx[1] + "px");
			add_render_callback(() => /*div2_elementresize_handler*/ ctx[12].call(div2));
			attr(div3, "class", "webcam svelte-18llgdn");
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div1);
			append(div1, div0);
			mount_component(switch_1, div0, null);
			append(div3, t0);
			append(div3, div2);
			if (if_block) if_block.m(div2, null);
			append(div2, t1);
			append(div2, video);
			/*video_binding*/ ctx[11](video);
			div2_resize_listener = add_resize_listener(div2, /*div2_elementresize_handler*/ ctx[12].bind(div2));
			current = true;
		},
		p(ctx, dirty) {
			const switch_1_changes = {};

			if (!updating_checked && dirty & /*$active*/ 128) {
				updating_checked = true;
				switch_1_changes.checked = /*$active*/ ctx[7];
				add_flush_callback(() => updating_checked = false);
			}

			switch_1.$set(switch_1_changes);

			if (/*$active*/ ctx[7] && !/*$ready*/ ctx[8]) {
				if (if_block) {
					if (dirty & /*$active, $ready*/ 384) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$9();
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div2, t1);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty & /*width, height, webcamContainerWidth*/ 70) {
				set_style(video, "width", /*width*/ ctx[1] > /*height*/ ctx[2]
				? `${/*webcamContainerWidth*/ ctx[6]}px`
				: 'auto');
			}

			if (!current || dirty & /*width, height, webcamContainerWidth*/ 70) {
				set_style(video, "height", /*width*/ ctx[1] > /*height*/ ctx[2]
				? 'auto'
				: `${/*webcamContainerWidth*/ ctx[6] * /*height*/ ctx[2] / /*width*/ ctx[1]}px`);
			}

			if (!current || dirty & /*width, height*/ 6) {
				set_style(div2, "flex-direction", /*width*/ ctx[1] > /*height*/ ctx[2] ? 'column' : 'row');
			}

			if (!current || dirty & /*webcamContainerWidth, height, width*/ 70) {
				set_style(div2, "height", /*webcamContainerWidth*/ ctx[6] * /*height*/ ctx[2] / /*width*/ ctx[1] + "px");
			}
		},
		i(local) {
			if (current) return;
			transition_in(switch_1.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(switch_1.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div3);
			destroy_component(switch_1);
			if (if_block) if_block.d();
			/*video_binding*/ ctx[11](null);
			div2_resize_listener();
		}
	};
}

function create_fragment$b(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: /*title*/ ctx[0],
				$$slots: { default: [create_default_slot$6] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*title*/ 1) viewcontainer_changes.title = /*title*/ ctx[0];

			if (dirty & /*$$scope, width, height, webcamContainerWidth, videoElement, $active, $ready*/ 16870) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$b($$self, $$props, $$invalidate) {
	let $active,
		$$unsubscribe_active = noop$1,
		$$subscribe_active = () => ($$unsubscribe_active(), $$unsubscribe_active = subscribe(active, $$value => $$invalidate(7, $active = $$value)), active);

	let $ready,
		$$unsubscribe_ready = noop$1,
		$$subscribe_ready = () => ($$unsubscribe_ready(), $$unsubscribe_ready = subscribe(ready, $$value => $$invalidate(8, $ready = $$value)), ready);

	$$self.$$.on_destroy.push(() => $$unsubscribe_active());
	$$self.$$.on_destroy.push(() => $$unsubscribe_ready());
	let { title } = $$props;
	let { width } = $$props;
	let { height } = $$props;
	let { active } = $$props;
	$$subscribe_active();
	let { mediaStream } = $$props;
	let { ready } = $$props;
	$$subscribe_ready();
	let videoElement;
	let webcamContainerWidth;
	let unSub = noop;

	onMount(async () => {
		await tick();
		await tick();

		unSub = mediaStream.subscribe(s => {
			if (s) {
				$$invalidate(5, videoElement.srcObject = s, videoElement);
			}
		});
	});

	onDestroy(() => {
		unSub();
	});

	function switch_1_checked_binding(value) {
		$active = value;
		active.set($active);
	}

	function video_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			videoElement = $$value;
			$$invalidate(5, videoElement);
		});
	}

	function div2_elementresize_handler() {
		webcamContainerWidth = this.clientWidth;
		$$invalidate(6, webcamContainerWidth);
	}

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('width' in $$props) $$invalidate(1, width = $$props.width);
		if ('height' in $$props) $$invalidate(2, height = $$props.height);
		if ('active' in $$props) $$subscribe_active($$invalidate(3, active = $$props.active));
		if ('mediaStream' in $$props) $$invalidate(9, mediaStream = $$props.mediaStream);
		if ('ready' in $$props) $$subscribe_ready($$invalidate(4, ready = $$props.ready));
	};

	return [
		title,
		width,
		height,
		active,
		ready,
		videoElement,
		webcamContainerWidth,
		$active,
		$ready,
		mediaStream,
		switch_1_checked_binding,
		video_binding,
		div2_elementresize_handler
	];
}

class Webcam_view extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$b, create_fragment$b, safe_not_equal, {
			title: 0,
			width: 1,
			height: 2,
			active: 3,
			mediaStream: 9,
			ready: 4
		});
	}
}

var _Webcam_width, _Webcam_height, _Webcam_webcamWidth, _Webcam_webcamHeight, _Webcam_videoElement, _Webcam_thumbnailWidth, _Webcam_unsubActive, _Webcam_stopStreaming, _Webcam_thumbnailCanvas, _Webcam_thumbnailCtx, _Webcam_captureCanvas, _Webcam_captureCtx;
function requestInterval(fn, delay) {
    let start = new Date().getTime();
    let stop = false;
    let animationFrame;
    function loop() {
        if (stop) {
            return;
        }
        const current = new Date().getTime();
        if (current - start >= delay) {
            fn();
            start = new Date().getTime();
        }
        animationFrame = window.requestAnimationFrame(loop);
    }
    animationFrame = window.requestAnimationFrame(loop);
    return function clear() {
        window.cancelAnimationFrame(animationFrame);
        stop = true;
    };
}
class Webcam extends Component {
    constructor({ width = 224, height = 224, period = 50 } = {}) {
        super();
        this.title = 'webcam';
        this.$active = new Stream(false, true);
        this.$ready = new Stream(false, true);
        this.$mediastream = new Stream(undefined, true);
        this.$images = new Stream(never(), true);
        this.$thumbnails = new Stream(never(), true);
        // Webcam stuff
        _Webcam_width.set(this, void 0);
        _Webcam_height.set(this, void 0);
        _Webcam_webcamWidth.set(this, void 0);
        _Webcam_webcamHeight.set(this, void 0);
        _Webcam_videoElement.set(this, document.createElement('video'));
        _Webcam_thumbnailWidth.set(this, 60);
        _Webcam_unsubActive.set(this, noop);
        _Webcam_stopStreaming.set(this, noop);
        _Webcam_thumbnailCanvas.set(this, void 0);
        _Webcam_thumbnailCtx.set(this, void 0);
        _Webcam_captureCanvas.set(this, void 0);
        _Webcam_captureCtx.set(this, void 0);
        __classPrivateFieldSet(this, _Webcam_width, width, "f");
        __classPrivateFieldSet(this, _Webcam_height, height, "f");
        this.period = period;
        this.setupCapture();
        this.start();
        __classPrivateFieldGet(this, _Webcam_videoElement, "f").autoplay = true;
        __classPrivateFieldSet(this, _Webcam_unsubActive, this.$active.subscribe((v) => {
            __classPrivateFieldGet(this, _Webcam_stopStreaming, "f").call(this);
            if (v) {
                this.loadCameras();
                __classPrivateFieldSet(this, _Webcam_stopStreaming, requestInterval(this.process, this.period), "f");
            }
            else {
                this.stopCamera();
            }
        }), "f");
    }
    getWidth() {
        return __classPrivateFieldGet(this, _Webcam_width, "f");
    }
    mount(target) {
        const t = target || document.querySelector(`#${this.id}`);
        if (!t)
            return;
        this.destroy();
        this.$$.app = new Webcam_view({
            target: t,
            props: {
                title: this.title,
                width: __classPrivateFieldGet(this, _Webcam_width, "f"),
                height: __classPrivateFieldGet(this, _Webcam_height, "f"),
                active: this.$active,
                mediaStream: this.$mediastream,
                ready: this.$ready,
            },
        });
    }
    stop() {
        super.stop();
        __classPrivateFieldGet(this, _Webcam_stopStreaming, "f").call(this);
        __classPrivateFieldGet(this, _Webcam_unsubActive, "f").call(this);
        if (this.$mediastream.get()) {
            for (const track of this.$mediastream.get().getTracks()) {
                track.stop();
            }
        }
    }
    setupCapture() {
        __classPrivateFieldSet(this, _Webcam_thumbnailCanvas, document.createElement('canvas'), "f");
        __classPrivateFieldGet(this, _Webcam_thumbnailCanvas, "f").width = __classPrivateFieldGet(this, _Webcam_thumbnailWidth, "f");
        __classPrivateFieldGet(this, _Webcam_thumbnailCanvas, "f").height = (__classPrivateFieldGet(this, _Webcam_thumbnailWidth, "f") * __classPrivateFieldGet(this, _Webcam_height, "f")) / __classPrivateFieldGet(this, _Webcam_width, "f");
        __classPrivateFieldSet(this, _Webcam_thumbnailCtx, __classPrivateFieldGet(this, _Webcam_thumbnailCanvas, "f").getContext('2d'), "f");
        __classPrivateFieldSet(this, _Webcam_captureCanvas, document.createElement('canvas'), "f");
        __classPrivateFieldGet(this, _Webcam_captureCanvas, "f").width = __classPrivateFieldGet(this, _Webcam_width, "f");
        __classPrivateFieldGet(this, _Webcam_captureCanvas, "f").height = __classPrivateFieldGet(this, _Webcam_height, "f");
        __classPrivateFieldSet(this, _Webcam_captureCtx, __classPrivateFieldGet(this, _Webcam_captureCanvas, "f").getContext('2d'), "f");
    }
    async loadCameras() {
        try {
            const mediaStream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment' },
            });
            __classPrivateFieldSet(this, _Webcam_webcamWidth, mediaStream.getVideoTracks()[0].getSettings().width, "f");
            __classPrivateFieldSet(this, _Webcam_webcamHeight, mediaStream.getVideoTracks()[0].getSettings().height, "f");
            this.loadSrcStream(mediaStream);
        }
        catch (error) {
            throwError(new Error('Webcam not supported'));
        }
    }
    loadSrcStream(s) {
        this.$mediastream.set(s);
        __classPrivateFieldGet(this, _Webcam_videoElement, "f").srcObject = s;
        __classPrivateFieldGet(this, _Webcam_videoElement, "f").onloadedmetadata = () => {
            this.$ready.set(true);
        };
    }
    stopCamera() {
        if (this.$mediastream.get()) {
            const tracks = this.$mediastream.get().getTracks();
            for (const track of tracks) {
                track.stop();
                __classPrivateFieldGet(this, _Webcam_videoElement, "f").srcObject = null;
            }
            this.$ready.set(false);
        }
    }
    process() {
        if (!this.$ready.get())
            return;
        this.$thumbnails.set(this.captureThumbnail());
        this.$images.set(this.captureImage());
    }
    captureThumbnail() {
        if (!this.$ready.get())
            return null;
        const hRatio = __classPrivateFieldGet(this, _Webcam_height, "f") / __classPrivateFieldGet(this, _Webcam_webcamHeight, "f");
        const wRatio = __classPrivateFieldGet(this, _Webcam_width, "f") / __classPrivateFieldGet(this, _Webcam_webcamWidth, "f");
        if (hRatio > wRatio) {
            const w = (__classPrivateFieldGet(this, _Webcam_thumbnailCanvas, "f").height * __classPrivateFieldGet(this, _Webcam_webcamWidth, "f")) / __classPrivateFieldGet(this, _Webcam_webcamHeight, "f");
            __classPrivateFieldGet(this, _Webcam_thumbnailCtx, "f").drawImage(__classPrivateFieldGet(this, _Webcam_videoElement, "f"), __classPrivateFieldGet(this, _Webcam_thumbnailCanvas, "f").width / 2 - w / 2, 0, w, __classPrivateFieldGet(this, _Webcam_thumbnailCanvas, "f").height);
        }
        else {
            const h = (__classPrivateFieldGet(this, _Webcam_thumbnailCanvas, "f").width * __classPrivateFieldGet(this, _Webcam_webcamHeight, "f")) / __classPrivateFieldGet(this, _Webcam_webcamWidth, "f");
            __classPrivateFieldGet(this, _Webcam_thumbnailCtx, "f").drawImage(__classPrivateFieldGet(this, _Webcam_videoElement, "f"), 0, __classPrivateFieldGet(this, _Webcam_thumbnailCanvas, "f").height / 2 - h / 2, __classPrivateFieldGet(this, _Webcam_thumbnailCanvas, "f").width, h);
        }
        return __classPrivateFieldGet(this, _Webcam_thumbnailCanvas, "f").toDataURL('image/jpeg');
    }
    captureImage() {
        if (!this.$ready.get())
            return null;
        const hRatio = __classPrivateFieldGet(this, _Webcam_height, "f") / __classPrivateFieldGet(this, _Webcam_webcamHeight, "f");
        const wRatio = __classPrivateFieldGet(this, _Webcam_width, "f") / __classPrivateFieldGet(this, _Webcam_webcamWidth, "f");
        if (hRatio > wRatio) {
            const w = (__classPrivateFieldGet(this, _Webcam_height, "f") * __classPrivateFieldGet(this, _Webcam_webcamWidth, "f")) / __classPrivateFieldGet(this, _Webcam_webcamHeight, "f");
            __classPrivateFieldGet(this, _Webcam_captureCtx, "f").drawImage(__classPrivateFieldGet(this, _Webcam_videoElement, "f"), __classPrivateFieldGet(this, _Webcam_width, "f") / 2 - w / 2, 0, w, __classPrivateFieldGet(this, _Webcam_height, "f"));
        }
        else {
            const h = (__classPrivateFieldGet(this, _Webcam_width, "f") * __classPrivateFieldGet(this, _Webcam_webcamHeight, "f")) / __classPrivateFieldGet(this, _Webcam_webcamWidth, "f");
            __classPrivateFieldGet(this, _Webcam_captureCtx, "f").drawImage(__classPrivateFieldGet(this, _Webcam_videoElement, "f"), 0, __classPrivateFieldGet(this, _Webcam_height, "f") / 2 - h / 2, __classPrivateFieldGet(this, _Webcam_width, "f"), h);
        }
        return __classPrivateFieldGet(this, _Webcam_captureCtx, "f").getImageData(0, 0, __classPrivateFieldGet(this, _Webcam_width, "f"), __classPrivateFieldGet(this, _Webcam_height, "f"));
    }
}
_Webcam_width = new WeakMap(), _Webcam_height = new WeakMap(), _Webcam_webcamWidth = new WeakMap(), _Webcam_webcamHeight = new WeakMap(), _Webcam_videoElement = new WeakMap(), _Webcam_thumbnailWidth = new WeakMap(), _Webcam_unsubActive = new WeakMap(), _Webcam_stopStreaming = new WeakMap(), _Webcam_thumbnailCanvas = new WeakMap(), _Webcam_thumbnailCtx = new WeakMap(), _Webcam_captureCanvas = new WeakMap(), _Webcam_captureCtx = new WeakMap();

function webcam(...args) {
    return new Webcam(...args);
}

function isTitle$1(x) {
    return typeof x === 'string';
}
function isComponentArray$1(x) {
    return Array.isArray(x);
}
class DashboardPage$1 {
    constructor(name, showSidebar = true) {
        this.name = name;
        this.showSidebar = showSidebar;
        this.components = [];
        this.componentsLeft = [];
    }
    use(...components) {
        this.components = this.components.concat(components);
        return this;
    }
    sidebar(...components) {
        this.componentsLeft = this.componentsLeft.concat(components);
        return this;
    }
    mount() {
        for (const m of this.components) {
            if (isComponentArray$1(m)) {
                for (const n of m) {
                    n.mount();
                }
            }
            else if (!isTitle$1(m)) {
                m.mount();
            }
        }
        for (const m of this.componentsLeft) {
            m.mount();
        }
    }
    destroy() {
        for (const m of this.components) {
            if (isComponentArray$1(m)) {
                for (const n of m) {
                    n.destroy();
                }
            }
            else if (!isTitle$1(m)) {
                m.destroy();
            }
        }
        for (const m of this.componentsLeft) {
            m.destroy();
        }
    }
}

function pathToRegexp(path, keys, sensitive, strict) {
    if (path instanceof RegExp)
        return path;
    if (path instanceof Array)
        path = `(${path.join('|')})`;
    path = path
        .concat(strict ? '' : '/?')
        .replace(/\/\(/g, '(?:/')
        .replace(/\+/g, '__plus__')
        .replace(/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?/g, (_, slash, format, key, capture, optional) => {
        keys.push({ name: key, optional: !!optional });
        slash = slash || '';
        return `${optional ? '' : slash}(?:${optional ? slash : ''}${format || ''}${capture || (format && '([^/.]+?)') || '([^/]+?)'})${optional || ''}`;
    })
        .replace(/([/.])/g, '\\$1')
        .replace(/__plus__/g, '(.+)')
        .replace(/\*/g, '(.*)');
    return new RegExp(`^${path}$`, sensitive ? '' : 'i');
}
class Route {
    constructor(path, name) {
        this.path = path;
        this.name = name;
        this.keys = [];
        this.fns = [];
        this.params = {};
        this.regex = pathToRegexp(this.path, this.keys, false, false);
    }
    addHandler(fn) {
        this.fns.push(fn);
    }
    removeHandler(fn) {
        this.fns = this.fns.filter((f) => fn === f);
    }
    run(params) {
        for (const fn of this.fns) {
            fn.apply(this, params);
        }
    }
    match(path, params) {
        const m = this.regex.exec(path);
        if (!m)
            return false;
        for (let i = 1, len = m.length; i < len; i++) {
            const key = this.keys[i - 1];
            const val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];
            if (key) {
                this.params[key.name] = val;
            }
            params.push(val);
        }
        return true;
    }
}
function checkRoute(hash, route) {
    const params = [];
    if (route.match(hash, params)) {
        route.run(params);
        return true;
    }
    return false;
}
class Router {
    constructor() {
        this.map = {};
        this.routes = [];
        this.addListener();
    }
    route(path, fn) {
        const s = path.split(' ');
        const name = s.length === 2 ? s[0] : null;
        path = s.length === 2 ? s[1] : s[0];
        if (!Object.keys(this.map).includes(path)) {
            this.map[path] = new Route(path, name);
            this.routes.push(this.map[path]);
        }
        this.map[path].addHandler(fn);
        this.reload();
    }
    addListener() {
        window.addEventListener('hashchange', this.reload.bind(this), false);
    }
    removeListener() {
        window.removeEventListener('hashchange', this.reload.bind(this));
    }
    reload() {
        const hash = window.location.hash.substring(1);
        for (let i = 0; i < this.routes.length; i++) {
            const route = this.routes[i];
            if (checkRoute(hash, route)) {
                return;
            }
        }
    }
    navigate(path, { silent = false } = {}) {
        if (silent) {
            this.removeListener();
        }
        setTimeout(() => {
            window.location.hash = path;
            if (silent) {
                setTimeout(() => {
                    this.addListener();
                }, 1);
            }
        }, 1);
    }
}

/* src/layouts/dashboard/DashboardPage.svelte generated by Svelte v3.52.0 */

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	return child_ctx;
}

function get_each_context_1$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i].id;
	return child_ctx;
}

function get_each_context_2$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i].id;
	return child_ctx;
}

// (8:0) {#if dashboard}
function create_if_block$8(ctx) {
	let t;
	let div;
	let if_block = /*dashboard*/ ctx[0].showSidebar && create_if_block_3(ctx);
	let each_value = /*dashboard*/ ctx[0].components;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	}

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "right svelte-15dyumc");
			toggle_class(div, "fullw", !/*dashboard*/ ctx[0].showSidebar);
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, dirty) {
			if (/*dashboard*/ ctx[0].showSidebar) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_3(ctx);
					if_block.c();
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*dashboard, Array*/ 1) {
				each_value = /*dashboard*/ ctx[0].components;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$4(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$4(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*dashboard*/ 1) {
				toggle_class(div, "fullw", !/*dashboard*/ ctx[0].showSidebar);
			}
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t);
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (9:2) {#if dashboard.showSidebar}
function create_if_block_3(ctx) {
	let div;
	let each_value_2 = /*dashboard*/ ctx[0].componentsLeft;
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "left svelte-15dyumc");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, dirty) {
			if (dirty & /*dashboard*/ 1) {
				each_value_2 = /*dashboard*/ ctx[0].componentsLeft;
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (11:6) {#each dashboard.componentsLeft as { id }}
function create_each_block_2$1(ctx) {
	let div;
	let div_id_value;

	return {
		c() {
			div = element("div");
			attr(div, "id", div_id_value = /*id*/ ctx[4]);
			attr(div, "class", "card");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*dashboard*/ 1 && div_id_value !== (div_id_value = /*id*/ ctx[4])) {
				attr(div, "id", div_id_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (26:6) {:else}
function create_else_block$5(ctx) {
	let div;
	let div_id_value;

	return {
		c() {
			div = element("div");
			attr(div, "id", div_id_value = /*m*/ ctx[1].id);
			attr(div, "class", "card");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*dashboard*/ 1 && div_id_value !== (div_id_value = /*m*/ ctx[1].id)) {
				attr(div, "id", div_id_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (24:38) 
function create_if_block_2$3(ctx) {
	let h2;
	let t_value = /*m*/ ctx[1] + "";
	let t;

	return {
		c() {
			h2 = element("h2");
			t = text$1(t_value);
			attr(h2, "class", "svelte-15dyumc");
		},
		m(target, anchor) {
			insert(target, h2, anchor);
			append(h2, t);
		},
		p(ctx, dirty) {
			if (dirty & /*dashboard*/ 1 && t_value !== (t_value = /*m*/ ctx[1] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(h2);
		}
	};
}

// (18:6) {#if Array.isArray(m)}
function create_if_block_1$6(ctx) {
	let div;
	let t;
	let each_value_1 = /*m*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			attr(div, "class", "flex flex-row flex-wrap items-stretch");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*dashboard*/ 1) {
				each_value_1 = /*m*/ ctx[1];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, t);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (20:10) {#each m as { id }}
function create_each_block_1$2(ctx) {
	let div;
	let div_id_value;

	return {
		c() {
			div = element("div");
			attr(div, "id", div_id_value = /*id*/ ctx[4]);
			attr(div, "class", "card flex-none xl:flex-1 w-full xl:w-auto");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*dashboard*/ 1 && div_id_value !== (div_id_value = /*id*/ ctx[4])) {
				attr(div, "id", div_id_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (17:4) {#each dashboard.components as m}
function create_each_block$4(ctx) {
	let show_if;
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (dirty & /*dashboard*/ 1) show_if = null;
		if (show_if == null) show_if = !!Array.isArray(/*m*/ ctx[1]);
		if (show_if) return create_if_block_1$6;
		if (typeof /*m*/ ctx[1] === 'string') return create_if_block_2$3;
		return create_else_block$5;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$a(ctx) {
	let if_block_anchor;
	let if_block = /*dashboard*/ ctx[0] && create_if_block$8(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (/*dashboard*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$8(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$a($$self, $$props, $$invalidate) {
	let { dashboard } = $$props;

	afterUpdate(() => {
		dashboard.mount();
	});

	$$self.$$set = $$props => {
		if ('dashboard' in $$props) $$invalidate(0, dashboard = $$props.dashboard);
	};

	return [dashboard];
}

class DashboardPage extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$a, create_fragment$a, safe_not_equal, { dashboard: 0 });
	}
}

/* src/layouts/dashboard/DatasetSettings.svelte generated by Svelte v3.52.0 */

function create_else_block$4(ctx) {
	let t;

	return {
		c() {
			t = text$1("This dataset is empty");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (31:2) {#if $count}
function create_if_block_1$5(ctx) {
	let t0;
	let t1;
	let t2;
	let t3_value = (/*$count*/ ctx[3] ? 's' : '') + "";
	let t3;
	let t4;

	return {
		c() {
			t0 = text$1("This dataset contains ");
			t1 = text$1(/*$count*/ ctx[3]);
			t2 = text$1(" instance");
			t3 = text$1(t3_value);
			t4 = text$1(".");
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, t2, anchor);
			insert(target, t3, anchor);
			insert(target, t4, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$count*/ 8) set_data(t1, /*$count*/ ctx[3]);
			if (dirty & /*$count*/ 8 && t3_value !== (t3_value = (/*$count*/ ctx[3] ? 's' : '') + "")) set_data(t3, t3_value);
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (detaching) detach(t2);
			if (detaching) detach(t3);
			if (detaching) detach(t4);
		}
	};
}

// (38:2) {#if $count}
function create_if_block$7(ctx) {
	let button;
	let t;
	let span;
	let current;

	button = new Button$1({
			props: {
				$$slots: { default: [create_default_slot_2$2] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*downloadDataset*/ ctx[4]);

	return {
		c() {
			create_component(button.$$.fragment);
			t = space();
			span = element("span");
			attr(span, "class", "w-1");
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			insert(target, t, anchor);
			insert(target, span, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 256) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
			if (detaching) detach(t);
			if (detaching) detach(span);
		}
	};
}

// (39:4) <Button on:click={downloadDataset}>
function create_default_slot_2$2(ctx) {
	let t;

	return {
		c() {
			t = text$1("Download Dataset");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (42:2) <Button on:click={uploadDataset}>
function create_default_slot_1$5(ctx) {
	let t;

	return {
		c() {
			t = text$1("Upload Dataset");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (45:2) <Button type="danger" on:click={clearDataset}>
function create_default_slot$5(ctx) {
	let t;

	return {
		c() {
			t = text$1("Clear Dataset");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$9(ctx) {
	let span0;
	let t0_value = /*dataset*/ ctx[0].title + "";
	let t0;
	let t1;
	let p;
	let t2;
	let div;
	let t3;
	let button0;
	let t4;
	let span1;
	let t5;
	let input;
	let t6;
	let button1;
	let current;

	function select_block_type(ctx, dirty) {
		if (/*$count*/ ctx[3]) return create_if_block_1$5;
		return create_else_block$4;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type(ctx);
	let if_block1 = /*$count*/ ctx[3] && create_if_block$7(ctx);

	button0 = new Button$1({
			props: {
				$$slots: { default: [create_default_slot_1$5] },
				$$scope: { ctx }
			}
		});

	button0.$on("click", /*uploadDataset*/ ctx[5]);

	button1 = new Button$1({
			props: {
				type: "danger",
				$$slots: { default: [create_default_slot$5] },
				$$scope: { ctx }
			}
		});

	button1.$on("click", /*clearDataset*/ ctx[6]);

	return {
		c() {
			span0 = element("span");
			t0 = text$1(t0_value);
			t1 = space();
			p = element("p");
			if_block0.c();
			t2 = space();
			div = element("div");
			if (if_block1) if_block1.c();
			t3 = space();
			create_component(button0.$$.fragment);
			t4 = space();
			span1 = element("span");
			t5 = space();
			input = element("input");
			t6 = space();
			create_component(button1.$$.fragment);
			attr(span0, "class", "card-title");
			attr(p, "class", "pb-2");
			attr(span1, "class", "w-1");
			attr(input, "type", "file");
			input.multiple = true;
			attr(input, "class", "hidden");
			attr(div, "class", "flex");
		},
		m(target, anchor) {
			insert(target, span0, anchor);
			append(span0, t0);
			insert(target, t1, anchor);
			insert(target, p, anchor);
			if_block0.m(p, null);
			insert(target, t2, anchor);
			insert(target, div, anchor);
			if (if_block1) if_block1.m(div, null);
			append(div, t3);
			mount_component(button0, div, null);
			append(div, t4);
			append(div, span1);
			append(div, t5);
			append(div, input);
			/*input_binding*/ ctx[7](input);
			append(div, t6);
			mount_component(button1, div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if ((!current || dirty & /*dataset*/ 1) && t0_value !== (t0_value = /*dataset*/ ctx[0].title + "")) set_data(t0, t0_value);

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(p, null);
				}
			}

			if (/*$count*/ ctx[3]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*$count*/ 8) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$7(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			const button0_changes = {};

			if (dirty & /*$$scope*/ 256) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty & /*$$scope*/ 256) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block1);
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block1);
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span0);
			if (detaching) detach(t1);
			if (detaching) detach(p);
			if_block0.d();
			if (detaching) detach(t2);
			if (detaching) detach(div);
			if (if_block1) if_block1.d();
			destroy_component(button0);
			/*input_binding*/ ctx[7](null);
			destroy_component(button1);
		}
	};
}

function instance$9($$self, $$props, $$invalidate) {
	let count;

	let $count,
		$$unsubscribe_count = noop$1,
		$$subscribe_count = () => ($$unsubscribe_count(), $$unsubscribe_count = subscribe(count, $$value => $$invalidate(3, $count = $$value)), count);

	$$self.$$.on_destroy.push(() => $$unsubscribe_count());
	let { dataset } = $$props;
	let uploadInput;

	function downloadDataset() {
		dataset.download();
	}

	function uploadDataset() {
		uploadInput === null || uploadInput === void 0
		? void 0
		: uploadInput.click();
	}

	function clearDataset() {
		dataset.clear();
	}

	onMount(async () => {
		await tick();
		await tick();

		uploadInput.addEventListener('change', e => {
			const fl = e.target.files;
			const files = [];

			for (let i = 0; i < fl.length; i++) {
				files.push(fl[i]);
			}

			dataset.upload(files);
		});
	});

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			uploadInput = $$value;
			$$invalidate(1, uploadInput);
		});
	}

	$$self.$$set = $$props => {
		if ('dataset' in $$props) $$invalidate(0, dataset = $$props.dataset);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*dataset*/ 1) {
			$$subscribe_count($$invalidate(2, count = dataset.$count));
		}
	};

	return [
		dataset,
		uploadInput,
		count,
		$count,
		downloadDataset,
		uploadDataset,
		clearDataset,
		input_binding
	];
}

class DatasetSettings extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$9, create_fragment$9, safe_not_equal, { dataset: 0 });
	}
}

/* src/layouts/dashboard/DataStoreSettings.svelte generated by Svelte v3.52.0 */

function create_if_block_1$4(ctx) {
	let await_block_anchor;
	let promise;
	let current;

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: false,
		pending: create_pending_block,
		then: create_then_block,
		catch: create_catch_block,
		value: 4,
		blocks: [,,,]
	};

	handle_promise(promise = /*dataStore*/ ctx[0].connect(), info);

	return {
		c() {
			await_block_anchor = empty();
			info.block.c();
		},
		m(target, anchor) {
			insert(target, await_block_anchor, anchor);
			info.block.m(target, info.anchor = anchor);
			info.mount = () => await_block_anchor.parentNode;
			info.anchor = await_block_anchor;
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			info.ctx = ctx;

			if (dirty & /*dataStore*/ 1 && promise !== (promise = /*dataStore*/ ctx[0].connect()) && handle_promise(promise, info)) ; else {
				update_await_block_branch(info, ctx, dirty);
			}
		},
		i(local) {
			if (current) return;
			transition_in(info.block);
			current = true;
		},
		o(local) {
			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				transition_out(block);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(await_block_anchor);
			info.block.d(detaching);
			info.token = null;
			info = null;
		}
	};
}

// (1:0) <script lang="ts">import { ViewContainer }
function create_catch_block(ctx) {
	return {
		c: noop$1,
		m: noop$1,
		p: noop$1,
		i: noop$1,
		o: noop$1,
		d: noop$1
	};
}

// (14:4) {:then user}
function create_then_block(ctx) {
	let p;
	let t0;
	let t1_value = /*user*/ ctx[4].email + "";
	let t1;
	let t2;
	let div;
	let button;
	let current;

	button = new Button$1({
			props: {
				$$slots: { default: [create_default_slot_1$4] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*logout*/ ctx[3]);

	return {
		c() {
			p = element("p");
			t0 = text$1("Hello, ");
			t1 = text$1(t1_value);
			t2 = space();
			div = element("div");
			create_component(button.$$.fragment);
			attr(p, "class", "pb-2");
			attr(div, "class", "flex");
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t0);
			append(p, t1);
			insert(target, t2, anchor);
			insert(target, div, anchor);
			mount_component(button, div, null);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty & /*dataStore*/ 1) && t1_value !== (t1_value = /*user*/ ctx[4].email + "")) set_data(t1, t1_value);
			const button_changes = {};

			if (dirty & /*$$scope*/ 32) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(p);
			if (detaching) detach(t2);
			if (detaching) detach(div);
			destroy_component(button);
		}
	};
}

// (16:24) <Button on:click={logout}>
function create_default_slot_1$4(ctx) {
	let t;

	return {
		c() {
			t = text$1("Log out");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (12:32)        <Spinner />     {:then user}
function create_pending_block(ctx) {
	let spinner;
	let current;
	spinner = new Spinner({});

	return {
		c() {
			create_component(spinner.$$.fragment);
		},
		m(target, anchor) {
			mount_component(spinner, target, anchor);
			current = true;
		},
		p: noop$1,
		i(local) {
			if (current) return;
			transition_in(spinner.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(spinner.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(spinner, detaching);
		}
	};
}

// (21:2) {#if $services}
function create_if_block$6(ctx) {
	let div;
	let t0;
	let t1_value = /*$services*/ ctx[2].join(', ') + "";
	let t1;

	return {
		c() {
			div = element("div");
			t0 = text$1("This data store contains the following services: ");
			t1 = text$1(t1_value);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t0);
			append(div, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*$services*/ 4 && t1_value !== (t1_value = /*$services*/ ctx[2].join(', ') + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (10:0) <ViewContainer title="data store ({dataStore.location})">
function create_default_slot$4(ctx) {
	let t;
	let if_block1_anchor;
	let current;
	let if_block0 = /*dataStore*/ ctx[0].requiresAuth && create_if_block_1$4(ctx);
	let if_block1 = /*$services*/ ctx[2] && create_if_block$6(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*dataStore*/ ctx[0].requiresAuth) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*dataStore*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*$services*/ ctx[2]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$6(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

function create_fragment$8(ctx) {
	let viewcontainer;
	let current;

	viewcontainer = new ViewContainer({
			props: {
				title: "data store (" + /*dataStore*/ ctx[0].location + ")",
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(viewcontainer.$$.fragment);
		},
		m(target, anchor) {
			mount_component(viewcontainer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const viewcontainer_changes = {};
			if (dirty & /*dataStore*/ 1) viewcontainer_changes.title = "data store (" + /*dataStore*/ ctx[0].location + ")";

			if (dirty & /*$$scope, $services, dataStore*/ 37) {
				viewcontainer_changes.$$scope = { dirty, ctx };
			}

			viewcontainer.$set(viewcontainer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(viewcontainer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(viewcontainer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(viewcontainer, detaching);
		}
	};
}

function instance$8($$self, $$props, $$invalidate) {
	let services;

	let $services,
		$$unsubscribe_services = noop$1,
		$$subscribe_services = () => ($$unsubscribe_services(), $$unsubscribe_services = subscribe(services, $$value => $$invalidate(2, $services = $$value)), services);

	$$self.$$.on_destroy.push(() => $$unsubscribe_services());
	let { dataStore } = $$props;

	function logout() {
		dataStore.logout();
	}

	$$self.$$set = $$props => {
		if ('dataStore' in $$props) $$invalidate(0, dataStore = $$props.dataStore);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*dataStore*/ 1) {
			$$subscribe_services($$invalidate(1, services = dataStore.$services));
		}
	};

	return [dataStore, services, $services, logout];
}

class DataStoreSettings extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { dataStore: 0 });
	}
}

/* src/layouts/dashboard/ModelSettings.svelte generated by Svelte v3.52.0 */

function create_default_slot_1$3(ctx) {
	let t;

	return {
		c() {
			t = text$1("Download Model");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (47:2) <Button on:click={uploadModel}>
function create_default_slot$3(ctx) {
	let t;

	return {
		c() {
			t = text$1("Upload Model");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$7(ctx) {
	let span0;
	let t0_value = /*model*/ ctx[0].title + "";
	let t0;
	let t1;
	let div;
	let button0;
	let t2;
	let span1;
	let t3;
	let input;
	let t4;
	let button1;
	let current;

	button0 = new Button$1({
			props: {
				$$slots: { default: [create_default_slot_1$3] },
				$$scope: { ctx }
			}
		});

	button0.$on("click", /*downloadModel*/ ctx[2]);

	button1 = new Button$1({
			props: {
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			}
		});

	button1.$on("click", /*uploadModel*/ ctx[3]);

	return {
		c() {
			span0 = element("span");
			t0 = text$1(t0_value);
			t1 = space();
			div = element("div");
			create_component(button0.$$.fragment);
			t2 = space();
			span1 = element("span");
			t3 = space();
			input = element("input");
			t4 = space();
			create_component(button1.$$.fragment);
			attr(span0, "class", "card-title");
			attr(span1, "class", "w-1");
			attr(input, "type", "file");
			input.multiple = true;
			attr(input, "class", "hidden");
			attr(div, "class", "flex");
		},
		m(target, anchor) {
			insert(target, span0, anchor);
			append(span0, t0);
			insert(target, t1, anchor);
			insert(target, div, anchor);
			mount_component(button0, div, null);
			append(div, t2);
			append(div, span1);
			append(div, t3);
			append(div, input);
			/*input_binding*/ ctx[4](input);
			append(div, t4);
			mount_component(button1, div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if ((!current || dirty & /*model*/ 1) && t0_value !== (t0_value = /*model*/ ctx[0].title + "")) set_data(t0, t0_value);
			const button0_changes = {};

			if (dirty & /*$$scope*/ 32) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty & /*$$scope*/ 32) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span0);
			if (detaching) detach(t1);
			if (detaching) detach(div);
			destroy_component(button0);
			/*input_binding*/ ctx[4](null);
			destroy_component(button1);
		}
	};
}

function isSaveable(m) {
	return 'download' in m;
}

function instance$7($$self, $$props, $$invalidate) {
	let { model } = $$props;
	let uploadInput;

	function downloadModel() {
		if (isSaveable(model)) {
			model.download();
		} else {
			throwError(new Error('This model cannot be saved'));
		}
	}

	function uploadModel() {
		if (isSaveable(model)) {
			uploadInput === null || uploadInput === void 0
			? void 0
			: uploadInput.click();
		} else {
			throwError(new Error('This model cannot be uploaded'));
		}
	}

	onMount(async () => {
		await tick();
		await tick();

		uploadInput.addEventListener('change', e => {
			const fl = e.target.files;
			const files = [];

			for (let i = 0; i < fl.length; i++) {
				files.push(fl[i]);
			}

			if (isSaveable(model)) {
				model.upload(...files);
			}
		});
	});

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			uploadInput = $$value;
			$$invalidate(1, uploadInput);
		});
	}

	$$self.$$set = $$props => {
		if ('model' in $$props) $$invalidate(0, model = $$props.model);
	};

	return [model, uploadInput, downloadModel, uploadModel, input_binding];
}

class ModelSettings extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { model: 0 });
	}
}

/* src/layouts/dashboard/PredictionsSettings.svelte generated by Svelte v3.52.0 */

function create_else_block$3(ctx) {
	let t;

	return {
		c() {
			t = text$1("This batch prediction component is empty");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (31:2) {#if $count}
function create_if_block_1$3(ctx) {
	let t0;
	let t1;
	let t2;
	let t3_value = (/*$count*/ ctx[3] ? 's' : '') + "";
	let t3;

	return {
		c() {
			t0 = text$1("This batch prediction component contains\n    ");
			t1 = text$1(/*$count*/ ctx[3]);
			t2 = text$1("\n    prediction");
			t3 = text$1(t3_value);
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, t2, anchor);
			insert(target, t3, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$count*/ 8) set_data(t1, /*$count*/ ctx[3]);
			if (dirty & /*$count*/ 8 && t3_value !== (t3_value = (/*$count*/ ctx[3] ? 's' : '') + "")) set_data(t3, t3_value);
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (detaching) detach(t2);
			if (detaching) detach(t3);
		}
	};
}

// (38:2) {#if $count}
function create_if_block$5(ctx) {
	let button;
	let t;
	let span;
	let current;

	button = new Button$1({
			props: {
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*downloadPredictions*/ ctx[4]);

	return {
		c() {
			create_component(button.$$.fragment);
			t = space();
			span = element("span");
			attr(span, "class", "w-1");
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			insert(target, t, anchor);
			insert(target, span, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 256) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
			if (detaching) detach(t);
			if (detaching) detach(span);
		}
	};
}

// (39:4) <Button on:click={downloadPredictions}>
function create_default_slot_2$1(ctx) {
	let t;

	return {
		c() {
			t = text$1("Download Predictions");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (42:2) <Button on:click={uploadPredictions}>
function create_default_slot_1$2(ctx) {
	let t;

	return {
		c() {
			t = text$1("Upload Predictions");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (45:2) <Button type="danger" on:click={clearPredictions}>
function create_default_slot$2(ctx) {
	let t;

	return {
		c() {
			t = text$1("Clear Predictions");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$6(ctx) {
	let span0;
	let t0_value = /*prediction*/ ctx[0].title + "";
	let t0;
	let t1;
	let p;
	let t2;
	let div;
	let t3;
	let button0;
	let t4;
	let span1;
	let t5;
	let input;
	let t6;
	let button1;
	let current;

	function select_block_type(ctx, dirty) {
		if (/*$count*/ ctx[3]) return create_if_block_1$3;
		return create_else_block$3;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type(ctx);
	let if_block1 = /*$count*/ ctx[3] && create_if_block$5(ctx);

	button0 = new Button$1({
			props: {
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			}
		});

	button0.$on("click", /*uploadPredictions*/ ctx[5]);

	button1 = new Button$1({
			props: {
				type: "danger",
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			}
		});

	button1.$on("click", /*clearPredictions*/ ctx[6]);

	return {
		c() {
			span0 = element("span");
			t0 = text$1(t0_value);
			t1 = space();
			p = element("p");
			if_block0.c();
			t2 = space();
			div = element("div");
			if (if_block1) if_block1.c();
			t3 = space();
			create_component(button0.$$.fragment);
			t4 = space();
			span1 = element("span");
			t5 = space();
			input = element("input");
			t6 = space();
			create_component(button1.$$.fragment);
			attr(span0, "class", "card-title");
			attr(p, "class", "pb-2");
			attr(span1, "class", "w-1");
			attr(input, "type", "file");
			input.multiple = true;
			attr(input, "class", "hidden");
			attr(div, "class", "flex");
		},
		m(target, anchor) {
			insert(target, span0, anchor);
			append(span0, t0);
			insert(target, t1, anchor);
			insert(target, p, anchor);
			if_block0.m(p, null);
			insert(target, t2, anchor);
			insert(target, div, anchor);
			if (if_block1) if_block1.m(div, null);
			append(div, t3);
			mount_component(button0, div, null);
			append(div, t4);
			append(div, span1);
			append(div, t5);
			append(div, input);
			/*input_binding*/ ctx[7](input);
			append(div, t6);
			mount_component(button1, div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if ((!current || dirty & /*prediction*/ 1) && t0_value !== (t0_value = /*prediction*/ ctx[0].title + "")) set_data(t0, t0_value);

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(p, null);
				}
			}

			if (/*$count*/ ctx[3]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*$count*/ 8) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$5(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			const button0_changes = {};

			if (dirty & /*$$scope*/ 256) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty & /*$$scope*/ 256) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block1);
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block1);
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span0);
			if (detaching) detach(t1);
			if (detaching) detach(p);
			if_block0.d();
			if (detaching) detach(t2);
			if (detaching) detach(div);
			if (if_block1) if_block1.d();
			destroy_component(button0);
			/*input_binding*/ ctx[7](null);
			destroy_component(button1);
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	let count;

	let $count,
		$$unsubscribe_count = noop$1,
		$$subscribe_count = () => ($$unsubscribe_count(), $$unsubscribe_count = subscribe(count, $$value => $$invalidate(3, $count = $$value)), count);

	$$self.$$.on_destroy.push(() => $$unsubscribe_count());
	let { prediction } = $$props;
	let uploadInput;

	function downloadPredictions() {
		prediction.download();
	}

	function uploadPredictions() {
		uploadInput === null || uploadInput === void 0
		? void 0
		: uploadInput.click();
	}

	function clearPredictions() {
		prediction.clear();
	}

	onMount(async () => {
		await tick();
		await tick();

		uploadInput.addEventListener('change', e => {
			const fl = e.target.files;
			const files = [];

			for (let i = 0; i < fl.length; i++) {
				files.push(fl[i]);
			}

			prediction.upload(files);
		});
	});

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			uploadInput = $$value;
			$$invalidate(1, uploadInput);
		});
	}

	$$self.$$set = $$props => {
		if ('prediction' in $$props) $$invalidate(0, prediction = $$props.prediction);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*prediction*/ 1) {
			$$subscribe_count($$invalidate(2, count = prediction.$count));
		}
	};

	return [
		prediction,
		uploadInput,
		count,
		$count,
		downloadPredictions,
		uploadPredictions,
		clearPredictions,
		input_binding
	];
}

class PredictionsSettings extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { prediction: 0 });
	}
}

/* src/layouts/dashboard/DashboardSettings.svelte generated by Svelte v3.52.0 */

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	return child_ctx;
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i].id;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i];
	return child_ctx;
}

function get_each_context_4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[13] = list[i];
	return child_ctx;
}

function get_each_context_5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	return child_ctx;
}

// (12:0) {#if settings}
function create_if_block$4(ctx) {
	let div0;
	let h20;
	let t1;
	let t2;
	let h21;
	let t4;
	let t5;
	let h22;
	let t7;
	let t8;
	let h23;
	let t10;
	let t11;
	let div1;
	let current;
	let each_value_5 = /*settings*/ ctx[0].xDataStores;
	let each_blocks_4 = [];

	for (let i = 0; i < each_value_5.length; i += 1) {
		each_blocks_4[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
	}

	const out = i => transition_out(each_blocks_4[i], 1, 1, () => {
		each_blocks_4[i] = null;
	});

	let each_value_4 = /*settings*/ ctx[0].xModels;
	let each_blocks_3 = [];

	for (let i = 0; i < each_value_4.length; i += 1) {
		each_blocks_3[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
	}

	const out_1 = i => transition_out(each_blocks_3[i], 1, 1, () => {
		each_blocks_3[i] = null;
	});

	let each_value_3 = /*settings*/ ctx[0].xDatasets;
	let each_blocks_2 = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks_2[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	}

	const out_2 = i => transition_out(each_blocks_2[i], 1, 1, () => {
		each_blocks_2[i] = null;
	});

	let each_value_2 = /*settings*/ ctx[0].xPredictions;
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	const out_3 = i => transition_out(each_blocks_1[i], 1, 1, () => {
		each_blocks_1[i] = null;
	});

	let each_value = /*settings*/ ctx[0].components;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	return {
		c() {
			div0 = element("div");
			h20 = element("h2");
			h20.textContent = "Data Stores";
			t1 = space();

			for (let i = 0; i < each_blocks_4.length; i += 1) {
				each_blocks_4[i].c();
			}

			t2 = space();
			h21 = element("h2");
			h21.textContent = "Models";
			t4 = space();

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].c();
			}

			t5 = space();
			h22 = element("h2");
			h22.textContent = "Datasets";
			t7 = space();

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].c();
			}

			t8 = space();
			h23 = element("h2");
			h23.textContent = "Predictions";
			t10 = space();

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t11 = space();
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div0, "class", "left svelte-inuorr");
			attr(div1, "class", "right svelte-inuorr");
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			append(div0, h20);
			append(div0, t1);

			for (let i = 0; i < each_blocks_4.length; i += 1) {
				each_blocks_4[i].m(div0, null);
			}

			append(div0, t2);
			append(div0, h21);
			append(div0, t4);

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].m(div0, null);
			}

			append(div0, t5);
			append(div0, h22);
			append(div0, t7);

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].m(div0, null);
			}

			append(div0, t8);
			append(div0, h23);
			append(div0, t10);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div0, null);
			}

			insert(target, t11, anchor);
			insert(target, div1, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*settings*/ 1) {
				each_value_5 = /*settings*/ ctx[0].xDataStores;
				let i;

				for (i = 0; i < each_value_5.length; i += 1) {
					const child_ctx = get_each_context_5(ctx, each_value_5, i);

					if (each_blocks_4[i]) {
						each_blocks_4[i].p(child_ctx, dirty);
						transition_in(each_blocks_4[i], 1);
					} else {
						each_blocks_4[i] = create_each_block_5(child_ctx);
						each_blocks_4[i].c();
						transition_in(each_blocks_4[i], 1);
						each_blocks_4[i].m(div0, t2);
					}
				}

				group_outros();

				for (i = each_value_5.length; i < each_blocks_4.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (dirty & /*settings*/ 1) {
				each_value_4 = /*settings*/ ctx[0].xModels;
				let i;

				for (i = 0; i < each_value_4.length; i += 1) {
					const child_ctx = get_each_context_4(ctx, each_value_4, i);

					if (each_blocks_3[i]) {
						each_blocks_3[i].p(child_ctx, dirty);
						transition_in(each_blocks_3[i], 1);
					} else {
						each_blocks_3[i] = create_each_block_4(child_ctx);
						each_blocks_3[i].c();
						transition_in(each_blocks_3[i], 1);
						each_blocks_3[i].m(div0, t5);
					}
				}

				group_outros();

				for (i = each_value_4.length; i < each_blocks_3.length; i += 1) {
					out_1(i);
				}

				check_outros();
			}

			if (dirty & /*settings*/ 1) {
				each_value_3 = /*settings*/ ctx[0].xDatasets;
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3(ctx, each_value_3, i);

					if (each_blocks_2[i]) {
						each_blocks_2[i].p(child_ctx, dirty);
						transition_in(each_blocks_2[i], 1);
					} else {
						each_blocks_2[i] = create_each_block_3(child_ctx);
						each_blocks_2[i].c();
						transition_in(each_blocks_2[i], 1);
						each_blocks_2[i].m(div0, t8);
					}
				}

				group_outros();

				for (i = each_value_3.length; i < each_blocks_2.length; i += 1) {
					out_2(i);
				}

				check_outros();
			}

			if (dirty & /*settings*/ 1) {
				each_value_2 = /*settings*/ ctx[0].xPredictions;
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
						transition_in(each_blocks_1[i], 1);
					} else {
						each_blocks_1[i] = create_each_block_2(child_ctx);
						each_blocks_1[i].c();
						transition_in(each_blocks_1[i], 1);
						each_blocks_1[i].m(div0, null);
					}
				}

				group_outros();

				for (i = each_value_2.length; i < each_blocks_1.length; i += 1) {
					out_3(i);
				}

				check_outros();
			}

			if (dirty & /*settings, Array*/ 1) {
				each_value = /*settings*/ ctx[0].components;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_5.length; i += 1) {
				transition_in(each_blocks_4[i]);
			}

			for (let i = 0; i < each_value_4.length; i += 1) {
				transition_in(each_blocks_3[i]);
			}

			for (let i = 0; i < each_value_3.length; i += 1) {
				transition_in(each_blocks_2[i]);
			}

			for (let i = 0; i < each_value_2.length; i += 1) {
				transition_in(each_blocks_1[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks_4 = each_blocks_4.filter(Boolean);

			for (let i = 0; i < each_blocks_4.length; i += 1) {
				transition_out(each_blocks_4[i]);
			}

			each_blocks_3 = each_blocks_3.filter(Boolean);

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				transition_out(each_blocks_3[i]);
			}

			each_blocks_2 = each_blocks_2.filter(Boolean);

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				transition_out(each_blocks_2[i]);
			}

			each_blocks_1 = each_blocks_1.filter(Boolean);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				transition_out(each_blocks_1[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div0);
			destroy_each(each_blocks_4, detaching);
			destroy_each(each_blocks_3, detaching);
			destroy_each(each_blocks_2, detaching);
			destroy_each(each_blocks_1, detaching);
			if (detaching) detach(t11);
			if (detaching) detach(div1);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (15:4) {#each settings.xDataStores as dataStore}
function create_each_block_5(ctx) {
	let div;
	let datastoresettings;
	let current;

	datastoresettings = new DataStoreSettings({
			props: { dataStore: /*dataStore*/ ctx[16] }
		});

	return {
		c() {
			div = element("div");
			create_component(datastoresettings.$$.fragment);
			attr(div, "class", "card");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(datastoresettings, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const datastoresettings_changes = {};
			if (dirty & /*settings*/ 1) datastoresettings_changes.dataStore = /*dataStore*/ ctx[16];
			datastoresettings.$set(datastoresettings_changes);
		},
		i(local) {
			if (current) return;
			transition_in(datastoresettings.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(datastoresettings.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(datastoresettings);
		}
	};
}

// (21:4) {#each settings.xModels as model}
function create_each_block_4(ctx) {
	let div;
	let modelsettings;
	let current;
	modelsettings = new ModelSettings({ props: { model: /*model*/ ctx[13] } });

	return {
		c() {
			div = element("div");
			create_component(modelsettings.$$.fragment);
			attr(div, "class", "card");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(modelsettings, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const modelsettings_changes = {};
			if (dirty & /*settings*/ 1) modelsettings_changes.model = /*model*/ ctx[13];
			modelsettings.$set(modelsettings_changes);
		},
		i(local) {
			if (current) return;
			transition_in(modelsettings.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(modelsettings.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(modelsettings);
		}
	};
}

// (27:4) {#each settings.xDatasets as dataset}
function create_each_block_3(ctx) {
	let div;
	let datasetsettings;
	let current;
	datasetsettings = new DatasetSettings({ props: { dataset: /*dataset*/ ctx[10] } });

	return {
		c() {
			div = element("div");
			create_component(datasetsettings.$$.fragment);
			attr(div, "class", "card");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(datasetsettings, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const datasetsettings_changes = {};
			if (dirty & /*settings*/ 1) datasetsettings_changes.dataset = /*dataset*/ ctx[10];
			datasetsettings.$set(datasetsettings_changes);
		},
		i(local) {
			if (current) return;
			transition_in(datasetsettings.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(datasetsettings.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(datasetsettings);
		}
	};
}

// (33:4) {#each settings.xPredictions as prediction}
function create_each_block_2(ctx) {
	let div;
	let predictionssettings;
	let t;
	let current;

	predictionssettings = new PredictionsSettings({
			props: { prediction: /*prediction*/ ctx[7] }
		});

	return {
		c() {
			div = element("div");
			create_component(predictionssettings.$$.fragment);
			t = space();
			attr(div, "class", "card");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(predictionssettings, div, null);
			append(div, t);
			current = true;
		},
		p(ctx, dirty) {
			const predictionssettings_changes = {};
			if (dirty & /*settings*/ 1) predictionssettings_changes.prediction = /*prediction*/ ctx[7];
			predictionssettings.$set(predictionssettings_changes);
		},
		i(local) {
			if (current) return;
			transition_in(predictionssettings.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(predictionssettings.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(predictionssettings);
		}
	};
}

// (49:6) {:else}
function create_else_block$2(ctx) {
	let div;
	let div_id_value;

	return {
		c() {
			div = element("div");
			attr(div, "id", div_id_value = /*m*/ ctx[1].id);
			attr(div, "class", "card");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*settings*/ 1 && div_id_value !== (div_id_value = /*m*/ ctx[1].id)) {
				attr(div, "id", div_id_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (47:38) 
function create_if_block_2$2(ctx) {
	let h2;
	let t_value = /*m*/ ctx[1] + "";
	let t;

	return {
		c() {
			h2 = element("h2");
			t = text$1(t_value);
		},
		m(target, anchor) {
			insert(target, h2, anchor);
			append(h2, t);
		},
		p(ctx, dirty) {
			if (dirty & /*settings*/ 1 && t_value !== (t_value = /*m*/ ctx[1] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(h2);
		}
	};
}

// (41:6) {#if Array.isArray(m)}
function create_if_block_1$2(ctx) {
	let div;
	let t;
	let each_value_1 = /*m*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			attr(div, "class", "flex flex-row flex-wrap items-stretch");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*settings*/ 1) {
				each_value_1 = /*m*/ ctx[1];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, t);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (43:10) {#each m as { id }}
function create_each_block_1$1(ctx) {
	let div;
	let div_id_value;

	return {
		c() {
			div = element("div");
			attr(div, "id", div_id_value = /*id*/ ctx[4]);
			attr(div, "class", "card flex-none xl:flex-1 w-full xl:w-auto");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*settings*/ 1 && div_id_value !== (div_id_value = /*id*/ ctx[4])) {
				attr(div, "id", div_id_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (40:4) {#each settings.components as m}
function create_each_block$3(ctx) {
	let show_if;
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (dirty & /*settings*/ 1) show_if = null;
		if (show_if == null) show_if = !!Array.isArray(/*m*/ ctx[1]);
		if (show_if) return create_if_block_1$2;
		if (typeof /*m*/ ctx[1] === 'string') return create_if_block_2$2;
		return create_else_block$2;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$5(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*settings*/ ctx[0] && create_if_block$4(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*settings*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*settings*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$4(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let { settings } = $$props;

	afterUpdate(() => {
		settings.mount();
	});

	$$self.$$set = $$props => {
		if ('settings' in $$props) $$invalidate(0, settings = $$props.settings);
	};

	return [settings];
}

class DashboardSettings$1 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { settings: 0 });
	}
}

/* src/layouts/dashboard/DashboardHeader.svelte generated by Svelte v3.52.0 */

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[8] = list[i][0];
	child_ctx[9] = list[i][1];
	child_ctx[11] = i;
	return child_ctx;
}

// (36:6) {#each Object.entries(items) as [slug, name], index}
function create_each_block$2(ctx) {
	let a;
	let t0_value = /*name*/ ctx[9] + "";
	let t0;
	let t1;
	let a_href_value;

	return {
		c() {
			a = element("a");
			t0 = text$1(t0_value);
			t1 = space();
			attr(a, "href", a_href_value = `#${/*slug*/ ctx[8]}`);
			attr(a, "class", "ml-2 mr-5 flex items-center hover:text-black border-solid border-0 border-b-2 border-transparent svelte-1ut593v");
			toggle_class(a, "active", !/*showSettings*/ ctx[4] && /*current*/ ctx[2] === /*name*/ ctx[9]);
		},
		m(target, anchor) {
			insert(target, a, anchor);
			append(a, t0);
			append(a, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*items*/ 2 && t0_value !== (t0_value = /*name*/ ctx[9] + "")) set_data(t0, t0_value);

			if (dirty & /*items*/ 2 && a_href_value !== (a_href_value = `#${/*slug*/ ctx[8]}`)) {
				attr(a, "href", a_href_value);
			}

			if (dirty & /*showSettings, current, Object, items*/ 22) {
				toggle_class(a, "active", !/*showSettings*/ ctx[4] && /*current*/ ctx[2] === /*name*/ ctx[9]);
			}
		},
		d(detaching) {
			if (detaching) detach(a);
		}
	};
}

// (47:6) <Button round on:click={toggleSettings}>
function create_default_slot_1$1(ctx) {
	let svg;
	let circle;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			path = svg_element("path");
			attr(circle, "cx", "12");
			attr(circle, "cy", "12");
			attr(circle, "r", "3");
			attr(path, "d", "M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "24");
			attr(svg, "height", "24");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "fill", "none");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", "2");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", "feather feather-settings");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle);
			append(svg, path);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (65:6) {#if closable}
function create_if_block$3(ctx) {
	let button;
	let t;
	let span;
	let current;

	button = new Button$1({
			props: {
				round: true,
				type: "danger",
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*quit*/ ctx[5]);

	return {
		c() {
			create_component(button.$$.fragment);
			t = space();
			span = element("span");
			attr(span, "class", "w-1");
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			insert(target, t, anchor);
			insert(target, span, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 4096) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
			if (detaching) detach(t);
			if (detaching) detach(span);
		}
	};
}

// (66:8) <Button round type="danger" on:click={quit}>
function create_default_slot$1(ctx) {
	let svg;
	let path;
	let line;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			line = svg_element("line");
			attr(path, "d", "M18.36 6.64a9 9 0 1 1-12.73 0");
			attr(line, "x1", "12");
			attr(line, "y1", "2");
			attr(line, "x2", "12");
			attr(line, "y2", "12");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", "24");
			attr(svg, "height", "24");
			attr(svg, "viewBox", "0 0 24 24");
			attr(svg, "fill", "none");
			attr(svg, "stroke", "currentColor");
			attr(svg, "stroke-width", "2");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(svg, "class", "feather feather-power");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, path);
			append(svg, line);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function create_fragment$4(ctx) {
	let header;
	let div1;
	let a;
	let span0;
	let t0;
	let t1;
	let nav;
	let t2;
	let div0;
	let button;
	let t3;
	let span1;
	let t4;
	let current;
	let each_value = Object.entries(/*items*/ ctx[1]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	button = new Button$1({
			props: {
				round: true,
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			}
		});

	button.$on("click", /*toggleSettings*/ ctx[6]);
	let if_block = /*closable*/ ctx[3] && create_if_block$3(ctx);

	return {
		c() {
			header = element("header");
			div1 = element("div");
			a = element("a");
			span0 = element("span");
			t0 = text$1(/*title*/ ctx[0]);
			t1 = space();
			nav = element("nav");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			div0 = element("div");
			create_component(button.$$.fragment);
			t3 = space();
			span1 = element("span");
			t4 = space();
			if (if_block) if_block.c();
			attr(span0, "class", "mx-3 text-lg");
			attr(a, "href", "#/");
			attr(a, "class", "flex p-3 title-font font-medium items-center text-gray-900 mb-4 md:mb-0 border-solid border-0 border-r border-gray-200 svelte-1ut593v");
			attr(nav, "class", "flex items-stretch justify-start flex-wrap text-base grow mx-4");
			attr(span1, "class", "w-1");
			attr(div0, "class", "flex items-center");
			attr(div1, "class", "mx-auto flex flex-wrap flex-col md:flex-row items-stretch w-full");
			attr(header, "class", "bg-white text-gray-700 body-font");
		},
		m(target, anchor) {
			insert(target, header, anchor);
			append(header, div1);
			append(div1, a);
			append(a, span0);
			append(span0, t0);
			append(div1, t1);
			append(div1, nav);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(nav, null);
			}

			append(div1, t2);
			append(div1, div0);
			mount_component(button, div0, null);
			append(div0, t3);
			append(div0, span1);
			append(div0, t4);
			if (if_block) if_block.m(div0, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*title*/ 1) set_data(t0, /*title*/ ctx[0]);

			if (dirty & /*Object, items, showSettings, current*/ 22) {
				each_value = Object.entries(/*items*/ ctx[1]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(nav, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			const button_changes = {};

			if (dirty & /*$$scope*/ 4096) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);

			if (/*closable*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*closable*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div0, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(header);
			destroy_each(each_blocks, detaching);
			destroy_component(button);
			if (if_block) if_block.d();
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let { title } = $$props;
	let { items } = $$props;
	let { current } = $$props;
	let { closable } = $$props;
	let { showSettings = false } = $$props;
	const dispatch = createEventDispatcher();

	function toggleSettings() {
		if (showSettings) {
			window.location.href = window.location.href.split('#')[0] + '#' + Object.keys(items)[Object.values(items).indexOf(current)];
		} else {
			window.location.href = window.location.href.split('#')[0] + '#settings';
		}
	}

	function quit() {
		setTimeout(
			() => {
				dispatch('quit');
			},
			400
		);
	}

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('items' in $$props) $$invalidate(1, items = $$props.items);
		if ('current' in $$props) $$invalidate(2, current = $$props.current);
		if ('closable' in $$props) $$invalidate(3, closable = $$props.closable);
		if ('showSettings' in $$props) $$invalidate(4, showSettings = $$props.showSettings);
	};

	return [title, items, current, closable, showSettings, quit, toggleSettings];
}

class DashboardHeader extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
			title: 0,
			items: 1,
			current: 2,
			closable: 3,
			showSettings: 4,
			quit: 5
		});
	}

	get quit() {
		return this.$$.ctx[5];
	}
}

/* src/layouts/dashboard/DashboardFooter.svelte generated by Svelte v3.52.0 */

function create_else_block_1(ctx) {
	let t;

	return {
		c() {
			t = text$1(" ");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (14:4) {#if $logStream}
function create_if_block$2(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*$logStream*/ ctx[1][0] === LogLevel.Warning) return create_if_block_1$1;
		if (/*$logStream*/ ctx[1][0] === LogLevel.Error) return create_if_block_2$1;
		return create_else_block$1;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (21:6) {:else}
function create_else_block$1(ctx) {
	let t_value = (/*$logStream*/ ctx[1][1] || '') + "";
	let t;

	return {
		c() {
			t = text$1(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$logStream*/ 2 && t_value !== (t_value = (/*$logStream*/ ctx[1][1] || '') + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (18:49) 
function create_if_block_2$1(ctx) {
	let t0;
	let t1_value = (/*$logStream*/ ctx[1][1] || '') + "";
	let t1;

	return {
		c() {
			t0 = text$1("Err:\n        ");
			t1 = text$1(t1_value);
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$logStream*/ 2 && t1_value !== (t1_value = (/*$logStream*/ ctx[1][1] || '') + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
		}
	};
}

// (15:6) {#if $logStream[0] === LogLevel.Warning}
function create_if_block_1$1(ctx) {
	let t0;
	let t1_value = (/*$logStream*/ ctx[1][1] || '') + "";
	let t1;

	return {
		c() {
			t0 = text$1("Warn:\n        ");
			t1 = text$1(t1_value);
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$logStream*/ 2 && t1_value !== (t1_value = (/*$logStream*/ ctx[1][1] || '') + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
		}
	};
}

function create_fragment$3(ctx) {
	let footer;
	let p0;
	let t0;
	let p1;
	let t1;
	let t2;

	function select_block_type(ctx, dirty) {
		if (/*$logStream*/ ctx[1]) return create_if_block$2;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			footer = element("footer");
			p0 = element("p");
			if_block.c();
			t0 = space();
			p1 = element("p");
			t1 = text$1("© 2021 ");
			t2 = text$1(/*author*/ ctx[0]);
			attr(p0, "class", "console svelte-i04gf3");
			toggle_class(p0, "error", /*$logStream*/ ctx[1] && /*$logStream*/ ctx[1][0] === LogLevel.Error);
			toggle_class(p0, "warning", /*$logStream*/ ctx[1] && /*$logStream*/ ctx[1][0] === LogLevel.Warning);
			attr(p1, "class", "text-sm text-gray-500 sm:ml-4 sm:pl-4 sm:border-gray-200");
			attr(footer, "class", "bg-white text-gray-600 border-t px-5 py-1 flex items-center justify-between flex-col sm:flex-row");
		},
		m(target, anchor) {
			insert(target, footer, anchor);
			append(footer, p0);
			if_block.m(p0, null);
			append(footer, t0);
			append(footer, p1);
			append(p1, t1);
			append(p1, t2);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(p0, null);
				}
			}

			if (dirty & /*$logStream, LogLevel*/ 2) {
				toggle_class(p0, "error", /*$logStream*/ ctx[1] && /*$logStream*/ ctx[1][0] === LogLevel.Error);
			}

			if (dirty & /*$logStream, LogLevel*/ 2) {
				toggle_class(p0, "warning", /*$logStream*/ ctx[1] && /*$logStream*/ ctx[1][0] === LogLevel.Warning);
			}

			if (dirty & /*author*/ 1) set_data(t2, /*author*/ ctx[0]);
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) detach(footer);
			if_block.d();
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let $logStream;
	let { author } = $$props;
	const logStream = getLogStream();
	component_subscribe($$self, logStream, value => $$invalidate(1, $logStream = value));

	$$self.$$set = $$props => {
		if ('author' in $$props) $$invalidate(0, author = $$props.author);
	};

	return [author, $logStream, logStream];
}

class DashboardFooter extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { author: 0 });
	}
}

/* src/layouts/dashboard/Dashboard.svelte generated by Svelte v3.52.0 */

function create_if_block$1(ctx) {
	let div1;
	let div0;
	let dashboardheader;
	let t0;
	let main;
	let current_block_type_index;
	let if_block;
	let t1;
	let dashboardfooter;
	let div0_transition;
	let current;

	dashboardheader = new DashboardHeader({
			props: {
				title: /*title*/ ctx[0],
				items: /*dashboardSlugs*/ ctx[10].reduce(/*func*/ ctx[12], {}),
				current: /*currentDashboard*/ ctx[9],
				showSettings: /*showSettings*/ ctx[8],
				closable: /*closable*/ ctx[4]
			}
		});

	dashboardheader.$on("quit", /*quit*/ ctx[5]);
	const if_block_creators = [create_if_block_1, create_if_block_2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*showSettings*/ ctx[8]) return 0;
		if (/*currentDashboard*/ ctx[9]) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	dashboardfooter = new DashboardFooter({ props: { author: /*author*/ ctx[1] } });

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			create_component(dashboardheader.$$.fragment);
			t0 = space();
			main = element("main");
			if (if_block) if_block.c();
			t1 = space();
			create_component(dashboardfooter.$$.fragment);
			attr(main, "class", "main-container svelte-1da5cws");
			attr(div0, "class", "app-container svelte-1da5cws");
			attr(div1, "class", "marcelle fixed h-screen w-full max-w-full overflow-y-scroll overflow-x-hidden top-0 left-0 z-50");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			mount_component(dashboardheader, div0, null);
			append(div0, t0);
			append(div0, main);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(main, null);
			}

			append(div0, t1);
			mount_component(dashboardfooter, div0, null);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const dashboardheader_changes = {};
			if (dirty & /*title*/ 1) dashboardheader_changes.title = /*title*/ ctx[0];
			if (dirty & /*dashboardSlugs, dashboardNames*/ 1088) dashboardheader_changes.items = /*dashboardSlugs*/ ctx[10].reduce(/*func*/ ctx[12], {});
			if (dirty & /*currentDashboard*/ 512) dashboardheader_changes.current = /*currentDashboard*/ ctx[9];
			if (dirty & /*showSettings*/ 256) dashboardheader_changes.showSettings = /*showSettings*/ ctx[8];
			if (dirty & /*closable*/ 16) dashboardheader_changes.closable = /*closable*/ ctx[4];
			dashboardheader.$set(dashboardheader_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(main, null);
				} else {
					if_block = null;
				}
			}

			const dashboardfooter_changes = {};
			if (dirty & /*author*/ 2) dashboardfooter_changes.author = /*author*/ ctx[1];
			dashboardfooter.$set(dashboardfooter_changes);
		},
		i(local) {
			if (current) return;
			transition_in(dashboardheader.$$.fragment, local);
			transition_in(if_block);
			transition_in(dashboardfooter.$$.fragment, local);

			add_render_callback(() => {
				if (!div0_transition) div0_transition = create_bidirectional_transition(
					div0,
					blur,
					{
						amount: 10,
						duration: /*closable*/ ctx[4] ? 400 : 0
					},
					true
				);

				div0_transition.run(1);
			});

			current = true;
		},
		o(local) {
			transition_out(dashboardheader.$$.fragment, local);
			transition_out(if_block);
			transition_out(dashboardfooter.$$.fragment, local);

			if (!div0_transition) div0_transition = create_bidirectional_transition(
				div0,
				blur,
				{
					amount: 10,
					duration: /*closable*/ ctx[4] ? 400 : 0
				},
				false
			);

			div0_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(dashboardheader);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			destroy_component(dashboardfooter);
			if (detaching && div0_transition) div0_transition.end();
		}
	};
}

// (94:35) 
function create_if_block_2(ctx) {
	let dashboardpagecomponent;
	let current;

	dashboardpagecomponent = new DashboardPage({
			props: {
				dashboard: /*dashboards*/ ctx[2][/*currentDashboard*/ ctx[9]]
			}
		});

	return {
		c() {
			create_component(dashboardpagecomponent.$$.fragment);
		},
		m(target, anchor) {
			mount_component(dashboardpagecomponent, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const dashboardpagecomponent_changes = {};
			if (dirty & /*dashboards, currentDashboard*/ 516) dashboardpagecomponent_changes.dashboard = /*dashboards*/ ctx[2][/*currentDashboard*/ ctx[9]];
			dashboardpagecomponent.$set(dashboardpagecomponent_changes);
		},
		i(local) {
			if (current) return;
			transition_in(dashboardpagecomponent.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(dashboardpagecomponent.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(dashboardpagecomponent, detaching);
		}
	};
}

// (92:8) {#if showSettings}
function create_if_block_1(ctx) {
	let dashboardsettingscomponent;
	let current;
	dashboardsettingscomponent = new DashboardSettings$1({ props: { settings: /*settings*/ ctx[3] } });

	return {
		c() {
			create_component(dashboardsettingscomponent.$$.fragment);
		},
		m(target, anchor) {
			mount_component(dashboardsettingscomponent, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const dashboardsettingscomponent_changes = {};
			if (dirty & /*settings*/ 8) dashboardsettingscomponent_changes.settings = /*settings*/ ctx[3];
			dashboardsettingscomponent.$set(dashboardsettingscomponent_changes);
		},
		i(local) {
			if (current) return;
			transition_in(dashboardsettingscomponent.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(dashboardsettingscomponent.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(dashboardsettingscomponent, detaching);
		}
	};
}

function create_fragment$2(ctx) {
	let title_value;
	let t;
	let if_block_anchor;
	let current;
	document.title = title_value = /*title*/ ctx[0];
	let if_block = /*showApp*/ ctx[7] && create_if_block$1(ctx);

	return {
		c() {
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			insert(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if ((!current || dirty & /*title*/ 1) && title_value !== (title_value = /*title*/ ctx[0])) {
				document.title = title_value;
			}

			if (/*showApp*/ ctx[7]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*showApp*/ 128) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function string2slug(str) {
	let s = str.replace(/^\s+|\s+$/g, ''); // trim
	s = s.toLowerCase();

	// remove accents, swap ñ for n, etc
	const from = 'àáäâèéëêìíïîòóöôùúüûñç·/_,:;';

	const to = 'aaaaeeeeiiiioooouuuunc------';

	for (let i = 0, l = from.length; i < l; i++) {
		s = s.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i));
	}

	s = s.replace(/[^a-z0-9 -]/g, '').replace(/\s+/g, '-').replace(/-+/g, '-'); // remove invalid chars
	// collapse whitespace and replace by -
	// collapse dashes

	return s;
}

function instance$2($$self, $$props, $$invalidate) {
	let dashboardNames;
	let dashboardSlugs;
	const dispatch = createEventDispatcher();
	let { title } = $$props;
	let { author } = $$props;
	let { dashboards = {} } = $$props;
	let { settings } = $$props;
	let { page } = $$props;
	let { closable } = $$props;
	let showApp = false;

	onMount(() => {
		$$invalidate(7, showApp = true);
	});

	function quit() {
		$$invalidate(7, showApp = false);

		setTimeout(
			() => {
				dispatch('quit');
			},
			400
		);
	}

	let showSettings = false;
	let currentDashboard = Object.keys(dashboards)[0] || undefined;

	// Routing
	onMount(() => {
		try {
			const router = new Router();

			router.route('settings', () => {
				$$invalidate(8, showSettings = true);
				if (currentDashboard) dashboards[currentDashboard].destroy();
				page.set('settings');
			});

			dashboardSlugs.forEach((slug, i) => {
				router.route(slug, () => {
					$$invalidate(8, showSettings = false);
					if (currentDashboard === dashboardNames[i]) return;
					if (currentDashboard) dashboards[currentDashboard].destroy();
					$$invalidate(9, currentDashboard = dashboardNames[i]);
					page.set(slug === '' ? string2slug(dashboardNames[0]) : slug);
				});
			});
		} catch(error) {
			// eslint-disable-next-line no-console
			console.log('Could not enable router', error);
		}
	});

	const func = (o, x, i) => ({ ...o, [x]: dashboardNames[i] });

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('author' in $$props) $$invalidate(1, author = $$props.author);
		if ('dashboards' in $$props) $$invalidate(2, dashboards = $$props.dashboards);
		if ('settings' in $$props) $$invalidate(3, settings = $$props.settings);
		if ('page' in $$props) $$invalidate(11, page = $$props.page);
		if ('closable' in $$props) $$invalidate(4, closable = $$props.closable);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*dashboards*/ 4) {
			$$invalidate(6, dashboardNames = Object.keys(dashboards));
		}

		if ($$self.$$.dirty & /*dashboardNames*/ 64) {
			$$invalidate(10, dashboardSlugs = [''].concat(dashboardNames.slice(1).map(string2slug)));
		}
	};

	return [
		title,
		author,
		dashboards,
		settings,
		closable,
		quit,
		dashboardNames,
		showApp,
		showSettings,
		currentDashboard,
		dashboardSlugs,
		page,
		func
	];
}

class Dashboard$1 extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			title: 0,
			author: 1,
			dashboards: 2,
			settings: 3,
			page: 11,
			closable: 4,
			quit: 5
		});
	}

	get quit() {
		return this.$$.ctx[5];
	}
}

function isTitle(x) {
    return typeof x === 'string';
}
function isComponentArray(x) {
    return Array.isArray(x);
}
class DashboardSettings {
    constructor() {
        this.name = 'settings';
        this.components = [];
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.xModels = [];
        this.xDatasets = [];
        this.xPredictions = [];
        this.xDataStores = [];
    }
    use(...components) {
        this.components = this.components.concat(components);
        return this;
    }
    dataStores(...stores) {
        this.xDataStores = stores;
        return this;
    }
    models(...models) {
        this.xModels = models;
        return this;
    }
    datasets(...datasets) {
        this.xDatasets = datasets;
        return this;
    }
    predictions(...predictions) {
        this.xPredictions = predictions;
        return this;
    }
    mount() {
        for (const m of this.components) {
            if (isComponentArray(m)) {
                for (const n of m) {
                    n.mount();
                }
            }
            else if (!isTitle(m)) {
                m.mount();
            }
        }
    }
    destroy() {
        for (const m of this.components) {
            if (isComponentArray(m)) {
                for (const n of m) {
                    n.destroy();
                }
            }
            else if (!isTitle(m)) {
                m.destroy();
            }
        }
    }
}

class Dashboard {
    constructor({ title = 'Hello, Marcelle!', author = 'author', closable = false, }) {
        this.panels = {};
        this.settings = new DashboardSettings();
        this.$active = new Stream(false, true);
        this.$page = new Stream('', true);
        this.title = title;
        this.author = author;
        this.closable = closable;
    }
    page(name, showSidebar) {
        if (!Object.keys(this.panels).includes(name)) {
            this.panels[name] = new DashboardPage$1(name, showSidebar);
        }
        return this.panels[name];
    }
    show() {
        this.app = new Dashboard$1({
            target: document.body,
            props: {
                title: this.title,
                author: this.author,
                dashboards: this.panels,
                settings: this.settings,
                page: this.$page,
                closable: this.closable,
            },
        });
        this.$active.set(true);
        this.app.$on('quit', () => {
            var _a;
            this.$active.set(false);
            (_a = this.app) === null || _a === void 0 ? void 0 : _a.$destroy();
            for (const panel of Object.values(this.panels)) {
                panel.destroy();
            }
            this.app = undefined;
        });
    }
    hide() {
        var _a;
        (_a = this.app) === null || _a === void 0 ? void 0 : _a.quit();
    }
}
function dashboard(options) {
    return new Dashboard(options);
}

/* src/layouts/wizard/WizardPage.svelte generated by Svelte v3.52.0 */

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i].id;
	return child_ctx;
}

// (27:10) {:else}
function create_else_block(ctx) {
	let div;
	let div_id_value;

	return {
		c() {
			div = element("div");
			attr(div, "id", div_id_value = /*m*/ ctx[4].id);
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*components*/ 8 && div_id_value !== (div_id_value = /*m*/ ctx[4].id)) {
				attr(div, "id", div_id_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (21:10) {#if Array.isArray(m)}
function create_if_block(ctx) {
	let div;
	let t;
	let each_value_1 = /*m*/ ctx[4];
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			attr(div, "class", "flex flex-row flex-wrap items-stretch");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*components*/ 8) {
				each_value_1 = /*m*/ ctx[4];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, t);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (23:14) {#each m as { id }}
function create_each_block_1(ctx) {
	let div;
	let div_id_value;

	return {
		c() {
			div = element("div");
			attr(div, "id", div_id_value = /*id*/ ctx[7]);
			attr(div, "class", "flex-none xl:flex-1 w-full xl:w-auto");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*components*/ 8 && div_id_value !== (div_id_value = /*id*/ ctx[7])) {
				attr(div, "id", div_id_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (20:8) {#each components as m}
function create_each_block$1(ctx) {
	let show_if;
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (dirty & /*components*/ 8) show_if = null;
		if (show_if == null) show_if = !!Array.isArray(/*m*/ ctx[4]);
		if (show_if) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$1(ctx) {
	let div5;
	let div4;
	let div1;
	let h3;
	let t0;
	let t1;
	let t2;
	let t3;
	let div0;
	let p;
	let t4;
	let t5;
	let div3;
	let div2;
	let each_value = /*components*/ ctx[3];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	return {
		c() {
			div5 = element("div");
			div4 = element("div");
			div1 = element("div");
			h3 = element("h3");
			t0 = text$1(/*index*/ ctx[0]);
			t1 = text$1(".\n        ");
			t2 = text$1(/*title*/ ctx[1]);
			t3 = space();
			div0 = element("div");
			p = element("p");
			t4 = text$1(/*description*/ ctx[2]);
			t5 = space();
			div3 = element("div");
			div2 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(h3, "class", "text-lg leading-6 font-medium text-gray-900");
			attr(h3, "id", "modal-headline");
			attr(p, "class", "text-sm leading-5 text-gray-500");
			attr(div0, "class", "mt-2");
			attr(div1, "class", "desc svelte-tq2nfn");
			attr(div2, "class", "text-center");
			attr(div3, "class", "components svelte-tq2nfn");
			attr(div4, "class", "flex flex-col w-full");
			attr(div5, "class", "bg-white px-4 pt-2 pb-4 sm:px-6 sm:pb-4 flex");
		},
		m(target, anchor) {
			insert(target, div5, anchor);
			append(div5, div4);
			append(div4, div1);
			append(div1, h3);
			append(h3, t0);
			append(h3, t1);
			append(h3, t2);
			append(div1, t3);
			append(div1, div0);
			append(div0, p);
			append(p, t4);
			append(div4, t5);
			append(div4, div3);
			append(div3, div2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div2, null);
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*index*/ 1) set_data(t0, /*index*/ ctx[0]);
			if (dirty & /*title*/ 2) set_data(t2, /*title*/ ctx[1]);
			if (dirty & /*description*/ 4) set_data(t4, /*description*/ ctx[2]);

			if (dirty & /*components, Array*/ 8) {
				each_value = /*components*/ ctx[3];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div2, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) detach(div5);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let { index } = $$props;
	let { title } = $$props;
	let { description } = $$props;
	let { components = [] } = $$props;

	$$self.$$set = $$props => {
		if ('index' in $$props) $$invalidate(0, index = $$props.index);
		if ('title' in $$props) $$invalidate(1, title = $$props.title);
		if ('description' in $$props) $$invalidate(2, description = $$props.description);
		if ('components' in $$props) $$invalidate(3, components = $$props.components);
	};

	return [index, title, description, components];
}

class WizardPage$1 extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			index: 0,
			title: 1,
			description: 2,
			components: 3
		});
	}
}

/* src/layouts/wizard/Wizard.svelte generated by Svelte v3.52.0 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i];
	child_ctx[12] = i;
	return child_ctx;
}

// (69:11) <Button type="danger" on:click={quit}>
function create_default_slot_2(ctx) {
	let t;

	return {
		c() {
			t = text$1("Close");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (71:8) {#each Array(pages.length) as _, i}
function create_each_block(ctx) {
	let button;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[6](/*i*/ ctx[12]);
	}

	return {
		c() {
			button = element("button");
			attr(button, "class", "page-button svelte-1r1rt01");
			toggle_class(button, "current", /*$current*/ ctx[3] === /*i*/ ctx[12]);
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (!mounted) {
				dispose = listen(button, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*$current*/ 8) {
				toggle_class(button, "current", /*$current*/ ctx[3] === /*i*/ ctx[12]);
			}
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (76:8) <Button           disabled={$current <= 0}           on:click={() => {             goToPage($current - 1);           }}         >
function create_default_slot_1(ctx) {
	let t;

	return {
		c() {
			t = text$1("Previous");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (84:8) <Button           variant="filled"           type={$current >= pages.length - 1 ? 'success' : 'default'}           on:click={() => {             if (current.get() < pages.length - 1) {               goToPage($current + 1);             } else {               quit();             }           }}         >
function create_default_slot(ctx) {
	let t_value = (/*$current*/ ctx[3] >= /*pages*/ ctx[0].length - 1
	? 'Finish'
	: 'Next') + "";

	let t;

	return {
		c() {
			t = text$1(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$current, pages*/ 9 && t_value !== (t_value = (/*$current*/ ctx[3] >= /*pages*/ ctx[0].length - 1
			? 'Finish'
			: 'Next') + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment(ctx) {
	let div7;
	let div1;
	let div0;
	let t0;
	let div6;
	let wizardpagecomponent;
	let t1;
	let div5;
	let div2;
	let button0;
	let t2;
	let div3;
	let t3;
	let div4;
	let button1;
	let t4;
	let button2;
	let current;
	let mounted;
	let dispose;

	wizardpagecomponent = new WizardPage$1({
			props: {
				title: /*pages*/ ctx[0][/*$current*/ ctx[3]].attr.title,
				description: /*pages*/ ctx[0][/*$current*/ ctx[3]].attr.description,
				components: /*pages*/ ctx[0][/*$current*/ ctx[3]].components,
				index: /*$current*/ ctx[3] + 1
			}
		});

	button0 = new Button$1({
			props: {
				type: "danger",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			}
		});

	button0.$on("click", /*quit*/ ctx[2]);
	let each_value = Array(/*pages*/ ctx[0].length);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	button1 = new Button$1({
			props: {
				disabled: /*$current*/ ctx[3] <= 0,
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	button1.$on("click", /*click_handler_1*/ ctx[7]);

	button2 = new Button$1({
			props: {
				variant: "filled",
				type: /*$current*/ ctx[3] >= /*pages*/ ctx[0].length - 1
				? 'success'
				: 'default',
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	button2.$on("click", /*click_handler_2*/ ctx[8]);

	return {
		c() {
			div7 = element("div");
			div1 = element("div");
			div0 = element("div");
			t0 = space();
			div6 = element("div");
			create_component(wizardpagecomponent.$$.fragment);
			t1 = space();
			div5 = element("div");
			div2 = element("div");
			create_component(button0.$$.fragment);
			t2 = space();
			div3 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t3 = space();
			div4 = element("div");
			create_component(button1.$$.fragment);
			t4 = space();
			create_component(button2.$$.fragment);
			attr(div0, "class", "absolute inset-0 bg-gray-500 opacity-50");
			attr(div1, "class", "absolute min-h-screen inset-0 transition-opacity");
			attr(div3, "class", "text-center");
			attr(div4, "class", "text-right");
			attr(div5, "class", "bg-white border-t border-gray-300 px-4 py-2 grid grid-cols-3");
			attr(div6, "class", "bg-white rounded-lg overflow-hidden shadow-xl transform transition-all sm:max-w-3xl sm:w-full");
			attr(div7, "class", "marcelle wizard svelte-1r1rt01");
		},
		m(target, anchor) {
			insert(target, div7, anchor);
			append(div7, div1);
			append(div1, div0);
			append(div7, t0);
			append(div7, div6);
			mount_component(wizardpagecomponent, div6, null);
			append(div6, t1);
			append(div6, div5);
			append(div5, div2);
			mount_component(button0, div2, null);
			append(div5, t2);
			append(div5, div3);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div3, null);
			}

			append(div5, t3);
			append(div5, div4);
			mount_component(button1, div4, null);
			append(div4, t4);
			mount_component(button2, div4, null);
			current = true;

			if (!mounted) {
				dispose = listen(div0, "click", /*onOutsideClick*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			const wizardpagecomponent_changes = {};
			if (dirty & /*pages, $current*/ 9) wizardpagecomponent_changes.title = /*pages*/ ctx[0][/*$current*/ ctx[3]].attr.title;
			if (dirty & /*pages, $current*/ 9) wizardpagecomponent_changes.description = /*pages*/ ctx[0][/*$current*/ ctx[3]].attr.description;
			if (dirty & /*pages, $current*/ 9) wizardpagecomponent_changes.components = /*pages*/ ctx[0][/*$current*/ ctx[3]].components;
			if (dirty & /*$current*/ 8) wizardpagecomponent_changes.index = /*$current*/ ctx[3] + 1;
			wizardpagecomponent.$set(wizardpagecomponent_changes);
			const button0_changes = {};

			if (dirty & /*$$scope*/ 8192) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);

			if (dirty & /*$current, goToPage, pages*/ 25) {
				each_value = Array(/*pages*/ ctx[0].length);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div3, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			const button1_changes = {};
			if (dirty & /*$current*/ 8) button1_changes.disabled = /*$current*/ ctx[3] <= 0;

			if (dirty & /*$$scope*/ 8192) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
			const button2_changes = {};

			if (dirty & /*$current, pages*/ 9) button2_changes.type = /*$current*/ ctx[3] >= /*pages*/ ctx[0].length - 1
			? 'success'
			: 'default';

			if (dirty & /*$$scope, $current, pages*/ 8201) {
				button2_changes.$$scope = { dirty, ctx };
			}

			button2.$set(button2_changes);
		},
		i(local) {
			if (current) return;
			transition_in(wizardpagecomponent.$$.fragment, local);
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			transition_in(button2.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(wizardpagecomponent.$$.fragment, local);
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			transition_out(button2.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div7);
			destroy_component(wizardpagecomponent);
			destroy_component(button0);
			destroy_each(each_blocks, detaching);
			destroy_component(button1);
			destroy_component(button2);
			mounted = false;
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $current,
		$$unsubscribe_current = noop$1,
		$$subscribe_current = () => ($$unsubscribe_current(), $$unsubscribe_current = subscribe(current, $$value => $$invalidate(3, $current = $$value)), current);

	$$self.$$.on_destroy.push(() => $$unsubscribe_current());
	let { pages } = $$props;
	let { current } = $$props;
	$$subscribe_current();

	function goToPage(index) {
		if (index >= 0 && index <= pages.length - 1) {
			for (const m of pages[current.get()].components) {
				if (Array.isArray(m)) {
					for (const n of m) {
						n.destroy();
					}
				} else {
					m.destroy();
				}
			}

			current.set(index);
		}
	}

	afterUpdate(() => {
		for (const m of pages[current.get()].components) {
			if (Array.isArray(m)) {
				for (const n of m) {
					n.mount();
				}
			} else {
				m.mount();
			}
		}
	});

	onDestroy(() => {
		for (const m of pages[current.get()].components) {
			if (Array.isArray(m)) {
				for (const n of m) {
					n.destroy();
				}
			} else {
				m.destroy();
			}
		}
	});

	const dispatch = createEventDispatcher();

	function quit() {
		dispatch('quit');
	}

	function onOutsideClick() {
		quit();
	}

	const click_handler = i => goToPage(i);

	const click_handler_1 = () => {
		goToPage($current - 1);
	};

	const click_handler_2 = () => {
		if (current.get() < pages.length - 1) {
			goToPage($current + 1);
		} else {
			quit();
		}
	};

	$$self.$$set = $$props => {
		if ('pages' in $$props) $$invalidate(0, pages = $$props.pages);
		if ('current' in $$props) $$subscribe_current($$invalidate(1, current = $$props.current));
	};

	return [
		pages,
		current,
		quit,
		$current,
		goToPage,
		onOutsideClick,
		click_handler,
		click_handler_1,
		click_handler_2
	];
}

class Wizard$1 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { pages: 0, current: 1, quit: 2 });
	}

	get quit() {
		return this.$$.ctx[2];
	}
}

class WizardPage {
    constructor(pageFn) {
        this.pageFn = pageFn;
        this.components = [];
        this.attr = { title: '', description: '' };
    }
    title(title) {
        this.attr.title = title;
        return this;
    }
    description(desc) {
        this.attr.description = desc;
        return this;
    }
    use(...components) {
        this.components = this.components.concat(components);
        return this;
    }
    page() {
        return this.pageFn();
    }
}

class Wizard {
    constructor() {
        this.pages = [];
        this.app = undefined;
        this.$current = new Stream(0, true);
        this.$current.start();
    }
    page() {
        const s = new WizardPage(this.page.bind(this));
        this.pages.push(s);
        return s;
    }
    show() {
        this.app = new Wizard$1({
            target: document.body,
            props: {
                pages: this.pages,
                current: this.$current,
            },
        });
        this.app.$on('quit', () => {
            var _a;
            (_a = this.app) === null || _a === void 0 ? void 0 : _a.$destroy();
            this.app = undefined;
        });
    }
    hide() {
        var _a;
        (_a = this.app) === null || _a === void 0 ? void 0 : _a.quit();
    }
}
function wizard() {
    return new Wizard();
}

export { ArrayIterable, Component, LazyIterable, LogLevel, Model, ServiceIterable, Stream, TFJSBaseModel, TFJSCustomClassifier, TFJSCustomModel, account, batchPrediction, button, cocoSsd, confidencePlot, confusionMatrix, createStream, dashboard, dataStore, dataset, dataset2tfjs, datasetBrowser, datasetScatter, datasetTable, detectionBoxes, fileUpload, genericChart, getLogStream, imageDisplay, imageUpload, isDataset, isStream, iterableFromArray, iterableFromService, kmeansClustering, knnClassifier, logger, mergeDeep, mlpClassifier, mlpRegressor, mobileNet, modelParameters, notification, number, numberArray, onnxModel, pca, poseDetection, predictionProgress, progressBar, scatterPlot, select, sketchPad, slider, text, textArea, textField, textInput, tfjsModel, throwError, toggle, trainingHistory, trainingPlot, trainingProgress, umap, webcam, wizard };
//# sourceMappingURL=marcelle.esm.js.map
