export declare function isIterable<T>(item: unknown): item is Iterable<T>;
export declare function isAsyncIterable<T>(item: unknown): item is AsyncIterable<T>;
export declare class LazyIterable<T> implements AsyncIterable<T> {
    private readonly source;
    constructor(source: () => AsyncIterable<T>);
    [Symbol.asyncIterator](): AsyncIterator<T>;
    entries(): LazyIterable<[number, T]>;
    keys(): LazyIterable<number>;
    values(): LazyIterable<T>;
    forEach(action: (element: T, index: number) => void): Promise<void>;
    concat(other: T | Promise<T> | Iterable<T> | AsyncIterable<T>): LazyIterable<T>;
    reduce(callback: (accumulator: T, current: T, index: number) => T): Promise<T>;
    reduce<TAccumulator>(callback: (accumulator: TAccumulator, current: T, index: number) => TAccumulator, initialValue: TAccumulator): Promise<TAccumulator>;
    filter(predicate: (element: T, index: number) => boolean): LazyIterable<T>;
    take(count: number): LazyIterable<T>;
    skip(count: number): LazyIterable<T>;
    map<S>(selector: (element: T, index: number) => S): LazyIterable<S>;
    zip<TRight>(other: () => AsyncIterable<TRight>): LazyIterable<[T, TRight]>;
    toArray(): Promise<T[]>;
}
