import { Tensor, TensorLike } from '@tensorflow/tfjs-core';
import '@tensorflow/tfjs-core/dist/public/chained_ops/gather';
import '@tensorflow/tfjs-core/dist/public/chained_ops/arg_max';
import '@tensorflow/tfjs-core/dist/public/chained_ops/squeeze';
import '@tensorflow/tfjs-core/dist/public/chained_ops/expand_dims';
import { loadLayersModel, Sequential } from '@tensorflow/tfjs-layers';
import { Dataset } from '../../core/dataset';
import { TFDataset } from '../../core/model/tfjs-utils';
import { TFJSBaseModel } from './tfjs-base-model';
import { Stream } from '../stream';
import type { Instance } from '../types';
import type { LazyIterable } from '../../utils';
export interface TFJSCustomModelOptions {
    epochs: number;
    batchSize: number;
    validationSplit: number;
}
export declare abstract class TFJSCustomModel<T extends Instance, PredictionType> extends TFJSBaseModel<T, PredictionType> {
    title: string;
    model: Sequential;
    loadFn: typeof loadLayersModel;
    validationSplit: number;
    parameters: {
        epochs: Stream<number>;
        batchSize: Stream<number>;
    };
    constructor({ epochs, batchSize, validationSplit, }?: Partial<TFJSCustomModelOptions>);
    transformDataset(ds: TFDataset<Partial<T>>): TFDataset<{
        xs: Tensor;
        ys: Tensor;
    }>;
    train(dataset: Dataset<T> | LazyIterable<T>, validationDataset?: Dataset<T> | LazyIterable<T>): Promise<void>;
    abstract predict(x: T['x']): Promise<PredictionType>;
    _predict(x: TensorLike): Tensor;
    clear(): void;
    abstract buildModel(inputShape: Tensor['shape'], outputShape: Tensor['shape']): void;
    fit(dsTrain: TFDataset<{
        xs: Tensor;
        ys: Tensor;
    }>, dsVal: TFDataset<{
        xs: Tensor;
        ys: Tensor;
    }>): void;
}
