import type { Stream as MostStream, Disposable, Scheduler, Sink, Time } from '@most/types';
import type { SeedValue } from '@most/core/dist/combinator/loop';
import { noop } from '../utils/misc';
export declare function isStream<T>(s: Stream<T> | unknown): s is Stream<T>;
export declare class Stream<T> {
    #private;
    static nextId: number;
    static numActive: number;
    id: number;
    private stream;
    private stopStream;
    private subscribers;
    value: T;
    ready: boolean;
    set: (value: T) => void;
    constructor(s: Stream<T> | MostStream<T> | T, hold?: boolean);
    get(): T;
    get holding(): boolean;
    run(sink: Sink<T>, s: Scheduler): Disposable;
    private runListeners;
    subscribe(run?: (value: T) => void, invalidate?: typeof noop): () => void;
    start(): Promise<void>;
    stop(): void;
    hold(h?: boolean): Stream<T>;
    thru<B>(f: (s: Stream<T>) => MostStream<B>): Stream<B>;
    startWith(x: T): Stream<T>;
    continueWith<U>(f: () => Stream<U>): Stream<T | U>;
    map<U>(f: (a: T) => U): Stream<U>;
    constant<B>(x: B): Stream<B>;
    tap(f: (a: T) => void): Stream<T>;
    ap<B>(fs: Stream<(a: T) => B>): Stream<B>;
    scan<B>(f: (b: B, a: T) => B, initial: B): Stream<B>;
    loop<B, S>(stepper: (seed: S, a: T) => SeedValue<S, B>, seed: S): Stream<B>;
    withItems<A>(items: A[]): Stream<A>;
    zipItems<A, C>(f: (a: A, b: T) => C, items: A[]): Stream<C>;
    switchLatest<U>(): Stream<U>;
    join<U>(): Stream<U>;
    chain<B>(f: (value: T) => Stream<B>): Stream<B>;
    concatMap<B>(f: (a: T) => Stream<B>): Stream<B>;
    mergeConcurrently<U>(concurrency: number): Stream<U>;
    mergeMapConcurrently<B>(f: (a: T) => Stream<B>, concurrency: number): Stream<B>;
    merge<A>(stream1: Stream<A>): Stream<A | T>;
    combine<A, R>(f: (a: A, b: T) => R, stream1: Stream<A>): Stream<R>;
    zip<A, R>(f: (a: A, b: T) => R, stream1: Stream<A>): Stream<R>;
    resample<B>(sampler: Stream<B>): Stream<T>;
    sample<A>(values: Stream<A>): Stream<A>;
    snapshot<A, C>(f: (a: A, b: T) => C, values: Stream<A>): Stream<C>;
    filter(p: (a: T) => boolean): Stream<T>;
    skipRepeats(): Stream<T>;
    skipRepeatsWith(equals: (a1: T, a2: T) => boolean): Stream<T>;
    slice(start: number, end: number): Stream<T>;
    take(n: number): Stream<T>;
    skip(n: number): Stream<T>;
    takeWhile(p: (a: T) => boolean): Stream<T>;
    skipWhile(p: (a: T) => boolean): Stream<T>;
    skipAfter(p: (a: T) => boolean): Stream<T>;
    until(endSignal: Stream<unknown>): Stream<T>;
    since(startSignal: Stream<unknown>): Stream<T>;
    during(timeWindow: Stream<Stream<unknown>>): Stream<T>;
    delay(delayTime: number): Stream<T>;
    withLocalTime(origin: Time): Stream<T>;
    throttle(period: number): Stream<T>;
    debounce(period: number): Stream<T>;
    awaitPromises(): Stream<Awaited<T>>;
    recoverWith<A, E extends Error>(f: (error: E) => Stream<A>): Stream<T | A>;
    static empty(): Stream<never>;
    static never(): Stream<never>;
    static now<A>(x: A): Stream<A>;
    static at<A>(t: Time, x: A): Stream<A>;
    static periodic(period: number): Stream<void>;
    static throwError(e: Error): Stream<never>;
}
export declare function createStream<T>(s: MostStream<T> | T, hold?: boolean): Stream<T>;
