import { Tensor, Tensor3D, TensorLike } from '@tensorflow/tfjs-core';
import '@tensorflow/tfjs-core/dist/public/chained_ops/mul';
import '@tensorflow/tfjs-core/dist/public/chained_ops/expand_dims';
import { ClassifierResults, Instance, TFJSBaseModel } from '../../core';
export interface InputTypes {
    image: ImageData;
    generic: TensorLike;
}
export interface OutputTypes {
    classification: string;
    segmentation: ImageData | TensorLike;
    generic: TensorLike;
}
export interface PredictionTypes {
    classification: ClassifierResults;
    segmentation: ImageData | TensorLike;
    generic: TensorLike;
}
export interface TFJSModelOptions<T, U> {
    inputType: T;
    taskType: U;
    segmentationOptions?: {
        output?: 'image' | 'tensor';
        applyArgmax?: boolean;
    };
}
export interface TFJSInstance<InputType, OutputType> extends Instance {
    x: InputType;
    y: OutputType;
}
export declare class TFJSModel<InputType extends keyof InputTypes, TaskType extends keyof OutputTypes> extends TFJSBaseModel<TFJSInstance<InputTypes[InputType], OutputTypes[TaskType]>, PredictionTypes[TaskType]> {
    title: string;
    inputShape: number[];
    inputType: InputType;
    taskType: TaskType;
    parameters: {};
    segmentationOptions: Record<string, unknown>;
    constructor({ inputType, taskType, segmentationOptions, }: TFJSModelOptions<InputType, TaskType>);
    train(): never;
    predict(input: InputTypes[InputType]): Promise<PredictionTypes[TaskType]>;
    preprocess(input: InputTypes[InputType]): Tensor;
    preprocessImage(img: InputTypes['image']): Tensor3D;
    postprocess(outputs: Tensor): Promise<PredictionTypes[TaskType]>;
    loadFromFiles(files: File[]): Promise<void>;
    loadFromUrl(url: string): Promise<void>;
    mount(target?: HTMLElement): void;
}
