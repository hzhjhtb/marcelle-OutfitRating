import { curry2, compose, apply, id, reduce, map as map$2, append, findIndex, remove, curry3 } from '@most/prelude';
import { asap, delay as delay$2, periodic as periodic$1, schedulerRelativeTo, currentTime, cancelTask } from '@most/scheduler';
import { disposeNone, disposeBoth, tryDispose as tryDispose$1, disposeOnce, disposeAll } from '@most/disposable';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */
function fatalError(e) {
    setTimeout(rethrow, 0, e);
}
function rethrow(e) {
    throw e;
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
var propagateTask = function (run, value, sink) { return new PropagateRunEventTask(run, value, sink); };
var propagateEventTask = function (value, sink) { return new PropagateEventTask(value, sink); };
var propagateEndTask = function (sink) { return new PropagateEndTask(sink); };
var propagateErrorTask = function (value, sink) { return new PropagateErrorTask(value, sink); };
var PropagateTask = /** @class */ (function () {
    function PropagateTask(sink) {
        this.sink = sink;
        this.active = true;
    }
    PropagateTask.prototype.dispose = function () {
        this.active = false;
    };
    PropagateTask.prototype.run = function (t) {
        if (!this.active) {
            return;
        }
        this.runIfActive(t);
    };
    PropagateTask.prototype.error = function (t, e) {
        // TODO: Remove this check and just do this.sink.error(t, e)?
        if (!this.active) {
            return fatalError(e);
        }
        this.sink.error(t, e);
    };
    return PropagateTask;
}());
var PropagateRunEventTask = /** @class */ (function (_super) {
    __extends(PropagateRunEventTask, _super);
    function PropagateRunEventTask(runEvent, value, sink) {
        var _this = _super.call(this, sink) || this;
        _this.runEvent = runEvent;
        _this.value = value;
        return _this;
    }
    PropagateRunEventTask.prototype.runIfActive = function (t) {
        this.runEvent(t, this.value, this.sink);
    };
    return PropagateRunEventTask;
}(PropagateTask));
var PropagateEventTask = /** @class */ (function (_super) {
    __extends(PropagateEventTask, _super);
    function PropagateEventTask(value, sink) {
        var _this = _super.call(this, sink) || this;
        _this.value = value;
        return _this;
    }
    PropagateEventTask.prototype.runIfActive = function (t) {
        this.sink.event(t, this.value);
    };
    return PropagateEventTask;
}(PropagateTask));
var PropagateEndTask = /** @class */ (function (_super) {
    __extends(PropagateEndTask, _super);
    function PropagateEndTask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PropagateEndTask.prototype.runIfActive = function (t) {
        this.sink.end(t);
    };
    return PropagateEndTask;
}(PropagateTask));
var PropagateErrorTask = /** @class */ (function (_super) {
    __extends(PropagateErrorTask, _super);
    function PropagateErrorTask(value, sink) {
        var _this = _super.call(this, sink) || this;
        _this.value = value;
        return _this;
    }
    PropagateErrorTask.prototype.runIfActive = function (t) {
        this.sink.error(t, this.value);
    };
    return PropagateErrorTask;
}(PropagateTask));

/** @license MIT License (c) copyright 2010-2017 original author or authors */
var empty = function () { return EMPTY; };
var isCanonicalEmpty = function (stream) {
    return stream === EMPTY;
};
var containsCanonicalEmpty = function (streams) {
    return streams.some(isCanonicalEmpty);
};
var Empty = /** @class */ (function () {
    function Empty() {
    }
    Empty.prototype.run = function (sink, scheduler) {
        return asap(propagateEndTask(sink), scheduler);
    };
    return Empty;
}());
var EMPTY = new Empty();

/** @license MIT License (c) copyright 2010-2017 original author or authors */
var never = function () { return NEVER; };
var Never = /** @class */ (function () {
    function Never() {
    }
    Never.prototype.run = function () {
        return disposeNone();
    };
    return Never;
}());
var NEVER = new Never();

/** @license MIT License (c) copyright 2010-2017 original author or authors */
var at = function (t, x) { return new At(t, x); };
var At = /** @class */ (function () {
    function At(t, x) {
        this.time = t;
        this.value = x;
    }
    At.prototype.run = function (sink, scheduler) {
        return delay$2(this.time, propagateTask(runAt, this.value, sink), scheduler);
    };
    return At;
}());
function runAt(t, x, sink) {
    sink.event(t, x);
    sink.end(t);
}

/** @license MIT License (c) copyright 2010-2017 original author or authors */
var now = function (x) { return at(0, x); };

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/**
 * Create a stream of events that occur at a regular period
 * @param {Number} period periodicity of events
 * @returns {Stream} new stream of periodic events, the event value is undefined
 */
var periodic = function (period) {
    return new Periodic(period);
};
var Periodic = /** @class */ (function () {
    function Periodic(period) {
        this.period = period;
    }
    Periodic.prototype.run = function (sink, scheduler) {
        return periodic$1(this.period, propagateEventTask(undefined, sink), scheduler);
    };
    return Periodic;
}());

var newStream = function (run) { return new StreamImpl(run); };
var StreamImpl = /** @class */ (function () {
    function StreamImpl(run) {
        this.run = run;
    }
    return StreamImpl;
}());

var SettableDisposable = /** @class */ (function () {
    function SettableDisposable() {
        this.disposable = undefined;
        this.disposed = false;
    }
    SettableDisposable.prototype.setDisposable = function (disposable) {
        if (this.disposable !== undefined) {
            throw new Error('setDisposable called more than once');
        }
        this.disposable = disposable;
        if (this.disposed) {
            disposable.dispose();
        }
    };
    SettableDisposable.prototype.dispose = function () {
        if (this.disposed) {
            return;
        }
        this.disposed = true;
        if (this.disposable !== undefined) {
            this.disposable.dispose();
        }
    };
    return SettableDisposable;
}());

/** @license MIT License (c) copyright 2010-2017 original author or authors */
var runEffects = curry2(function (stream, scheduler) {
    return new Promise(function (resolve, reject) {
        return runStream(stream, scheduler, resolve, reject);
    });
});
function runStream(stream, scheduler, resolve, reject) {
    var disposable = new SettableDisposable();
    var observer = new RunEffectsSink(resolve, reject, disposable);
    disposable.setDisposable(stream.run(observer, scheduler));
}
var RunEffectsSink = /** @class */ (function () {
    function RunEffectsSink(end, error, disposable) {
        this._end = end;
        this._error = error;
        this._disposable = disposable;
        this.active = true;
    }
    RunEffectsSink.prototype.event = function () { };
    RunEffectsSink.prototype.end = function () {
        if (!this.active) {
            return;
        }
        this.dispose(this._error, this._end, undefined);
    };
    RunEffectsSink.prototype.error = function (_t, e) {
        this.dispose(this._error, this._error, e);
    };
    RunEffectsSink.prototype.dispose = function (error, end, x) {
        this.active = false;
        tryDispose(error, end, x, this._disposable);
    };
    return RunEffectsSink;
}());
function tryDispose(error, end, x, disposable) {
    try {
        disposable.dispose();
    }
    catch (e) {
        error(e);
        return;
    }
    end(x);
}

/**
 * Run a Stream, sending all its events to the provided Sink.
 */
var run = function (sink, scheduler, stream) {
    return stream.run(sink, scheduler);
};

var RelativeSink = /** @class */ (function () {
    function RelativeSink(offset, sink) {
        this.sink = sink;
        this.offset = offset;
    }
    RelativeSink.prototype.event = function (t, x) {
        this.sink.event(t + this.offset, x);
    };
    RelativeSink.prototype.error = function (t, e) {
        this.sink.error(t + this.offset, e);
    };
    RelativeSink.prototype.end = function (t) {
        this.sink.end(t + this.offset);
    };
    return RelativeSink;
}());

/**
 * Create a stream with its own local clock
 * This transforms time from the provided scheduler's clock to a stream-local
 * clock (which starts at 0), and then *back* to the scheduler's clock before
 * propagating events to sink.  In other words, upstream sources will see local times,
 * and downstream sinks will see non-local (original) times.
 */
var withLocalTime = function (origin, stream) {
    return new WithLocalTime(origin, stream);
};
var WithLocalTime = /** @class */ (function () {
    function WithLocalTime(origin, source) {
        this.origin = origin;
        this.source = source;
    }
    WithLocalTime.prototype.run = function (sink, scheduler) {
        return this.source.run(relativeSink(this.origin, sink), schedulerRelativeTo(this.origin, scheduler));
    };
    return WithLocalTime;
}());
/**
 * Accumulate offsets instead of nesting RelativeSinks, which can happen
 * with higher-order stream and combinators like continueWith when they're
 * applied recursively.
 */
var relativeSink = function (origin, sink) {
    return sink instanceof RelativeSink
        ? new RelativeSink(origin + sink.offset, sink.sink)
        : new RelativeSink(origin, sink);
};

var Pipe = /** @class */ (function () {
    function Pipe(sink) {
        this.sink = sink;
    }
    Pipe.prototype.end = function (t) {
        return this.sink.end(t);
    };
    Pipe.prototype.error = function (t, e) {
        return this.sink.error(t, e);
    };
    return Pipe;
}());

/** @license MIT License (c) copyright 2010 original author or authors */
/**
 * Generalized feedback loop. Call a stepper function for each event. The stepper
 * will be called with 2 params: the current seed and the an event value.  It must
 * return a new { seed, value } pair. The `seed` will be fed back into the next
 * invocation of stepper, and the `value` will be propagated as the event value.
 * @param stepper loop step function
 * @param seed initial seed value passed to first stepper call
 * @param stream event stream
 * @returns new stream whose values are the `value` field of the objects
 * returned by the stepper
 */
var loop = function (stepper, seed, stream) {
    return isCanonicalEmpty(stream) ? empty()
        : new Loop(stepper, seed, stream);
};
var Loop = /** @class */ (function () {
    function Loop(stepper, seed, source) {
        this.step = stepper;
        this.seed = seed;
        this.source = source;
    }
    Loop.prototype.run = function (sink, scheduler) {
        return this.source.run(new LoopSink(this.step, this.seed, sink), scheduler);
    };
    return Loop;
}());
var LoopSink = /** @class */ (function (_super) {
    __extends(LoopSink, _super);
    function LoopSink(stepper, seed, sink) {
        var _this = _super.call(this, sink) || this;
        _this.step = stepper;
        _this.seed = seed;
        return _this;
    }
    LoopSink.prototype.event = function (t, x) {
        var result = this.step(this.seed, x);
        this.seed = result.seed;
        this.sink.event(t, result.value);
    };
    return LoopSink;
}(Pipe));

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/**
 * Create a stream containing successive reduce results of applying f to
 * the previous reduce result and the current stream item.
 * @param f reducer function
 * @param initial initial value
 * @param stream stream to scan
 * @returns new stream containing successive reduce results
 */
var scan = function (f, initial, stream) {
    return new Scan(f, initial, stream);
};
var Scan = /** @class */ (function () {
    function Scan(f, z, source) {
        this.source = source;
        this.f = f;
        this.value = z;
    }
    Scan.prototype.run = function (sink, scheduler) {
        var d1 = asap(propagateEventTask(this.value, sink), scheduler);
        var d2 = this.source.run(new ScanSink(this.f, this.value, sink), scheduler);
        return disposeBoth(d1, d2);
    };
    return Scan;
}());
var ScanSink = /** @class */ (function (_super) {
    __extends(ScanSink, _super);
    function ScanSink(f, z, sink) {
        var _this = _super.call(this, sink) || this;
        _this.f = f;
        _this.value = z;
        return _this;
    }
    ScanSink.prototype.event = function (t, x) {
        var f = this.f;
        this.value = f(this.value, x);
        this.sink.event(t, this.value);
    };
    return ScanSink;
}(Pipe));

/** @license MIT License (c) copyright 2010-2016 original author or authors */
var continueWith = function (f, stream) {
    return new ContinueWith(f, stream);
};
var ContinueWith = /** @class */ (function () {
    function ContinueWith(f, source) {
        this.f = f;
        this.source = source;
    }
    ContinueWith.prototype.run = function (sink, scheduler) {
        return new ContinueWithSink(this.f, this.source, sink, scheduler);
    };
    return ContinueWith;
}());
var ContinueWithSink = /** @class */ (function (_super) {
    __extends(ContinueWithSink, _super);
    function ContinueWithSink(f, source, sink, scheduler) {
        var _this = _super.call(this, sink) || this;
        _this.f = f;
        _this.scheduler = scheduler;
        _this.active = true;
        _this.disposable = disposeOnce(source.run(_this, scheduler));
        return _this;
    }
    ContinueWithSink.prototype.event = function (t, x) {
        if (!this.active) {
            return;
        }
        this.sink.event(t, x);
    };
    ContinueWithSink.prototype.end = function (t) {
        if (!this.active) {
            return;
        }
        tryDispose$1(t, this.disposable, this.sink);
        this.startNext(t, this.sink);
    };
    ContinueWithSink.prototype.startNext = function (t, sink) {
        try {
            this.disposable = this.continue(this.f, t, sink);
        }
        catch (e) {
            sink.error(t, e);
        }
    };
    ContinueWithSink.prototype.continue = function (f, t, sink) {
        return run(sink, this.scheduler, withLocalTime(t, f()));
    };
    ContinueWithSink.prototype.dispose = function () {
        this.active = false;
        return this.disposable.dispose();
    };
    return ContinueWithSink;
}(Pipe));

/** @license MIT License (c) copyright 2010-2017 original author or authors */
var startWith = function (x, stream) {
    return continueWith(function () { return stream; }, now(x));
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
var Filter = /** @class */ (function () {
    function Filter(p, source) {
        this.p = p;
        this.source = source;
    }
    Filter.prototype.run = function (sink, scheduler) {
        return this.source.run(new FilterSink(this.p, sink), scheduler);
    };
    /**
     * Create a filtered source, fusing adjacent filter.filter if possible
     * @param {function(x:*):boolean} p filtering predicate
     * @param {{run:function}} source source to filter
     * @returns {Filter} filtered source
     */
    Filter.create = function (p, source) {
        if (isCanonicalEmpty(source)) {
            return source;
        }
        if (source instanceof Filter) {
            return new Filter(and(source.p, p), source.source);
        }
        return new Filter(p, source);
    };
    return Filter;
}());
var FilterSink = /** @class */ (function (_super) {
    __extends(FilterSink, _super);
    function FilterSink(p, sink) {
        var _this = _super.call(this, sink) || this;
        _this.p = p;
        return _this;
    }
    FilterSink.prototype.event = function (t, x) {
        var p = this.p;
        p(x) && this.sink.event(t, x);
    };
    return FilterSink;
}(Pipe));
var and = function (p, q) { return function (x) { return p(x) && q(x); }; };

/** @license MIT License (c) copyright 2010-2016 original author or authors */
var FilterMap = /** @class */ (function () {
    function FilterMap(p, f, source) {
        this.p = p;
        this.f = f;
        this.source = source;
    }
    FilterMap.prototype.run = function (sink, scheduler) {
        return this.source.run(new FilterMapSink(this.p, this.f, sink), scheduler);
    };
    return FilterMap;
}());
var FilterMapSink = /** @class */ (function (_super) {
    __extends(FilterMapSink, _super);
    function FilterMapSink(p, f, sink) {
        var _this = _super.call(this, sink) || this;
        _this.p = p;
        _this.f = f;
        return _this;
    }
    FilterMapSink.prototype.event = function (t, x) {
        var f = this.f;
        var p = this.p;
        p(x) && this.sink.event(t, f(x));
    };
    return FilterMapSink;
}(Pipe));

/** @license MIT License (c) copyright 2010-2016 original author or authors */
var Map = /** @class */ (function () {
    function Map(f, source) {
        this.f = f;
        this.source = source;
    }
    Map.prototype.run = function (sink, scheduler) {
        return this.source.run(new MapSink(this.f, sink), scheduler);
    };
    /**
     * Create a mapped source, fusing adjacent map.map, filter.map,
     * and filter.map.map if possible
     * @param {function(*):*} f mapping function
     * @param {{run:function}} source source to map
     * @returns {Map|FilterMap} mapped source, possibly fused
     */
    Map.create = function (f, source) {
        if (isCanonicalEmpty(source)) {
            return empty();
        }
        if (source instanceof Map) {
            return new Map(compose(f, source.f), source.source);
        }
        if (source instanceof Filter) {
            return new FilterMap(source.p, f, source.source);
        }
        return new Map(f, source);
    };
    return Map;
}());
var MapSink = /** @class */ (function (_super) {
    __extends(MapSink, _super);
    function MapSink(f, sink) {
        var _this = _super.call(this, sink) || this;
        _this.f = f;
        return _this;
    }
    MapSink.prototype.event = function (t, x) {
        var f = this.f;
        this.sink.event(t, f(x));
    };
    return MapSink;
}(Pipe));

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/**
 * Transform each value in the stream by applying f to each
 * @param f mapping function
 * @param stream stream to map
 * @returns stream containing items transformed by f
 */
var map = function (f, stream) {
    return Map.create(f, stream);
};
/**
* Replace each value in the stream with x
* @param x
* @param stream
* @returns stream containing items replaced with x
*/
var constant = function (x, stream) {
    return map(function () { return x; }, stream);
};
/**
* Perform a side effect for each item in the stream
* @param f side effect to execute for each item. The return value will be discarded.
* @param stream stream to tap
* @returns new stream containing the same items as this stream
*/
var tap = function (f, stream) {
    return new Tap(f, stream);
};
var Tap = /** @class */ (function () {
    function Tap(f, source) {
        this.source = source;
        this.f = f;
    }
    Tap.prototype.run = function (sink, scheduler) {
        return this.source.run(new TapSink(this.f, sink), scheduler);
    };
    return Tap;
}());
var TapSink = /** @class */ (function (_super) {
    __extends(TapSink, _super);
    function TapSink(f, sink) {
        var _this = _super.call(this, sink) || this;
        _this.f = f;
        return _this;
    }
    TapSink.prototype.event = function (t, x) {
        var f = this.f;
        f(x);
        this.sink.event(t, x);
    };
    return TapSink;
}(Pipe));

/** @license MIT License (c) copyright 2010-2016 original author or authors */
var IndexSink = /** @class */ (function (_super) {
    __extends(IndexSink, _super);
    function IndexSink(i, sink) {
        var _this = _super.call(this, sink) || this;
        _this.index = i;
        _this.active = true;
        _this.value = undefined;
        return _this;
    }
    IndexSink.prototype.event = function (t, x) {
        if (!this.active) {
            return;
        }
        this.value = x;
        this.sink.event(t, this);
    };
    IndexSink.prototype.end = function (t) {
        if (!this.active) {
            return;
        }
        this.active = false;
        this.sink.event(t, this);
    };
    return IndexSink;
}(Pipe));

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */
/**
 * TODO: find a better way (without `any`)
 */
function invoke(f, args) {
    /* eslint complexity: [2,7] */
    switch (args.length) {
        case 0: return f();
        case 1: return f(args[0]);
        case 2: return f(args[0], args[1]);
        case 3: return f(args[0], args[1], args[2]);
        case 4: return f(args[0], args[1], args[2], args[3]);
        case 5: return f(args[0], args[1], args[2], args[3], args[4]);
        default:
            return f.apply(undefined, args);
    }
}

/** @license MIT License (c) copyright 2010 original author or authors */
/**
 * Combine latest events from two streams
 * @param f function to combine most recent events
 * @param stream1
 * @param stream2
 * @returns stream containing the result of applying f to the most recent
 *  event of each input stream, whenever a new event arrives on any stream.
 */
var combine = function (f, stream1, stream2) {
    return combineArray(f, [stream1, stream2]);
};
/**
* Combine latest events from all input streams
* @param f function to combine most recent events
* @param streams most recent events
* @returns stream containing the result of applying f to the most recent
*  event of each input stream, whenever a new event arrives on any stream.
*/
var combineArray = function (f, streams) {
    return streams.length === 0 || containsCanonicalEmpty(streams) ? empty()
        : streams.length === 1 ? map(f, streams[0])
            : new Combine(f, streams);
};
var Combine = /** @class */ (function () {
    function Combine(f, sources) {
        this.f = f;
        this.sources = sources;
    }
    Combine.prototype.run = function (sink, scheduler) {
        var l = this.sources.length;
        var disposables = new Array(l);
        var sinks = new Array(l);
        var mergeSink = new CombineSink(disposables, sinks.length, sink, this.f);
        for (var indexSink = void 0, i = 0; i < l; ++i) {
            indexSink = sinks[i] = new IndexSink(i, mergeSink);
            disposables[i] = this.sources[i].run(indexSink, scheduler);
        }
        return disposeAll(disposables);
    };
    return Combine;
}());
var CombineSink = /** @class */ (function (_super) {
    __extends(CombineSink, _super);
    function CombineSink(disposables, length, sink, f) {
        var _this = _super.call(this, sink) || this;
        _this.disposables = disposables;
        _this.f = f;
        _this.awaiting = length;
        _this.values = new Array(length);
        _this.hasValue = new Array(length).fill(false);
        _this.activeCount = length;
        return _this;
    }
    CombineSink.prototype.event = function (t, indexedValue) {
        if (!indexedValue.active) {
            this.dispose(t, indexedValue.index);
            return;
        }
        var i = indexedValue.index;
        var awaiting = this.updateReady(i);
        this.values[i] = indexedValue.value;
        if (awaiting === 0) {
            this.sink.event(t, invoke(this.f, this.values));
        }
    };
    CombineSink.prototype.updateReady = function (index) {
        if (this.awaiting > 0) {
            if (!this.hasValue[index]) {
                this.hasValue[index] = true;
                this.awaiting -= 1;
            }
        }
        return this.awaiting;
    };
    CombineSink.prototype.dispose = function (t, index) {
        tryDispose$1(t, this.disposables[index], this.sink);
        if (--this.activeCount === 0) {
            this.sink.end(t);
        }
    };
    return CombineSink;
}(Pipe));

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/**
 * Assume fs is a stream containing functions, and apply the latest function
 * in fs to the latest value in xs.
 * fs:         --f---------g--------h------>
 * xs:         -a-------b-------c-------d-->
 * ap(fs, xs): --fa-----fb-gb---gc--hc--hd->
 * @param {Stream} fs stream of functions to apply to the latest x
 * @param {Stream} xs stream of values to which to apply all the latest f
 * @returns {Stream} stream containing all the applications of fs to xs
 */
function ap(fs, xs) {
    return combine(apply, fs, xs);
}

/** @license MIT License (c) copyright 2010 original author or authors */
var mergeConcurrently = function (concurrency, stream) {
    return mergeMapConcurrently(id, concurrency, stream);
};
var mergeMapConcurrently = function (f, concurrency, stream) {
    return isCanonicalEmpty(stream) ? empty()
        : new MergeConcurrently(f, concurrency, stream);
};
var MergeConcurrently = /** @class */ (function () {
    function MergeConcurrently(f, concurrency, source) {
        this.f = f;
        this.concurrency = concurrency;
        this.source = source;
    }
    MergeConcurrently.prototype.run = function (sink, scheduler) {
        return new Outer(this.f, this.concurrency, this.source, sink, scheduler);
    };
    return MergeConcurrently;
}());
var isNonEmpty = function (array) { return array.length > 0; };
var Outer = /** @class */ (function () {
    function Outer(f, concurrency, source, sink, scheduler) {
        this.f = f;
        this.concurrency = concurrency;
        this.sink = sink;
        this.scheduler = scheduler;
        this.pending = [];
        this.current = [];
        this.disposable = disposeOnce(source.run(this, scheduler));
        this.active = true;
    }
    Outer.prototype.event = function (t, x) {
        this.addInner(t, x);
    };
    Outer.prototype.addInner = function (t, x) {
        if (this.current.length < this.concurrency) {
            this.startInner(t, x);
        }
        else {
            this.pending.push(x);
        }
    };
    Outer.prototype.startInner = function (t, x) {
        try {
            this.initInner(t, x);
        }
        catch (e) {
            this.error(t, e);
        }
    };
    Outer.prototype.initInner = function (t, x) {
        var innerSink = new Inner(t, this, this.sink);
        innerSink.disposable = mapAndRun(this.f, t, x, innerSink, this.scheduler);
        this.current.push(innerSink);
    };
    Outer.prototype.end = function (t) {
        this.active = false;
        tryDispose$1(t, this.disposable, this.sink);
        this.checkEnd(t);
    };
    Outer.prototype.error = function (t, e) {
        this.active = false;
        this.sink.error(t, e);
    };
    Outer.prototype.dispose = function () {
        this.active = false;
        this.pending.length = 0;
        this.disposable.dispose();
        disposeAll(this.current).dispose();
    };
    Outer.prototype.endInner = function (t, inner) {
        var i = this.current.indexOf(inner);
        if (i >= 0) {
            this.current.splice(i, 1);
        }
        tryDispose$1(t, inner, this);
        var pending = this.pending;
        if (isNonEmpty(pending)) {
            this.startInner(t, pending.shift());
        }
        else {
            this.checkEnd(t);
        }
    };
    Outer.prototype.checkEnd = function (t) {
        if (!this.active && this.current.length === 0) {
            this.sink.end(t);
        }
    };
    return Outer;
}());
var mapAndRun = function (f, t, x, sink, scheduler) {
    return f(x).run(sink, schedulerRelativeTo(t, scheduler));
};
var Inner = /** @class */ (function () {
    function Inner(time, outer, sink) {
        this.time = time;
        this.outer = outer;
        this.sink = sink;
        this.disposable = disposeNone();
    }
    Inner.prototype.event = function (t, x) {
        this.sink.event(t + this.time, x);
    };
    Inner.prototype.end = function (t) {
        this.outer.endInner(t + this.time, this);
    };
    Inner.prototype.error = function (t, e) {
        this.outer.error(t + this.time, e);
    };
    Inner.prototype.dispose = function () {
        return this.disposable.dispose();
    };
    return Inner;
}());

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/**
 * Map each value in the stream to a new stream, and merge it into the
 * returned outer stream. Event arrival times are preserved.
 * @param f chaining function, must return a Stream
 * @param stream
 * @returns new stream containing all events from each stream returned by f
 */
var chain = function (f, stream) { return mergeMapConcurrently(f, Infinity, stream); };
/**
 * Monadic join. Flatten a Stream<Stream<X>> to Stream<X> by merging inner
 * streams to the outer. Event arrival times are preserved.
 * @param stream stream of streams
 * @returns new stream containing all events of all inner streams
 */
var join = function (stream) { return mergeConcurrently(Infinity, stream); };

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/**
 * Map each value in stream to a new stream, and concatenate them all
 * stream:              -a---b---cX
 * f(a):                 1-1-1-1X
 * f(b):                        -2-2-2-2X
 * f(c):                                -3-3-3-3X
 * stream.concatMap(f): -1-1-1-1-2-2-2-2-3-3-3-3X
 * @param f function to map each value to a stream
 * @param stream
 * @returns new stream containing all events from each stream returned by f
 */
var concatMap = function (f, stream) {
    return mergeMapConcurrently(f, 1, stream);
};

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/**
 * @returns stream containing events from two streams in time order.
 * If two events are simultaneous they will be merged in arbitrary order.
 */
function merge(stream1, stream2) {
    return mergeArray([stream1, stream2]);
}
/**
 * @param streams array of stream to merge
 * @returns stream containing events from all input observables
 * in time order.  If two events are simultaneous they will be merged in
 * arbitrary order.
 */
var mergeArray = function (streams) {
    return mergeStreams(withoutCanonicalEmpty(streams));
};
/**
 * This implements fusion/flattening for merge.  It will
 * fuse adjacent merge operations.  For example:
 * - a.merge(b).merge(c) effectively becomes merge(a, b, c)
 * - merge(a, merge(b, c)) effectively becomes merge(a, b, c)
 * It does this by concatenating the sources arrays of
 * any nested Merge sources, in effect "flattening" nested
 * merge operations into a single merge.
 * TODO: use {@link MergeArray}
 */
var mergeStreams = function (streams) {
    return streams.length === 0 ? empty()
        : streams.length === 1 ? streams[0]
            : new Merge(reduce(appendSources, [], streams));
};
var withoutCanonicalEmpty = function (streams) {
    return streams.filter(isNotCanonicalEmpty);
};
var isNotCanonicalEmpty = function (stream) {
    return !isCanonicalEmpty(stream);
};
var appendSources = function (sources, stream) {
    return sources.concat(stream instanceof Merge ? stream.sources : stream);
};
var Merge = /** @class */ (function () {
    function Merge(sources) {
        this.sources = sources;
    }
    Merge.prototype.run = function (sink, scheduler) {
        var l = this.sources.length;
        var disposables = new Array(l);
        var sinks = new Array(l);
        var mergeSink = new MergeSink(disposables, sinks, sink);
        for (var indexSink = void 0, i = 0; i < l; ++i) {
            indexSink = sinks[i] = new IndexSink(i, mergeSink);
            disposables[i] = this.sources[i].run(indexSink, scheduler);
        }
        return disposeAll(disposables);
    };
    return Merge;
}());
var MergeSink = /** @class */ (function (_super) {
    __extends(MergeSink, _super);
    function MergeSink(disposables, sinks, sink) {
        var _this = _super.call(this, sink) || this;
        _this.disposables = disposables;
        _this.activeCount = sinks.length;
        return _this;
    }
    MergeSink.prototype.event = function (t, indexValue) {
        if (!indexValue.active) {
            this.dispose(t, indexValue.index);
            return;
        }
        this.sink.event(t, indexValue.value);
    };
    MergeSink.prototype.dispose = function (t, index) {
        tryDispose$1(t, this.disposables[index], this.sink);
        if (--this.activeCount === 0) {
            this.sink.end(t);
        }
    };
    return MergeSink;
}(Pipe));

/** @license MIT License (c) copyright 2010 original author or authors */
var sample = function (values, sampler) {
    return snapshot(function (x) { return x; }, values, sampler);
};
var snapshot = function (f, values, sampler) {
    return isCanonicalEmpty(sampler) || isCanonicalEmpty(values)
        ? empty()
        : new Snapshot(f, values, sampler);
};
var Snapshot = /** @class */ (function () {
    function Snapshot(f, values, sampler) {
        this.f = f;
        this.values = values;
        this.sampler = sampler;
    }
    Snapshot.prototype.run = function (sink, scheduler) {
        var sampleSink = new SnapshotSink(this.f, sink);
        var valuesDisposable = this.values.run(sampleSink.latest, scheduler);
        var samplerDisposable = this.sampler.run(sampleSink, scheduler);
        return disposeBoth(samplerDisposable, valuesDisposable);
    };
    return Snapshot;
}());
var SnapshotSink = /** @class */ (function (_super) {
    __extends(SnapshotSink, _super);
    function SnapshotSink(f, sink) {
        var _this = _super.call(this, sink) || this;
        _this.f = f;
        _this.latest = new LatestValueSink(_this);
        return _this;
    }
    SnapshotSink.prototype.event = function (t, x) {
        if (this.latest.hasValue) {
            var f = this.f;
            // TODO: value should be boxed to avoid ! bang
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.sink.event(t, f(this.latest.value, x));
        }
    };
    return SnapshotSink;
}(Pipe));
var LatestValueSink = /** @class */ (function (_super) {
    __extends(LatestValueSink, _super);
    function LatestValueSink(sink) {
        var _this = _super.call(this, sink) || this;
        _this.hasValue = false;
        return _this;
    }
    LatestValueSink.prototype.event = function (_t, x) {
        this.value = x;
        this.hasValue = true;
    };
    LatestValueSink.prototype.end = function () { };
    return LatestValueSink;
}(Pipe));

/** @license MIT License (c) copyright 2010 original author or authors */
// Construct a constrained bounds
var boundsFrom = function (unsafeMin, unsafeMax) {
    var min = Math.max(0, unsafeMin);
    var max = Math.max(min, unsafeMax);
    return { min: min, max: max };
};
// Combine 2 bounds by narrowing min and max
var mergeBounds = function (b1, b2) {
    return boundsFrom(b1.min + b2.min, Math.min(b1.max, b1.min + b2.max));
};
// Nil bounds excludes all slice indices
var isNilBounds = function (b) {
    return b.min >= b.max;
};
// Infinite bounds includes all slice indices
var isInfiniteBounds = function (b) {
    return b.min <= 0 && b.max === Infinity;
};

// TODO: split into smaller files
/**
 * @param n
 * @param stream
 * @returns new stream containing only up to the first n items from stream
 */
var take = function (n, stream) {
    return slice(0, n, stream);
};
/**
 * @param n
 * @param stream
 * @returns new stream with the first n items removed
 */
var skip = function (n, stream) {
    return slice(n, Infinity, stream);
};
/**
 * Slice a stream by index. Negative start/end indexes are not supported
 * @param start
 * @param end
 * @param stream
 * @returns stream containing items where start <= index < end
 */
var slice = function (start, end, stream) {
    return sliceBounds(boundsFrom(start, end), stream);
};
var sliceBounds = function (bounds, stream) {
    return isSliceEmpty(bounds, stream) ? empty()
        : stream instanceof Map ? commuteMapSlice(bounds, stream)
            : stream instanceof Slice ? fuseSlice(bounds, stream)
                : createSlice(bounds, stream);
};
var isSliceEmpty = function (bounds, stream) {
    return isCanonicalEmpty(stream) || isNilBounds(bounds);
};
var createSlice = function (bounds, stream) {
    return isInfiniteBounds(bounds) ? stream : new Slice(bounds, stream);
};
var commuteMapSlice = function (bounds, mapStream) {
    return Map.create(mapStream.f, sliceBounds(bounds, mapStream.source));
};
var fuseSlice = function (bounds, sliceStream) {
    return sliceBounds(mergeBounds(sliceStream.bounds, bounds), sliceStream.source);
};
var Slice = /** @class */ (function () {
    function Slice(bounds, source) {
        this.source = source;
        this.bounds = bounds;
    }
    Slice.prototype.run = function (sink, scheduler) {
        var disposable = new SettableDisposable();
        var sliceSink = new SliceSink(this.bounds.min, this.bounds.max - this.bounds.min, sink, disposable);
        disposable.setDisposable(this.source.run(sliceSink, scheduler));
        return disposable;
    };
    return Slice;
}());
var SliceSink = /** @class */ (function (_super) {
    __extends(SliceSink, _super);
    function SliceSink(skip, take, sink, disposable) {
        var _this = _super.call(this, sink) || this;
        _this.skip = skip;
        _this.take = take;
        _this.disposable = disposable;
        return _this;
    }
    SliceSink.prototype.event = function (t, x) {
        /* eslint complexity: [1, 4] */
        if (this.skip > 0) {
            this.skip -= 1;
            return;
        }
        if (this.take === 0) {
            return;
        }
        this.take -= 1;
        this.sink.event(t, x);
        if (this.take === 0) {
            this.disposable.dispose();
            this.sink.end(t);
        }
    };
    return SliceSink;
}(Pipe));
var takeWhile = function (p, stream) {
    return isCanonicalEmpty(stream) ? empty()
        : new TakeWhile(p, stream);
};
var TakeWhile = /** @class */ (function () {
    function TakeWhile(p, source) {
        this.p = p;
        this.source = source;
    }
    TakeWhile.prototype.run = function (sink, scheduler) {
        var disposable = new SettableDisposable();
        var takeWhileSink = new TakeWhileSink(this.p, sink, disposable);
        disposable.setDisposable(this.source.run(takeWhileSink, scheduler));
        return disposable;
    };
    return TakeWhile;
}());
var TakeWhileSink = /** @class */ (function (_super) {
    __extends(TakeWhileSink, _super);
    function TakeWhileSink(p, sink, disposable) {
        var _this = _super.call(this, sink) || this;
        _this.p = p;
        _this.active = true;
        _this.disposable = disposable;
        return _this;
    }
    TakeWhileSink.prototype.event = function (t, x) {
        if (!this.active) {
            return;
        }
        var p = this.p;
        this.active = p(x);
        if (this.active) {
            this.sink.event(t, x);
        }
        else {
            this.disposable.dispose();
            this.sink.end(t);
        }
    };
    return TakeWhileSink;
}(Pipe));
var skipWhile = function (p, stream) {
    return isCanonicalEmpty(stream) ? empty()
        : new SkipWhile(p, stream);
};
var SkipWhile = /** @class */ (function () {
    function SkipWhile(p, source) {
        this.p = p;
        this.source = source;
    }
    SkipWhile.prototype.run = function (sink, scheduler) {
        return this.source.run(new SkipWhileSink(this.p, sink), scheduler);
    };
    return SkipWhile;
}());
var SkipWhileSink = /** @class */ (function (_super) {
    __extends(SkipWhileSink, _super);
    function SkipWhileSink(p, sink) {
        var _this = _super.call(this, sink) || this;
        _this.p = p;
        _this.skipping = true;
        return _this;
    }
    SkipWhileSink.prototype.event = function (t, x) {
        if (this.skipping) {
            var p = this.p;
            this.skipping = p(x);
            if (this.skipping) {
                return;
            }
        }
        this.sink.event(t, x);
    };
    return SkipWhileSink;
}(Pipe));
var skipAfter = function (p, stream) {
    return isCanonicalEmpty(stream) ? empty()
        : new SkipAfter(p, stream);
};
var SkipAfter = /** @class */ (function () {
    function SkipAfter(p, source) {
        this.p = p;
        this.source = source;
    }
    SkipAfter.prototype.run = function (sink, scheduler) {
        return this.source.run(new SkipAfterSink(this.p, sink), scheduler);
    };
    return SkipAfter;
}());
var SkipAfterSink = /** @class */ (function (_super) {
    __extends(SkipAfterSink, _super);
    function SkipAfterSink(p, sink) {
        var _this = _super.call(this, sink) || this;
        _this.p = p;
        _this.skipping = false;
        return _this;
    }
    SkipAfterSink.prototype.event = function (t, x) {
        if (this.skipping) {
            return;
        }
        var p = this.p;
        this.skipping = p(x);
        this.sink.event(t, x);
        if (this.skipping) {
            this.sink.end(t);
        }
    };
    return SkipAfterSink;
}(Pipe));

/** @license MIT License (c) copyright 2017 original author or authors */
var withItems = function (items, stream) {
    return zipItems(keepLeft, items, stream);
};
var zipItems = function (f, items, stream) {
    return isCanonicalEmpty(stream) || items.length === 0
        ? empty()
        : new ZipItems(f, items, take(items.length, stream));
};
var keepLeft = function (a) { return a; };
var ZipItems = /** @class */ (function () {
    function ZipItems(f, items, source) {
        this.f = f;
        this.items = items;
        this.source = source;
    }
    ZipItems.prototype.run = function (sink, scheduler) {
        return this.source.run(new ZipItemsSink(this.f, this.items, sink), scheduler);
    };
    return ZipItems;
}());
var ZipItemsSink = /** @class */ (function (_super) {
    __extends(ZipItemsSink, _super);
    function ZipItemsSink(f, items, sink) {
        var _this = _super.call(this, sink) || this;
        _this.f = f;
        _this.items = items;
        _this.index = 0;
        return _this;
    }
    ZipItemsSink.prototype.event = function (t, b) {
        var f = this.f;
        this.sink.event(t, f(this.items[this.index], b));
        this.index += 1;
    };
    return ZipItemsSink;
}(Pipe));

// Copied and modified from https://github.com/invertase/denque
// MIT License
// These constants were extracted directly from denque's shift()
// It's not clear exactly why the authors chose these particular
// values, but given denque's stated goals, it seems likely that
// they were chosen for speed/memory reasons.
// Max value of _head at which Queue is willing to shink
// its internal array
var HEAD_MAX_SHRINK = 2;
// Min value of _tail at which Queue is willing to shink
// its internal array
var TAIL_MIN_SHRINK = 10000;
var Queue = /** @class */ (function () {
    function Queue() {
        this.head = 0;
        this.tail = 0;
        this.capacityMask = 0x3;
        this.list = new Array(4);
    }
    Queue.prototype.push = function (x) {
        var tail = this.tail;
        this.list[tail] = x;
        this.tail = (tail + 1) & this.capacityMask;
        if (this.tail === this.head) {
            this.growArray();
        }
        if (this.head < this.tail) {
            return this.tail - this.head;
        }
        else {
            return this.capacityMask + 1 - (this.head - this.tail);
        }
    };
    Queue.prototype.shift = function () {
        var head = this.head;
        if (head === this.tail) {
            return undefined;
        }
        var x = this.list[head];
        this.list[head] = undefined;
        this.head = (head + 1) & this.capacityMask;
        if (head < HEAD_MAX_SHRINK &&
            this.tail > TAIL_MIN_SHRINK &&
            this.tail <= this.list.length >>> 2) {
            this.shrinkArray();
        }
        return x;
    };
    Queue.prototype.isEmpty = function () {
        return this.head === this.tail;
    };
    Queue.prototype.length = function () {
        if (this.head === this.tail) {
            return 0;
        }
        else if (this.head < this.tail) {
            return this.tail - this.head;
        }
        else {
            return this.capacityMask + 1 - (this.head - this.tail);
        }
    };
    Queue.prototype.growArray = function () {
        if (this.head) {
            // copy existing data, head to end, then beginning to tail.
            this.list = this.copyArray();
            this.head = 0;
        }
        // head is at 0 and array is now full, safe to extend
        this.tail = this.list.length;
        this.list.length *= 2;
        this.capacityMask = (this.capacityMask << 1) | 1;
    };
    Queue.prototype.shrinkArray = function () {
        this.list.length >>>= 1;
        this.capacityMask >>>= 1;
    };
    Queue.prototype.copyArray = function () {
        var newArray = [];
        var list = this.list;
        var len = list.length;
        var i;
        for (i = this.head; i < len; i++) {
            newArray.push(list[i]);
        }
        for (i = 0; i < this.tail; i++) {
            newArray.push(list[i]);
        }
        return newArray;
    };
    return Queue;
}());

/** @license MIT License (c) copyright 2010 original author or authors */
/**
 * Combine two streams pairwise by index by applying f to values at corresponding
 * indices.  The returned stream ends when either of the input streams ends.
 * @param {function} f function to combine values
 * @returns {Stream} new stream with items at corresponding indices combined
 *  using f
 */
function zip(f, stream1, stream2) {
    return zipArray(f, [stream1, stream2]);
}
/**
* Combine streams pairwise (or tuple-wise) by index by applying f to values
* at corresponding indices.  The returned stream ends when any of the input
* streams ends.
* @param {function} f function to combine values
* @param {[Stream]} streams streams to zip using f
* @returns {Stream} new stream with items at corresponding indices combined
*  using f
*/
var zipArray = function (f, streams) {
    return streams.length === 0 || containsCanonicalEmpty(streams) ? empty()
        : streams.length === 1 ? map(f, streams[0])
            : new Zip(f, streams);
};
var Zip = /** @class */ (function () {
    function Zip(f, sources) {
        this.f = f;
        this.sources = sources;
    }
    Zip.prototype.run = function (sink, scheduler) {
        var l = this.sources.length;
        var disposables = new Array(l);
        var sinks = new Array(l);
        var buffers = new Array(l);
        var zipSink = new ZipSink(this.f, buffers, sinks, sink);
        for (var indexSink = void 0, i = 0; i < l; ++i) {
            buffers[i] = new Queue();
            indexSink = sinks[i] = new IndexSink(i, zipSink);
            disposables[i] = this.sources[i].run(indexSink, scheduler);
        }
        return disposeAll(disposables);
    };
    return Zip;
}());
var ZipSink = /** @class */ (function (_super) {
    __extends(ZipSink, _super);
    function ZipSink(f, buffers, sinks, sink) {
        var _this = _super.call(this, sink) || this;
        _this.f = f;
        _this.sinks = sinks;
        _this.buffers = buffers;
        return _this;
    }
    ZipSink.prototype.event = function (t, indexedValue) {
        /* eslint complexity: [1, 5] */
        if (!indexedValue.active) {
            this.dispose(t, indexedValue.index);
            return;
        }
        var buffers = this.buffers;
        var buffer = buffers[indexedValue.index];
        buffer.push(indexedValue.value);
        if (buffer.length() === 1) {
            if (!ready(buffers)) {
                return;
            }
            emitZipped(this.f, t, buffers, this.sink);
            if (ended(this.buffers, this.sinks)) {
                this.sink.end(t);
            }
        }
    };
    ZipSink.prototype.dispose = function (t, index) {
        var buffer = this.buffers[index];
        if (buffer.isEmpty()) {
            this.sink.end(t);
        }
    };
    return ZipSink;
}(Pipe));
var emitZipped = function (f, t, buffers, sink) {
    return sink.event(t, invoke(f, map$2(head, buffers)));
};
var head = function (buffer) { return buffer.shift(); };
function ended(buffers, sinks) {
    for (var i = 0, l = buffers.length; i < l; ++i) {
        if (buffers[i].isEmpty() && !sinks[i].active) {
            return true;
        }
    }
    return false;
}
function ready(buffers) {
    for (var i = 0, l = buffers.length; i < l; ++i) {
        if (buffers[i].isEmpty()) {
            return false;
        }
    }
    return true;
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/**
 * Given a stream of streams, return a new stream that adopts the behavior
 * of the most recent inner stream.
 * @param stream of streams on which to switch
 * @returns switching stream
 */
var switchLatest = function (stream) {
    return isCanonicalEmpty(stream)
        ? empty()
        : new Switch(stream);
};
var Switch = /** @class */ (function () {
    function Switch(source) {
        this.source = source;
    }
    Switch.prototype.run = function (sink, scheduler) {
        var switchSink = new SwitchSink(sink, scheduler);
        return disposeBoth(switchSink, this.source.run(switchSink, scheduler));
    };
    return Switch;
}());
var SwitchSink = /** @class */ (function () {
    function SwitchSink(sink, scheduler) {
        this.sink = sink;
        this.scheduler = scheduler;
        this.current = null;
        this.ended = false;
    }
    SwitchSink.prototype.event = function (t, stream) {
        this.disposeCurrent(t);
        this.current = new Segment(stream, t, Infinity, this, this.sink, this.scheduler);
    };
    SwitchSink.prototype.end = function (t) {
        this.ended = true;
        this.checkEnd(t);
    };
    SwitchSink.prototype.error = function (t, e) {
        this.ended = true;
        this.sink.error(t, e);
    };
    SwitchSink.prototype.dispose = function () {
        return this.disposeCurrent(currentTime(this.scheduler));
    };
    SwitchSink.prototype.disposeCurrent = function (t) {
        if (this.current !== null) {
            return this.current.dispose(t);
        }
    };
    SwitchSink.prototype.disposeInner = function (t, inner) {
        inner.dispose(t);
        if (inner === this.current) {
            this.current = null;
        }
    };
    SwitchSink.prototype.checkEnd = function (t) {
        if (this.ended && this.current === null) {
            this.sink.end(t);
        }
    };
    SwitchSink.prototype.endInner = function (t, inner) {
        this.disposeInner(t, inner);
        this.checkEnd(t);
    };
    SwitchSink.prototype.errorInner = function (t, e, inner) {
        this.disposeInner(t, inner);
        this.sink.error(t, e);
    };
    return SwitchSink;
}());
var Segment = /** @class */ (function () {
    function Segment(source, min, max, outer, sink, scheduler) {
        this.min = min;
        this.max = max;
        this.outer = outer;
        this.sink = sink;
        this.disposable = source.run(this, schedulerRelativeTo(min, scheduler));
    }
    Segment.prototype.event = function (t, x) {
        var time = Math.max(0, t + this.min);
        if (time < this.max) {
            this.sink.event(time, x);
        }
    };
    Segment.prototype.end = function (t) {
        this.outer.endInner(t + this.min, this);
    };
    Segment.prototype.error = function (t, e) {
        this.outer.errorInner(t + this.min, e, this);
    };
    Segment.prototype.dispose = function (t) {
        tryDispose$1(t, this.disposable, this.sink);
    };
    return Segment;
}());

/** @license MIT License (c) copyright 2010-2016 original author or authors */
function filter(p, stream) {
    return Filter.create(p, stream);
}
/**
 * Skip repeated events, using === to detect duplicates
 * @param stream stream from which to omit repeated events
 * @returns stream without repeated events
 */
var skipRepeats = function (stream) {
    return skipRepeatsWith(same, stream);
};
/**
 * Skip repeated events using the provided equals function to detect duplicates
 * @param equals optional function to compare items
 * @param stream stream from which to omit repeated events
 * @returns stream without repeated events
 */
var skipRepeatsWith = function (equals, stream) {
    return isCanonicalEmpty(stream) ? empty()
        : new SkipRepeats(equals, stream);
};
var SkipRepeats = /** @class */ (function () {
    function SkipRepeats(equals, source) {
        this.equals = equals;
        this.source = source;
    }
    SkipRepeats.prototype.run = function (sink, scheduler) {
        return this.source.run(new SkipRepeatsSink(this.equals, sink), scheduler);
    };
    return SkipRepeats;
}());
var SkipRepeatsSink = /** @class */ (function (_super) {
    __extends(SkipRepeatsSink, _super);
    function SkipRepeatsSink(equals, sink) {
        var _this = _super.call(this, sink) || this;
        _this.equals = equals;
        _this.value = undefined;
        _this.init = true;
        return _this;
    }
    SkipRepeatsSink.prototype.event = function (t, x) {
        if (this.init) {
            this.init = false;
            this.value = x;
            this.sink.event(t, x);
            // TODO: value should be boxed to avoid ! bang
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        }
        else if (!this.equals(this.value, x)) {
            this.value = x;
            this.sink.event(t, x);
        }
    };
    return SkipRepeatsSink;
}(Pipe));
function same(a, b) {
    return a === b;
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
var until = function (signal, stream) {
    return new Until(signal, stream);
};
var since = function (signal, stream) {
    return new Since(signal, stream);
};
var during = function (timeWindow, stream) {
    return until(join(timeWindow), since(timeWindow, stream));
};
var Until = /** @class */ (function () {
    function Until(maxSignal, source) {
        this.maxSignal = maxSignal;
        this.source = source;
    }
    Until.prototype.run = function (sink, scheduler) {
        var disposable = new SettableDisposable();
        var d1 = this.source.run(sink, scheduler);
        var d2 = this.maxSignal.run(new UntilSink(sink, disposable), scheduler);
        disposable.setDisposable(disposeBoth(d1, d2));
        return disposable;
    };
    return Until;
}());
var Since = /** @class */ (function () {
    function Since(minSignal, source) {
        this.minSignal = minSignal;
        this.source = source;
    }
    Since.prototype.run = function (sink, scheduler) {
        var min = new LowerBoundSink(this.minSignal, sink, scheduler);
        var d = this.source.run(new SinceSink(min, sink), scheduler);
        return disposeBoth(min, d);
    };
    return Since;
}());
var SinceSink = /** @class */ (function (_super) {
    __extends(SinceSink, _super);
    function SinceSink(min, sink) {
        var _this = _super.call(this, sink) || this;
        _this.min = min;
        return _this;
    }
    SinceSink.prototype.event = function (t, x) {
        if (this.min.allow) {
            this.sink.event(t, x);
        }
    };
    return SinceSink;
}(Pipe));
var LowerBoundSink = /** @class */ (function (_super) {
    __extends(LowerBoundSink, _super);
    function LowerBoundSink(signal, sink, scheduler) {
        var _this = _super.call(this, sink) || this;
        _this.allow = false;
        _this.disposable = signal.run(_this, scheduler);
        return _this;
    }
    LowerBoundSink.prototype.event = function () {
        this.allow = true;
        this.dispose();
    };
    LowerBoundSink.prototype.end = function () { };
    LowerBoundSink.prototype.dispose = function () {
        this.disposable.dispose();
    };
    return LowerBoundSink;
}(Pipe));
var UntilSink = /** @class */ (function (_super) {
    __extends(UntilSink, _super);
    function UntilSink(sink, disposable) {
        var _this = _super.call(this, sink) || this;
        _this.disposable = disposable;
        return _this;
    }
    UntilSink.prototype.event = function (t) {
        this.disposable.dispose();
        this.sink.end(t);
    };
    UntilSink.prototype.end = function () { };
    return UntilSink;
}(Pipe));

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/**
 * @param delayTime milliseconds to delay each item
 * @param stream
 * @returns new stream containing the same items, but delayed by ms
 */
var delay = function (delayTime, stream) {
    return delayTime <= 0 ? stream : new Delay(delayTime, stream);
};
var Delay = /** @class */ (function () {
    function Delay(dt, source) {
        this.dt = dt;
        this.source = source;
    }
    Delay.prototype.run = function (sink, scheduler) {
        var delaySink = new DelaySink(this.dt, sink, scheduler);
        return disposeBoth(delaySink, this.source.run(delaySink, scheduler));
    };
    return Delay;
}());
var DelaySink = /** @class */ (function (_super) {
    __extends(DelaySink, _super);
    function DelaySink(dt, sink, scheduler) {
        var _this = _super.call(this, sink) || this;
        _this.dt = dt;
        _this.scheduler = scheduler;
        _this.tasks = [];
        return _this;
    }
    DelaySink.prototype.dispose = function () {
        this.tasks.forEach(cancelTask);
    };
    DelaySink.prototype.event = function (_t, x) {
        this.tasks.push(delay$2(this.dt, propagateEventTask(x, this.sink), this.scheduler));
    };
    DelaySink.prototype.end = function () {
        this.tasks.push(delay$2(this.dt, propagateEndTask(this.sink), this.scheduler));
    };
    return DelaySink;
}(Pipe));

/** @license MIT License (c) copyright 2010-2017 original author or authors */
/**
 * Limit the rate of events by suppressing events that occur too often
 * @param period time to suppress events
 * @param stream
 */
var throttle = function (period, stream) {
    return isCanonicalEmpty(stream) ? empty()
        : stream instanceof Map ? commuteMapThrottle(period, stream)
            : stream instanceof Throttle ? fuseThrottle(period, stream)
                : new Throttle(period, stream);
};
var commuteMapThrottle = function (period, mapStream) {
    return Map.create(mapStream.f, throttle(period, mapStream.source));
};
var fuseThrottle = function (period, throttleStream) {
    return new Throttle(Math.max(period, throttleStream.period), throttleStream.source);
};
var Throttle = /** @class */ (function () {
    function Throttle(period, source) {
        this.period = period;
        this.source = source;
    }
    Throttle.prototype.run = function (sink, scheduler) {
        return this.source.run(new ThrottleSink(this.period, sink), scheduler);
    };
    return Throttle;
}());
var ThrottleSink = /** @class */ (function (_super) {
    __extends(ThrottleSink, _super);
    function ThrottleSink(period, sink) {
        var _this = _super.call(this, sink) || this;
        _this.time = 0;
        _this.period = period;
        return _this;
    }
    ThrottleSink.prototype.event = function (t, x) {
        if (t >= this.time) {
            this.time = t + this.period;
            this.sink.event(t, x);
        }
    };
    return ThrottleSink;
}(Pipe));
/**
 * Wait for a burst of events to subside and emit only the last event in the burst
 * @param period events occuring more frequently than this will be suppressed
 * @param stream stream to debounce
 * @returns new debounced stream
 */
var debounce = function (period, stream) {
    return isCanonicalEmpty(stream) ? empty()
        : new Debounce(period, stream);
};
var Debounce = /** @class */ (function () {
    function Debounce(dt, source) {
        this.dt = dt;
        this.source = source;
    }
    Debounce.prototype.run = function (sink, scheduler) {
        return new DebounceSink(this.dt, this.source, sink, scheduler);
    };
    return Debounce;
}());
var DebounceSink = /** @class */ (function () {
    function DebounceSink(dt, source, sink, scheduler) {
        this.dt = dt;
        this.sink = sink;
        this.scheduler = scheduler;
        this.timer = null;
        this.disposable = source.run(this, scheduler);
    }
    DebounceSink.prototype.event = function (_t, x) {
        this.clearTimer();
        this.value = x;
        this.timer = delay$2(this.dt, new DebounceTask(this, x), this.scheduler);
    };
    DebounceSink.prototype.handleEventFromTask = function (t, x) {
        this.clearTimer();
        this.sink.event(t, x);
    };
    DebounceSink.prototype.end = function (t) {
        if (this.clearTimer()) {
            // TODO: value should be boxed to avoid ! bang
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.sink.event(t, this.value);
            this.value = undefined;
        }
        this.sink.end(t);
    };
    DebounceSink.prototype.error = function (t, x) {
        this.clearTimer();
        this.sink.error(t, x);
    };
    DebounceSink.prototype.dispose = function () {
        this.clearTimer();
        this.disposable.dispose();
    };
    DebounceSink.prototype.clearTimer = function () {
        if (this.timer === null) {
            return false;
        }
        this.timer.dispose();
        this.timer = null;
        return true;
    };
    return DebounceSink;
}());
var DebounceTask = /** @class */ (function () {
    function DebounceTask(sink, value) {
        this.sink = sink;
        this.value = value;
    }
    DebounceTask.prototype.run = function (t) {
        this.sink.handleEventFromTask(t, this.value);
    };
    DebounceTask.prototype.error = function (t, e) {
        this.sink.error(t, e);
    };
    DebounceTask.prototype.dispose = function () { };
    return DebounceTask;
}());

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/**
 * Turn a Stream<Promise<T>> into Stream<T> by awaiting each promise.
 * Event order is preserved. The stream will fail if any promise rejects.
 */
var awaitPromises = function (stream) {
    return isCanonicalEmpty(stream) ? empty() : new Await(stream);
};
/**
 * Create a stream containing only the promise's fulfillment
 * value at the time it fulfills.
 * @param promise
 * @return stream containing promise's fulfillment value.
 *  If the promise rejects, the stream will error
 */
var fromPromise = function (promise) { return awaitPromises(now(promise)); };
var Await = /** @class */ (function () {
    function Await(source) {
        this.source = source;
    }
    Await.prototype.run = function (sink, scheduler) {
        return this.source.run(new AwaitSink(sink, scheduler), scheduler);
    };
    return Await;
}());
var AwaitSink = /** @class */ (function () {
    function AwaitSink(sink, scheduler) {
        var _this = this;
        // Pre-create closures, to avoid creating them per event
        this.eventBound = function (x) { return _this.sink.event(currentTime(_this.scheduler), x); };
        this.endBound = function () { return _this.sink.end(currentTime(_this.scheduler)); };
        this.errorBound = function (e) { return _this.sink.error(currentTime(_this.scheduler), e); };
        this.sink = sink;
        this.scheduler = scheduler;
        this.queue = Promise.resolve();
    }
    AwaitSink.prototype.event = function (_t, promise) {
        var _this = this;
        this.queue = this.queue.then(function () { return _this.handlePromise(promise); })
            .catch(this.errorBound);
    };
    AwaitSink.prototype.end = function () {
        this.queue = this.queue.then(this.endBound)
            .catch(this.errorBound);
    };
    AwaitSink.prototype.error = function (_t, e) {
        var _this = this;
        // Don't resolve error values, propagate directly
        this.queue = this.queue.then(function () { return _this.errorBound(e); })
            .catch(fatalError);
    };
    AwaitSink.prototype.handlePromise = function (promise) {
        return promise.then(this.eventBound);
    };
    return AwaitSink;
}());

var SafeSink = /** @class */ (function () {
    function SafeSink(sink) {
        this.sink = sink;
        this.active = true;
    }
    SafeSink.prototype.event = function (t, x) {
        if (!this.active) {
            return;
        }
        this.sink.event(t, x);
    };
    SafeSink.prototype.end = function (t) {
        if (!this.active) {
            return;
        }
        this.disable();
        this.sink.end(t);
    };
    SafeSink.prototype.error = function (t, e) {
        this.disable();
        this.sink.error(t, e);
    };
    SafeSink.prototype.disable = function () {
        this.active = false;
        return this.sink;
    };
    return SafeSink;
}());

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */
function tryEvent(t, x, sink) {
    try {
        sink.event(t, x);
    }
    catch (e) {
        sink.error(t, e);
    }
}
function tryEnd(t, sink) {
    try {
        sink.end(t);
    }
    catch (e) {
        sink.error(t, e);
    }
}

/** @license MIT License (c) copyright 2010-2016 original author or authors */
/**
 * If stream encounters an error, recover and continue with items from stream
 * returned by f.
 * @param f which returns a new stream
 * @param stream
 * @returns new stream which will recover from an error by calling f
 */
var recoverWith = function (f, stream) {
    return isCanonicalEmpty(stream) ? empty()
        : new RecoverWith(f, stream);
};
/**
 * Create a stream containing only an error
 * @param e error value, preferably an Error or Error subtype
 * @returns new stream containing only an error
 */
var throwError = function (e) {
    return new ErrorStream(e);
};
var ErrorStream = /** @class */ (function () {
    function ErrorStream(e) {
        this.value = e;
    }
    ErrorStream.prototype.run = function (sink, scheduler) {
        return asap(propagateErrorTask(this.value, sink), scheduler);
    };
    return ErrorStream;
}());
var RecoverWith = /** @class */ (function () {
    function RecoverWith(f, source) {
        this.f = f;
        this.source = source;
    }
    RecoverWith.prototype.run = function (sink, scheduler) {
        return new RecoverWithSink(this.f, this.source, sink, scheduler);
    };
    return RecoverWith;
}());
var RecoverWithSink = /** @class */ (function () {
    function RecoverWithSink(f, source, sink, scheduler) {
        this.f = f;
        this.sink = new SafeSink(sink);
        this.scheduler = scheduler;
        this.disposable = source.run(this, scheduler);
    }
    RecoverWithSink.prototype.event = function (t, x) {
        tryEvent(t, x, this.sink);
    };
    RecoverWithSink.prototype.end = function (t) {
        tryEnd(t, this.sink);
    };
    RecoverWithSink.prototype.error = function (t, e) {
        var nextSink = this.sink.disable();
        tryDispose$1(t, this.disposable, this.sink);
        this._startNext(t, e, nextSink);
    };
    RecoverWithSink.prototype._startNext = function (t, x, sink) {
        try {
            this.disposable = this._continue(this.f, t, x, sink);
        }
        catch (e) {
            sink.error(t, e);
        }
    };
    RecoverWithSink.prototype._continue = function (f, t, x, sink) {
        return run(sink, this.scheduler, withLocalTime(t, f(x)));
    };
    RecoverWithSink.prototype.dispose = function () {
        return this.disposable.dispose();
    };
    return RecoverWithSink;
}());

var multicast = function (stream) {
    return stream instanceof Multicast || isCanonicalEmpty(stream)
        ? stream
        : new Multicast(stream);
};
var Multicast = /** @class */ (function () {
    function Multicast(source) {
        this.source = new MulticastSource(source);
    }
    Multicast.prototype.run = function (sink, scheduler) {
        return this.source.run(sink, scheduler);
    };
    return Multicast;
}());
var MulticastSource = /** @class */ (function () {
    function MulticastSource(source) {
        this.source = source;
        this.sinks = [];
        this.disposable = disposeNone();
    }
    MulticastSource.prototype.run = function (sink, scheduler) {
        var n = this.add(sink);
        if (n === 1) {
            this.disposable = this.source.run(this, scheduler);
        }
        return disposeOnce(new MulticastDisposable(this, sink));
    };
    MulticastSource.prototype.dispose = function () {
        var disposable = this.disposable;
        this.disposable = disposeNone();
        return disposable.dispose();
    };
    MulticastSource.prototype.add = function (sink) {
        this.sinks = append(sink, this.sinks);
        return this.sinks.length;
    };
    MulticastSource.prototype.remove = function (sink) {
        var i = findIndex(sink, this.sinks);
        // istanbul ignore next
        if (i >= 0) {
            this.sinks = remove(i, this.sinks);
        }
        return this.sinks.length;
    };
    MulticastSource.prototype.event = function (time, value) {
        var s = this.sinks;
        if (s.length === 1) {
            return s[0].event(time, value);
        }
        for (var i = 0; i < s.length; ++i) {
            tryEvent(time, value, s[i]);
        }
    };
    MulticastSource.prototype.end = function (time) {
        var s = this.sinks;
        for (var i = 0; i < s.length; ++i) {
            tryEnd(time, s[i]);
        }
    };
    MulticastSource.prototype.error = function (time, err) {
        var s = this.sinks;
        for (var i = 0; i < s.length; ++i) {
            s[i].error(time, err);
        }
    };
    return MulticastSource;
}());
var MulticastDisposable = /** @class */ (function () {
    function MulticastDisposable(source, sink) {
        this.source = source;
        this.sink = sink;
    }
    MulticastDisposable.prototype.dispose = function () {
        if (this.source.remove(this.sink) === 0) {
            this.source.dispose();
        }
    };
    return MulticastDisposable;
}());

/** @license MIT License (c) copyright 2016 original author or authors */
var run$1 = curry3(run);
var withLocalTime$1 = curry2(withLocalTime);
var loop$1 = curry3(loop);
var scan$1 = curry3(scan);
var startWith$1 = curry2(startWith);
var map$1 = curry2(map);
var constant$1 = curry2(constant);
var tap$1 = curry2(tap);
var ap$1 = curry2(ap);
var chain$1 = curry2(chain);
var continueWith$1 = curry2(continueWith);
var concatMap$1 = curry2(concatMap);
var mergeConcurrently$1 = curry2(mergeConcurrently);
var mergeMapConcurrently$1 = curry3(mergeMapConcurrently);
var merge$1 = curry2(merge);
var combine$1 = curry3(combine);
var combineArray$1 = curry2(combineArray);
var sample$1 = curry2(sample);
var snapshot$1 = curry3(snapshot);
var zipItems$1 = curry3(zipItems);
var withItems$1 = curry2(withItems);
var zip$1 = curry3(zip);
var zipArray$1 = curry2(zipArray);
var filter$1 = curry2(filter);
var skipRepeatsWith$1 = curry2(skipRepeatsWith);
var take$1 = curry2(take);
var skip$1 = curry2(skip);
var slice$1 = curry3(slice);
var takeWhile$1 = curry2(takeWhile);
var skipWhile$1 = curry2(skipWhile);
var skipAfter$1 = curry2(skipAfter);
var until$1 = curry2(until);
var since$1 = curry2(since);
var during$1 = curry2(during);
var delay$1 = curry2(delay);
var throttle$1 = curry2(throttle);
var debounce$1 = curry2(debounce);
var recoverWith$1 = curry2(recoverWith);
var propagateTask$1 = curry3(propagateTask);
var propagateEventTask$1 = curry2(propagateEventTask);
var propagateErrorTask$1 = curry2(propagateErrorTask);

export { MulticastSource, ap$1 as ap, at, awaitPromises, chain$1 as chain, combine$1 as combine, combineArray$1 as combineArray, concatMap$1 as concatMap, constant$1 as constant, continueWith$1 as continueWith, debounce$1 as debounce, delay$1 as delay, during$1 as during, empty, filter$1 as filter, fromPromise, join, loop$1 as loop, map$1 as map, merge$1 as merge, mergeArray, mergeConcurrently$1 as mergeConcurrently, mergeMapConcurrently$1 as mergeMapConcurrently, multicast, never, newStream, now, periodic, propagateEndTask, propagateErrorTask$1 as propagateErrorTask, propagateEventTask$1 as propagateEventTask, propagateTask$1 as propagateTask, recoverWith$1 as recoverWith, run$1 as run, runEffects, sample$1 as sample, scan$1 as scan, since$1 as since, skip$1 as skip, skipAfter$1 as skipAfter, skipRepeats, skipRepeatsWith$1 as skipRepeatsWith, skipWhile$1 as skipWhile, slice$1 as slice, snapshot$1 as snapshot, startWith$1 as startWith, switchLatest, take$1 as take, takeWhile$1 as takeWhile, tap$1 as tap, throttle$1 as throttle, throwError, until$1 as until, withItems$1 as withItems, withLocalTime$1 as withLocalTime, zip$1 as zip, zipArray$1 as zipArray, zipItems$1 as zipItems };
//# sourceMappingURL=index.es.js.map
